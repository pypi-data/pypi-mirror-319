import sys
from types import GenericAlias
from typing import _S, _T, Callable, Iterable, Iterator, MutableSequence, Optional, Any, Self, SupportsIndex, overload

class Vector:
    pass

class i8:
    def __init__(self, value: int) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, new_value: int) -> None: ...


class int:
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...
    def __lt__(self, other: object, /) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __gt__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...
    def __add__(self, other: object, /) -> num: ...
    def __sub__(self, other: object, /) -> num: ...
    def __mul__(self, other: object, /) -> num: ...
    def __truediv__(self, other: object, /) -> num: ...
    def __floordiv__(self, other: object, /) -> num: ...
    def __mod__(self, other: object, /) -> num: ...
    def __pow__(self, other: object, /) -> num: ...
    def __neg__(self) -> num: ...
    def __pos__(self) -> num: ...
    def __abs__(self) -> num: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    

class num:
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...
    def __lt__(self, other: object, /) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __gt__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...
    def __add__(self, other: object, /) -> num: ...
    def __sub__(self, other: object, /) -> num: ...
    def __mul__(self, other: object, /) -> num: ...
    def __truediv__(self, other: object, /) -> num: ...
    def __floordiv__(self, other: object, /) -> num: ...
    def __mod__(self, other: object, /) -> num: ...
    def __pow__(self, other: object, /) -> num: ...
    def __neg__(self) -> num: ...
    def __pos__(self) -> num: ...
    def __abs__(self) -> num: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...

class list(MutableSequence[_T]):

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, iterable: Iterable[_T], /) -> None: ...
    
    def copy(self) -> Self[_T]: ...
    def append(self, object: _T, /) -> None: ...
    def extend(self, iterable: Iterable[_T], /) -> None: ...
    def pop(self, index: SupportsIndex = -1, /) -> _T: ...
    # Signature of `list.index` should be kept in line with `collections.UserList.index()`
    # and multiprocessing.managers.ListProxy.index()
    def index(self, value: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
    def count(self, value: _T, /) -> int: ...
    def insert(self, index: SupportsIndex, object: _T, /) -> None: ...
    def remove(self, value: _T, /) -> None: ...
    # Signature of `list.sort` should be kept inline with `collections.UserList.sort()`
    # and multiprocessing.managers.ListProxy.sort()
    #
    # Use list[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]
    # to work around invariance
    @overload
    def sort(self: list[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...
    @overload
    def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    __hash__: ClassVar[None]  # type: ignore[assignment]
    @overload
    def __getitem__(self, i: SupportsIndex, /) -> _T: ...
    @overload
    def __getitem__(self, s: slice, /) -> list[_T]: ...
    @overload
    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...
    @overload
    def __setitem__(self, key: slice, value: Iterable[_T], /) -> None: ...
    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...
    # Overloading looks unnecessary, but is needed to work around complex mypy problems
    @overload
    def __add__(self, value: list[_T], /) -> list[_T]: ...
    @overload
    def __add__(self, value: list[_S], /) -> list[_S | _T]: ...
    def __iadd__(self, value: Iterable[_T], /) -> Self: ...  # type: ignore[misc]
    def __mul__(self, value: SupportsIndex, /) -> list[_T]: ...
    def __rmul__(self, value: SupportsIndex, /) -> list[_T]: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __contains__(self, key: object, /) -> bool: ...
    def __reversed__(self) -> Iterator[_T]: ...
    def __gt__(self, value: list[_T], /) -> bool: ...
    def __ge__(self, value: list[_T], /) -> bool: ...
    def __lt__(self, value: list[_T], /) -> bool: ...
    def __le__(self, value: list[_T], /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    # if sys.version_info >= (3, 9):
    #     def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...