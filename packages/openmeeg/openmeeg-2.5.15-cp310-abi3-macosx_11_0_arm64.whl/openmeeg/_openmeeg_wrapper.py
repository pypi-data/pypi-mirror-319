# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""OpenMEEG bindings for python"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _openmeeg
else:
    import _openmeeg

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class Error(object):
    r"""Proxy of C++ Error class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t, m):
        r"""__init__(Error self, int const t, char const * m) -> Error"""
        _openmeeg.Error_swiginit(self, _openmeeg.new_Error(t, m))

    def type(self):
        r"""type(Error self) -> int"""
        return _openmeeg.Error_type(self)

    def message(self):
        r"""message(Error self) -> std::string const &"""
        return _openmeeg.Error_message(self)
    __swig_destroy__ = _openmeeg.delete_Error

# Register Error in _openmeeg:
_openmeeg.Error_swigregister(Error)
class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmeeg.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _openmeeg.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _openmeeg.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _openmeeg.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _openmeeg.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _openmeeg.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _openmeeg.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _openmeeg.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _openmeeg.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _openmeeg.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _openmeeg.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _openmeeg.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _openmeeg.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _openmeeg.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _openmeeg.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _openmeeg.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _openmeeg.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _openmeeg:
_openmeeg.SwigPyIterator_swigregister(SwigPyIterator)
class vector_int(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_int self) -> SwigPyIterator"""
        return _openmeeg.vector_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_int self) -> bool"""
        return _openmeeg.vector_int___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_int self) -> bool"""
        return _openmeeg.vector_int___bool__(self)

    def __len__(self):
        r"""__len__(vector_int self) -> std::vector< int >::size_type"""
        return _openmeeg.vector_int___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> vector_int"""
        return _openmeeg.vector_int___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, vector_int v)
        """
        return _openmeeg.vector_int___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _openmeeg.vector_int___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_int self, std::vector< int >::difference_type i)
        __delitem__(vector_int self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_int___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_int self, SWIGPY_SLICEOBJECT * slice) -> vector_int
        __getitem__(vector_int self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _openmeeg.vector_int___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_int self, SWIGPY_SLICEOBJECT * slice, vector_int v)
        __setitem__(vector_int self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _openmeeg.vector_int___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_int self) -> std::vector< int >::value_type"""
        return _openmeeg.vector_int_pop(self)

    def append(self, x):
        r"""append(vector_int self, std::vector< int >::value_type const & x)"""
        return _openmeeg.vector_int_append(self, x)

    def empty(self):
        r"""empty(vector_int self) -> bool"""
        return _openmeeg.vector_int_empty(self)

    def size(self):
        r"""size(vector_int self) -> std::vector< int >::size_type"""
        return _openmeeg.vector_int_size(self)

    def swap(self, v):
        r"""swap(vector_int self, vector_int v)"""
        return _openmeeg.vector_int_swap(self, v)

    def begin(self):
        r"""begin(vector_int self) -> std::vector< int >::iterator"""
        return _openmeeg.vector_int_begin(self)

    def end(self):
        r"""end(vector_int self) -> std::vector< int >::iterator"""
        return _openmeeg.vector_int_end(self)

    def rbegin(self):
        r"""rbegin(vector_int self) -> std::vector< int >::reverse_iterator"""
        return _openmeeg.vector_int_rbegin(self)

    def rend(self):
        r"""rend(vector_int self) -> std::vector< int >::reverse_iterator"""
        return _openmeeg.vector_int_rend(self)

    def clear(self):
        r"""clear(vector_int self)"""
        return _openmeeg.vector_int_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_int self) -> std::vector< int >::allocator_type"""
        return _openmeeg.vector_int_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_int self)"""
        return _openmeeg.vector_int_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_int self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(vector_int self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _openmeeg.vector_int_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_int self) -> vector_int
        __init__(vector_int self, vector_int other) -> vector_int
        __init__(vector_int self, std::vector< int >::size_type size) -> vector_int
        __init__(vector_int self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_int
        """
        _openmeeg.vector_int_swiginit(self, _openmeeg.new_vector_int(*args))

    def push_back(self, x):
        r"""push_back(vector_int self, std::vector< int >::value_type const & x)"""
        return _openmeeg.vector_int_push_back(self, x)

    def front(self):
        r"""front(vector_int self) -> std::vector< int >::value_type const &"""
        return _openmeeg.vector_int_front(self)

    def back(self):
        r"""back(vector_int self) -> std::vector< int >::value_type const &"""
        return _openmeeg.vector_int_back(self)

    def assign(self, n, x):
        r"""assign(vector_int self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _openmeeg.vector_int_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_int self, std::vector< int >::size_type new_size)
        resize(vector_int self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _openmeeg.vector_int_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_int self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(vector_int self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _openmeeg.vector_int_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_int self, std::vector< int >::size_type n)"""
        return _openmeeg.vector_int_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_int self) -> std::vector< int >::size_type"""
        return _openmeeg.vector_int_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_int

# Register vector_int in _openmeeg:
_openmeeg.vector_int_swigregister(vector_int)
class vector_unsigned(object):
    r"""Proxy of C++ std::vector< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_unsigned self) -> SwigPyIterator"""
        return _openmeeg.vector_unsigned_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_unsigned self) -> bool"""
        return _openmeeg.vector_unsigned___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_unsigned self) -> bool"""
        return _openmeeg.vector_unsigned___bool__(self)

    def __len__(self):
        r"""__len__(vector_unsigned self) -> std::vector< unsigned int >::size_type"""
        return _openmeeg.vector_unsigned___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_unsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> vector_unsigned"""
        return _openmeeg.vector_unsigned___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_unsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(vector_unsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, vector_unsigned v)
        """
        return _openmeeg.vector_unsigned___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_unsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _openmeeg.vector_unsigned___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_unsigned self, std::vector< unsigned int >::difference_type i)
        __delitem__(vector_unsigned self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_unsigned___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_unsigned self, SWIGPY_SLICEOBJECT * slice) -> vector_unsigned
        __getitem__(vector_unsigned self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _openmeeg.vector_unsigned___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_unsigned self, SWIGPY_SLICEOBJECT * slice, vector_unsigned v)
        __setitem__(vector_unsigned self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_unsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _openmeeg.vector_unsigned___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_unsigned self) -> std::vector< unsigned int >::value_type"""
        return _openmeeg.vector_unsigned_pop(self)

    def append(self, x):
        r"""append(vector_unsigned self, std::vector< unsigned int >::value_type const & x)"""
        return _openmeeg.vector_unsigned_append(self, x)

    def empty(self):
        r"""empty(vector_unsigned self) -> bool"""
        return _openmeeg.vector_unsigned_empty(self)

    def size(self):
        r"""size(vector_unsigned self) -> std::vector< unsigned int >::size_type"""
        return _openmeeg.vector_unsigned_size(self)

    def swap(self, v):
        r"""swap(vector_unsigned self, vector_unsigned v)"""
        return _openmeeg.vector_unsigned_swap(self, v)

    def begin(self):
        r"""begin(vector_unsigned self) -> std::vector< unsigned int >::iterator"""
        return _openmeeg.vector_unsigned_begin(self)

    def end(self):
        r"""end(vector_unsigned self) -> std::vector< unsigned int >::iterator"""
        return _openmeeg.vector_unsigned_end(self)

    def rbegin(self):
        r"""rbegin(vector_unsigned self) -> std::vector< unsigned int >::reverse_iterator"""
        return _openmeeg.vector_unsigned_rbegin(self)

    def rend(self):
        r"""rend(vector_unsigned self) -> std::vector< unsigned int >::reverse_iterator"""
        return _openmeeg.vector_unsigned_rend(self)

    def clear(self):
        r"""clear(vector_unsigned self)"""
        return _openmeeg.vector_unsigned_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_unsigned self) -> std::vector< unsigned int >::allocator_type"""
        return _openmeeg.vector_unsigned_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_unsigned self)"""
        return _openmeeg.vector_unsigned_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_unsigned self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(vector_unsigned self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _openmeeg.vector_unsigned_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_unsigned self) -> vector_unsigned
        __init__(vector_unsigned self, vector_unsigned other) -> vector_unsigned
        __init__(vector_unsigned self, std::vector< unsigned int >::size_type size) -> vector_unsigned
        __init__(vector_unsigned self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> vector_unsigned
        """
        _openmeeg.vector_unsigned_swiginit(self, _openmeeg.new_vector_unsigned(*args))

    def push_back(self, x):
        r"""push_back(vector_unsigned self, std::vector< unsigned int >::value_type const & x)"""
        return _openmeeg.vector_unsigned_push_back(self, x)

    def front(self):
        r"""front(vector_unsigned self) -> std::vector< unsigned int >::value_type const &"""
        return _openmeeg.vector_unsigned_front(self)

    def back(self):
        r"""back(vector_unsigned self) -> std::vector< unsigned int >::value_type const &"""
        return _openmeeg.vector_unsigned_back(self)

    def assign(self, n, x):
        r"""assign(vector_unsigned self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _openmeeg.vector_unsigned_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_unsigned self, std::vector< unsigned int >::size_type new_size)
        resize(vector_unsigned self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _openmeeg.vector_unsigned_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_unsigned self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(vector_unsigned self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _openmeeg.vector_unsigned_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_unsigned self, std::vector< unsigned int >::size_type n)"""
        return _openmeeg.vector_unsigned_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_unsigned self) -> std::vector< unsigned int >::size_type"""
        return _openmeeg.vector_unsigned_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_unsigned

# Register vector_unsigned in _openmeeg:
_openmeeg.vector_unsigned_swigregister(vector_unsigned)
class vector_double(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_double self) -> SwigPyIterator"""
        return _openmeeg.vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_double self) -> bool"""
        return _openmeeg.vector_double___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_double self) -> bool"""
        return _openmeeg.vector_double___bool__(self)

    def __len__(self):
        r"""__len__(vector_double self) -> std::vector< double >::size_type"""
        return _openmeeg.vector_double___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vector_double"""
        return _openmeeg.vector_double___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vector_double v)
        """
        return _openmeeg.vector_double___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _openmeeg.vector_double___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_double self, std::vector< double >::difference_type i)
        __delitem__(vector_double self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_double___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_double self, SWIGPY_SLICEOBJECT * slice) -> vector_double
        __getitem__(vector_double self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _openmeeg.vector_double___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_double self, SWIGPY_SLICEOBJECT * slice, vector_double v)
        __setitem__(vector_double self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_double self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _openmeeg.vector_double___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_double self) -> std::vector< double >::value_type"""
        return _openmeeg.vector_double_pop(self)

    def append(self, x):
        r"""append(vector_double self, std::vector< double >::value_type const & x)"""
        return _openmeeg.vector_double_append(self, x)

    def empty(self):
        r"""empty(vector_double self) -> bool"""
        return _openmeeg.vector_double_empty(self)

    def size(self):
        r"""size(vector_double self) -> std::vector< double >::size_type"""
        return _openmeeg.vector_double_size(self)

    def swap(self, v):
        r"""swap(vector_double self, vector_double v)"""
        return _openmeeg.vector_double_swap(self, v)

    def begin(self):
        r"""begin(vector_double self) -> std::vector< double >::iterator"""
        return _openmeeg.vector_double_begin(self)

    def end(self):
        r"""end(vector_double self) -> std::vector< double >::iterator"""
        return _openmeeg.vector_double_end(self)

    def rbegin(self):
        r"""rbegin(vector_double self) -> std::vector< double >::reverse_iterator"""
        return _openmeeg.vector_double_rbegin(self)

    def rend(self):
        r"""rend(vector_double self) -> std::vector< double >::reverse_iterator"""
        return _openmeeg.vector_double_rend(self)

    def clear(self):
        r"""clear(vector_double self)"""
        return _openmeeg.vector_double_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_double self) -> std::vector< double >::allocator_type"""
        return _openmeeg.vector_double_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_double self)"""
        return _openmeeg.vector_double_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_double self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vector_double self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _openmeeg.vector_double_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_double self) -> vector_double
        __init__(vector_double self, vector_double other) -> vector_double
        __init__(vector_double self, std::vector< double >::size_type size) -> vector_double
        __init__(vector_double self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vector_double
        """
        _openmeeg.vector_double_swiginit(self, _openmeeg.new_vector_double(*args))

    def push_back(self, x):
        r"""push_back(vector_double self, std::vector< double >::value_type const & x)"""
        return _openmeeg.vector_double_push_back(self, x)

    def front(self):
        r"""front(vector_double self) -> std::vector< double >::value_type const &"""
        return _openmeeg.vector_double_front(self)

    def back(self):
        r"""back(vector_double self) -> std::vector< double >::value_type const &"""
        return _openmeeg.vector_double_back(self)

    def assign(self, n, x):
        r"""assign(vector_double self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _openmeeg.vector_double_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_double self, std::vector< double >::size_type new_size)
        resize(vector_double self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _openmeeg.vector_double_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_double self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vector_double self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _openmeeg.vector_double_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_double self, std::vector< double >::size_type n)"""
        return _openmeeg.vector_double_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_double self) -> std::vector< double >::size_type"""
        return _openmeeg.vector_double_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_double

# Register vector_double in _openmeeg:
_openmeeg.vector_double_swigregister(vector_double)
class vector_vertex(object):
    r"""Proxy of C++ std::vector< OpenMEEG::Vertex > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_vertex self) -> SwigPyIterator"""
        return _openmeeg.vector_vertex_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_vertex self) -> bool"""
        return _openmeeg.vector_vertex___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_vertex self) -> bool"""
        return _openmeeg.vector_vertex___bool__(self)

    def __len__(self):
        r"""__len__(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::size_type"""
        return _openmeeg.vector_vertex___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_vertex self, std::vector< OpenMEEG::Vertex >::difference_type i, std::vector< OpenMEEG::Vertex >::difference_type j) -> vector_vertex"""
        return _openmeeg.vector_vertex___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_vertex self, std::vector< OpenMEEG::Vertex >::difference_type i, std::vector< OpenMEEG::Vertex >::difference_type j)
        __setslice__(vector_vertex self, std::vector< OpenMEEG::Vertex >::difference_type i, std::vector< OpenMEEG::Vertex >::difference_type j, vector_vertex v)
        """
        return _openmeeg.vector_vertex___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_vertex self, std::vector< OpenMEEG::Vertex >::difference_type i, std::vector< OpenMEEG::Vertex >::difference_type j)"""
        return _openmeeg.vector_vertex___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_vertex self, std::vector< OpenMEEG::Vertex >::difference_type i)
        __delitem__(vector_vertex self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_vertex___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_vertex self, SWIGPY_SLICEOBJECT * slice) -> vector_vertex
        __getitem__(vector_vertex self, std::vector< OpenMEEG::Vertex >::difference_type i) -> Vertex
        """
        return _openmeeg.vector_vertex___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_vertex self, SWIGPY_SLICEOBJECT * slice, vector_vertex v)
        __setitem__(vector_vertex self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_vertex self, std::vector< OpenMEEG::Vertex >::difference_type i, Vertex x)
        """
        return _openmeeg.vector_vertex___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_vertex self) -> Vertex"""
        return _openmeeg.vector_vertex_pop(self)

    def append(self, x):
        r"""append(vector_vertex self, Vertex x)"""
        return _openmeeg.vector_vertex_append(self, x)

    def empty(self):
        r"""empty(vector_vertex self) -> bool"""
        return _openmeeg.vector_vertex_empty(self)

    def size(self):
        r"""size(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::size_type"""
        return _openmeeg.vector_vertex_size(self)

    def swap(self, v):
        r"""swap(vector_vertex self, vector_vertex v)"""
        return _openmeeg.vector_vertex_swap(self, v)

    def begin(self):
        r"""begin(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::iterator"""
        return _openmeeg.vector_vertex_begin(self)

    def end(self):
        r"""end(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::iterator"""
        return _openmeeg.vector_vertex_end(self)

    def rbegin(self):
        r"""rbegin(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::reverse_iterator"""
        return _openmeeg.vector_vertex_rbegin(self)

    def rend(self):
        r"""rend(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::reverse_iterator"""
        return _openmeeg.vector_vertex_rend(self)

    def clear(self):
        r"""clear(vector_vertex self)"""
        return _openmeeg.vector_vertex_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::allocator_type"""
        return _openmeeg.vector_vertex_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_vertex self)"""
        return _openmeeg.vector_vertex_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_vertex self, std::vector< OpenMEEG::Vertex >::iterator pos) -> std::vector< OpenMEEG::Vertex >::iterator
        erase(vector_vertex self, std::vector< OpenMEEG::Vertex >::iterator first, std::vector< OpenMEEG::Vertex >::iterator last) -> std::vector< OpenMEEG::Vertex >::iterator
        """
        return _openmeeg.vector_vertex_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_vertex self) -> vector_vertex
        __init__(vector_vertex self, vector_vertex other) -> vector_vertex
        __init__(vector_vertex self, std::vector< OpenMEEG::Vertex >::size_type size) -> vector_vertex
        __init__(vector_vertex self, std::vector< OpenMEEG::Vertex >::size_type size, Vertex value) -> vector_vertex
        """
        _openmeeg.vector_vertex_swiginit(self, _openmeeg.new_vector_vertex(*args))

    def push_back(self, x):
        r"""push_back(vector_vertex self, Vertex x)"""
        return _openmeeg.vector_vertex_push_back(self, x)

    def front(self):
        r"""front(vector_vertex self) -> Vertex"""
        return _openmeeg.vector_vertex_front(self)

    def back(self):
        r"""back(vector_vertex self) -> Vertex"""
        return _openmeeg.vector_vertex_back(self)

    def assign(self, n, x):
        r"""assign(vector_vertex self, std::vector< OpenMEEG::Vertex >::size_type n, Vertex x)"""
        return _openmeeg.vector_vertex_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_vertex self, std::vector< OpenMEEG::Vertex >::size_type new_size)
        resize(vector_vertex self, std::vector< OpenMEEG::Vertex >::size_type new_size, Vertex x)
        """
        return _openmeeg.vector_vertex_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_vertex self, std::vector< OpenMEEG::Vertex >::iterator pos, Vertex x) -> std::vector< OpenMEEG::Vertex >::iterator
        insert(vector_vertex self, std::vector< OpenMEEG::Vertex >::iterator pos, std::vector< OpenMEEG::Vertex >::size_type n, Vertex x)
        """
        return _openmeeg.vector_vertex_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_vertex self, std::vector< OpenMEEG::Vertex >::size_type n)"""
        return _openmeeg.vector_vertex_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_vertex self) -> std::vector< OpenMEEG::Vertex >::size_type"""
        return _openmeeg.vector_vertex_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_vertex

# Register vector_vertex in _openmeeg:
_openmeeg.vector_vertex_swigregister(vector_vertex)
class vector_pvertex(object):
    r"""Proxy of C++ std::vector< OpenMEEG::Vertex * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_pvertex self) -> SwigPyIterator"""
        return _openmeeg.vector_pvertex_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_pvertex self) -> bool"""
        return _openmeeg.vector_pvertex___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_pvertex self) -> bool"""
        return _openmeeg.vector_pvertex___bool__(self)

    def __len__(self):
        r"""__len__(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::size_type"""
        return _openmeeg.vector_pvertex___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::difference_type i, std::vector< OpenMEEG::Vertex * >::difference_type j) -> vector_pvertex"""
        return _openmeeg.vector_pvertex___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::difference_type i, std::vector< OpenMEEG::Vertex * >::difference_type j)
        __setslice__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::difference_type i, std::vector< OpenMEEG::Vertex * >::difference_type j, vector_pvertex v)
        """
        return _openmeeg.vector_pvertex___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::difference_type i, std::vector< OpenMEEG::Vertex * >::difference_type j)"""
        return _openmeeg.vector_pvertex___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::difference_type i)
        __delitem__(vector_pvertex self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_pvertex___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_pvertex self, SWIGPY_SLICEOBJECT * slice) -> vector_pvertex
        __getitem__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::difference_type i) -> Vertex
        """
        return _openmeeg.vector_pvertex___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_pvertex self, SWIGPY_SLICEOBJECT * slice, vector_pvertex v)
        __setitem__(vector_pvertex self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::difference_type i, Vertex x)
        """
        return _openmeeg.vector_pvertex___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_pvertex self) -> Vertex"""
        return _openmeeg.vector_pvertex_pop(self)

    def append(self, x):
        r"""append(vector_pvertex self, Vertex x)"""
        return _openmeeg.vector_pvertex_append(self, x)

    def empty(self):
        r"""empty(vector_pvertex self) -> bool"""
        return _openmeeg.vector_pvertex_empty(self)

    def size(self):
        r"""size(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::size_type"""
        return _openmeeg.vector_pvertex_size(self)

    def swap(self, v):
        r"""swap(vector_pvertex self, vector_pvertex v)"""
        return _openmeeg.vector_pvertex_swap(self, v)

    def begin(self):
        r"""begin(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::iterator"""
        return _openmeeg.vector_pvertex_begin(self)

    def end(self):
        r"""end(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::iterator"""
        return _openmeeg.vector_pvertex_end(self)

    def rbegin(self):
        r"""rbegin(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::reverse_iterator"""
        return _openmeeg.vector_pvertex_rbegin(self)

    def rend(self):
        r"""rend(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::reverse_iterator"""
        return _openmeeg.vector_pvertex_rend(self)

    def clear(self):
        r"""clear(vector_pvertex self)"""
        return _openmeeg.vector_pvertex_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::allocator_type"""
        return _openmeeg.vector_pvertex_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_pvertex self)"""
        return _openmeeg.vector_pvertex_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::iterator pos) -> std::vector< OpenMEEG::Vertex * >::iterator
        erase(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::iterator first, std::vector< OpenMEEG::Vertex * >::iterator last) -> std::vector< OpenMEEG::Vertex * >::iterator
        """
        return _openmeeg.vector_pvertex_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_pvertex self) -> vector_pvertex
        __init__(vector_pvertex self, vector_pvertex other) -> vector_pvertex
        __init__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::size_type size) -> vector_pvertex
        __init__(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::size_type size, Vertex value) -> vector_pvertex
        """
        _openmeeg.vector_pvertex_swiginit(self, _openmeeg.new_vector_pvertex(*args))

    def push_back(self, x):
        r"""push_back(vector_pvertex self, Vertex x)"""
        return _openmeeg.vector_pvertex_push_back(self, x)

    def front(self):
        r"""front(vector_pvertex self) -> Vertex"""
        return _openmeeg.vector_pvertex_front(self)

    def back(self):
        r"""back(vector_pvertex self) -> Vertex"""
        return _openmeeg.vector_pvertex_back(self)

    def assign(self, n, x):
        r"""assign(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::size_type n, Vertex x)"""
        return _openmeeg.vector_pvertex_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::size_type new_size)
        resize(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::size_type new_size, Vertex x)
        """
        return _openmeeg.vector_pvertex_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::iterator pos, Vertex x) -> std::vector< OpenMEEG::Vertex * >::iterator
        insert(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::iterator pos, std::vector< OpenMEEG::Vertex * >::size_type n, Vertex x)
        """
        return _openmeeg.vector_pvertex_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_pvertex self, std::vector< OpenMEEG::Vertex * >::size_type n)"""
        return _openmeeg.vector_pvertex_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_pvertex self) -> std::vector< OpenMEEG::Vertex * >::size_type"""
        return _openmeeg.vector_pvertex_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_pvertex

# Register vector_pvertex in _openmeeg:
_openmeeg.vector_pvertex_swigregister(vector_pvertex)
class vector_triangle(object):
    r"""Proxy of C++ std::vector< OpenMEEG::Triangle > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_triangle self) -> SwigPyIterator"""
        return _openmeeg.vector_triangle_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_triangle self) -> bool"""
        return _openmeeg.vector_triangle___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_triangle self) -> bool"""
        return _openmeeg.vector_triangle___bool__(self)

    def __len__(self):
        r"""__len__(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::size_type"""
        return _openmeeg.vector_triangle___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_triangle self, std::vector< OpenMEEG::Triangle >::difference_type i, std::vector< OpenMEEG::Triangle >::difference_type j) -> vector_triangle"""
        return _openmeeg.vector_triangle___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_triangle self, std::vector< OpenMEEG::Triangle >::difference_type i, std::vector< OpenMEEG::Triangle >::difference_type j)
        __setslice__(vector_triangle self, std::vector< OpenMEEG::Triangle >::difference_type i, std::vector< OpenMEEG::Triangle >::difference_type j, vector_triangle v)
        """
        return _openmeeg.vector_triangle___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_triangle self, std::vector< OpenMEEG::Triangle >::difference_type i, std::vector< OpenMEEG::Triangle >::difference_type j)"""
        return _openmeeg.vector_triangle___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_triangle self, std::vector< OpenMEEG::Triangle >::difference_type i)
        __delitem__(vector_triangle self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_triangle___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_triangle self, SWIGPY_SLICEOBJECT * slice) -> vector_triangle
        __getitem__(vector_triangle self, std::vector< OpenMEEG::Triangle >::difference_type i) -> Triangle
        """
        return _openmeeg.vector_triangle___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_triangle self, SWIGPY_SLICEOBJECT * slice, vector_triangle v)
        __setitem__(vector_triangle self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_triangle self, std::vector< OpenMEEG::Triangle >::difference_type i, Triangle x)
        """
        return _openmeeg.vector_triangle___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_triangle self) -> Triangle"""
        return _openmeeg.vector_triangle_pop(self)

    def append(self, x):
        r"""append(vector_triangle self, Triangle x)"""
        return _openmeeg.vector_triangle_append(self, x)

    def empty(self):
        r"""empty(vector_triangle self) -> bool"""
        return _openmeeg.vector_triangle_empty(self)

    def size(self):
        r"""size(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::size_type"""
        return _openmeeg.vector_triangle_size(self)

    def swap(self, v):
        r"""swap(vector_triangle self, vector_triangle v)"""
        return _openmeeg.vector_triangle_swap(self, v)

    def begin(self):
        r"""begin(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::iterator"""
        return _openmeeg.vector_triangle_begin(self)

    def end(self):
        r"""end(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::iterator"""
        return _openmeeg.vector_triangle_end(self)

    def rbegin(self):
        r"""rbegin(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::reverse_iterator"""
        return _openmeeg.vector_triangle_rbegin(self)

    def rend(self):
        r"""rend(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::reverse_iterator"""
        return _openmeeg.vector_triangle_rend(self)

    def clear(self):
        r"""clear(vector_triangle self)"""
        return _openmeeg.vector_triangle_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::allocator_type"""
        return _openmeeg.vector_triangle_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_triangle self)"""
        return _openmeeg.vector_triangle_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_triangle self, std::vector< OpenMEEG::Triangle >::iterator pos) -> std::vector< OpenMEEG::Triangle >::iterator
        erase(vector_triangle self, std::vector< OpenMEEG::Triangle >::iterator first, std::vector< OpenMEEG::Triangle >::iterator last) -> std::vector< OpenMEEG::Triangle >::iterator
        """
        return _openmeeg.vector_triangle_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_triangle self) -> vector_triangle
        __init__(vector_triangle self, vector_triangle other) -> vector_triangle
        __init__(vector_triangle self, std::vector< OpenMEEG::Triangle >::size_type size) -> vector_triangle
        __init__(vector_triangle self, std::vector< OpenMEEG::Triangle >::size_type size, Triangle value) -> vector_triangle
        """
        _openmeeg.vector_triangle_swiginit(self, _openmeeg.new_vector_triangle(*args))

    def push_back(self, x):
        r"""push_back(vector_triangle self, Triangle x)"""
        return _openmeeg.vector_triangle_push_back(self, x)

    def front(self):
        r"""front(vector_triangle self) -> Triangle"""
        return _openmeeg.vector_triangle_front(self)

    def back(self):
        r"""back(vector_triangle self) -> Triangle"""
        return _openmeeg.vector_triangle_back(self)

    def assign(self, n, x):
        r"""assign(vector_triangle self, std::vector< OpenMEEG::Triangle >::size_type n, Triangle x)"""
        return _openmeeg.vector_triangle_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_triangle self, std::vector< OpenMEEG::Triangle >::size_type new_size)
        resize(vector_triangle self, std::vector< OpenMEEG::Triangle >::size_type new_size, Triangle x)
        """
        return _openmeeg.vector_triangle_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_triangle self, std::vector< OpenMEEG::Triangle >::iterator pos, Triangle x) -> std::vector< OpenMEEG::Triangle >::iterator
        insert(vector_triangle self, std::vector< OpenMEEG::Triangle >::iterator pos, std::vector< OpenMEEG::Triangle >::size_type n, Triangle x)
        """
        return _openmeeg.vector_triangle_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_triangle self, std::vector< OpenMEEG::Triangle >::size_type n)"""
        return _openmeeg.vector_triangle_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_triangle self) -> std::vector< OpenMEEG::Triangle >::size_type"""
        return _openmeeg.vector_triangle_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_triangle

# Register vector_triangle in _openmeeg:
_openmeeg.vector_triangle_swigregister(vector_triangle)
class vector_string(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_string self) -> SwigPyIterator"""
        return _openmeeg.vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_string self) -> bool"""
        return _openmeeg.vector_string___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_string self) -> bool"""
        return _openmeeg.vector_string___bool__(self)

    def __len__(self):
        r"""__len__(vector_string self) -> std::vector< std::string >::size_type"""
        return _openmeeg.vector_string___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string"""
        return _openmeeg.vector_string___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string v)
        """
        return _openmeeg.vector_string___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _openmeeg.vector_string___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_string self, std::vector< std::string >::difference_type i)
        __delitem__(vector_string self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_string___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_string self, SWIGPY_SLICEOBJECT * slice) -> vector_string
        __getitem__(vector_string self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _openmeeg.vector_string___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_string self, SWIGPY_SLICEOBJECT * slice, vector_string v)
        __setitem__(vector_string self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _openmeeg.vector_string___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_string self) -> std::vector< std::string >::value_type"""
        return _openmeeg.vector_string_pop(self)

    def append(self, x):
        r"""append(vector_string self, std::vector< std::string >::value_type const & x)"""
        return _openmeeg.vector_string_append(self, x)

    def empty(self):
        r"""empty(vector_string self) -> bool"""
        return _openmeeg.vector_string_empty(self)

    def size(self):
        r"""size(vector_string self) -> std::vector< std::string >::size_type"""
        return _openmeeg.vector_string_size(self)

    def swap(self, v):
        r"""swap(vector_string self, vector_string v)"""
        return _openmeeg.vector_string_swap(self, v)

    def begin(self):
        r"""begin(vector_string self) -> std::vector< std::string >::iterator"""
        return _openmeeg.vector_string_begin(self)

    def end(self):
        r"""end(vector_string self) -> std::vector< std::string >::iterator"""
        return _openmeeg.vector_string_end(self)

    def rbegin(self):
        r"""rbegin(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _openmeeg.vector_string_rbegin(self)

    def rend(self):
        r"""rend(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _openmeeg.vector_string_rend(self)

    def clear(self):
        r"""clear(vector_string self)"""
        return _openmeeg.vector_string_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_string self) -> std::vector< std::string >::allocator_type"""
        return _openmeeg.vector_string_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_string self)"""
        return _openmeeg.vector_string_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_string self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_string self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _openmeeg.vector_string_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_string self) -> vector_string
        __init__(vector_string self, vector_string other) -> vector_string
        __init__(vector_string self, std::vector< std::string >::size_type size) -> vector_string
        __init__(vector_string self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string
        """
        _openmeeg.vector_string_swiginit(self, _openmeeg.new_vector_string(*args))

    def push_back(self, x):
        r"""push_back(vector_string self, std::vector< std::string >::value_type const & x)"""
        return _openmeeg.vector_string_push_back(self, x)

    def front(self):
        r"""front(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _openmeeg.vector_string_front(self)

    def back(self):
        r"""back(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _openmeeg.vector_string_back(self)

    def assign(self, n, x):
        r"""assign(vector_string self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _openmeeg.vector_string_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_string self, std::vector< std::string >::size_type new_size)
        resize(vector_string self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _openmeeg.vector_string_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _openmeeg.vector_string_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_string self, std::vector< std::string >::size_type n)"""
        return _openmeeg.vector_string_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_string self) -> std::vector< std::string >::size_type"""
        return _openmeeg.vector_string_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_string

# Register vector_string in _openmeeg:
_openmeeg.vector_string_swigregister(vector_string)
class vector_interface(object):
    r"""Proxy of C++ std::vector< OpenMEEG::Interface > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_interface self) -> SwigPyIterator"""
        return _openmeeg.vector_interface_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_interface self) -> bool"""
        return _openmeeg.vector_interface___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_interface self) -> bool"""
        return _openmeeg.vector_interface___bool__(self)

    def __len__(self):
        r"""__len__(vector_interface self) -> std::vector< OpenMEEG::Interface >::size_type"""
        return _openmeeg.vector_interface___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_interface self, std::vector< OpenMEEG::Interface >::difference_type i, std::vector< OpenMEEG::Interface >::difference_type j) -> vector_interface"""
        return _openmeeg.vector_interface___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_interface self, std::vector< OpenMEEG::Interface >::difference_type i, std::vector< OpenMEEG::Interface >::difference_type j)
        __setslice__(vector_interface self, std::vector< OpenMEEG::Interface >::difference_type i, std::vector< OpenMEEG::Interface >::difference_type j, vector_interface v)
        """
        return _openmeeg.vector_interface___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_interface self, std::vector< OpenMEEG::Interface >::difference_type i, std::vector< OpenMEEG::Interface >::difference_type j)"""
        return _openmeeg.vector_interface___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_interface self, std::vector< OpenMEEG::Interface >::difference_type i)
        __delitem__(vector_interface self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_interface___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_interface self, SWIGPY_SLICEOBJECT * slice) -> vector_interface
        __getitem__(vector_interface self, std::vector< OpenMEEG::Interface >::difference_type i) -> Interface
        """
        return _openmeeg.vector_interface___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_interface self, SWIGPY_SLICEOBJECT * slice, vector_interface v)
        __setitem__(vector_interface self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_interface self, std::vector< OpenMEEG::Interface >::difference_type i, Interface x)
        """
        return _openmeeg.vector_interface___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_interface self) -> Interface"""
        return _openmeeg.vector_interface_pop(self)

    def append(self, x):
        r"""append(vector_interface self, Interface x)"""
        return _openmeeg.vector_interface_append(self, x)

    def empty(self):
        r"""empty(vector_interface self) -> bool"""
        return _openmeeg.vector_interface_empty(self)

    def size(self):
        r"""size(vector_interface self) -> std::vector< OpenMEEG::Interface >::size_type"""
        return _openmeeg.vector_interface_size(self)

    def swap(self, v):
        r"""swap(vector_interface self, vector_interface v)"""
        return _openmeeg.vector_interface_swap(self, v)

    def begin(self):
        r"""begin(vector_interface self) -> std::vector< OpenMEEG::Interface >::iterator"""
        return _openmeeg.vector_interface_begin(self)

    def end(self):
        r"""end(vector_interface self) -> std::vector< OpenMEEG::Interface >::iterator"""
        return _openmeeg.vector_interface_end(self)

    def rbegin(self):
        r"""rbegin(vector_interface self) -> std::vector< OpenMEEG::Interface >::reverse_iterator"""
        return _openmeeg.vector_interface_rbegin(self)

    def rend(self):
        r"""rend(vector_interface self) -> std::vector< OpenMEEG::Interface >::reverse_iterator"""
        return _openmeeg.vector_interface_rend(self)

    def clear(self):
        r"""clear(vector_interface self)"""
        return _openmeeg.vector_interface_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_interface self) -> std::vector< OpenMEEG::Interface >::allocator_type"""
        return _openmeeg.vector_interface_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_interface self)"""
        return _openmeeg.vector_interface_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_interface self, std::vector< OpenMEEG::Interface >::iterator pos) -> std::vector< OpenMEEG::Interface >::iterator
        erase(vector_interface self, std::vector< OpenMEEG::Interface >::iterator first, std::vector< OpenMEEG::Interface >::iterator last) -> std::vector< OpenMEEG::Interface >::iterator
        """
        return _openmeeg.vector_interface_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_interface self) -> vector_interface
        __init__(vector_interface self, vector_interface other) -> vector_interface
        __init__(vector_interface self, std::vector< OpenMEEG::Interface >::size_type size) -> vector_interface
        __init__(vector_interface self, std::vector< OpenMEEG::Interface >::size_type size, Interface value) -> vector_interface
        """
        _openmeeg.vector_interface_swiginit(self, _openmeeg.new_vector_interface(*args))

    def push_back(self, x):
        r"""push_back(vector_interface self, Interface x)"""
        return _openmeeg.vector_interface_push_back(self, x)

    def front(self):
        r"""front(vector_interface self) -> Interface"""
        return _openmeeg.vector_interface_front(self)

    def back(self):
        r"""back(vector_interface self) -> Interface"""
        return _openmeeg.vector_interface_back(self)

    def assign(self, n, x):
        r"""assign(vector_interface self, std::vector< OpenMEEG::Interface >::size_type n, Interface x)"""
        return _openmeeg.vector_interface_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_interface self, std::vector< OpenMEEG::Interface >::size_type new_size)
        resize(vector_interface self, std::vector< OpenMEEG::Interface >::size_type new_size, Interface x)
        """
        return _openmeeg.vector_interface_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_interface self, std::vector< OpenMEEG::Interface >::iterator pos, Interface x) -> std::vector< OpenMEEG::Interface >::iterator
        insert(vector_interface self, std::vector< OpenMEEG::Interface >::iterator pos, std::vector< OpenMEEG::Interface >::size_type n, Interface x)
        """
        return _openmeeg.vector_interface_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_interface self, std::vector< OpenMEEG::Interface >::size_type n)"""
        return _openmeeg.vector_interface_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_interface self) -> std::vector< OpenMEEG::Interface >::size_type"""
        return _openmeeg.vector_interface_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_interface

# Register vector_interface in _openmeeg:
_openmeeg.vector_interface_swigregister(vector_interface)
class vector_simple_dom(object):
    r"""Proxy of C++ std::vector< OpenMEEG::SimpleDomain > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_simple_dom self) -> SwigPyIterator"""
        return _openmeeg.vector_simple_dom_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_simple_dom self) -> bool"""
        return _openmeeg.vector_simple_dom___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_simple_dom self) -> bool"""
        return _openmeeg.vector_simple_dom___bool__(self)

    def __len__(self):
        r"""__len__(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::size_type"""
        return _openmeeg.vector_simple_dom___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::difference_type i, std::vector< OpenMEEG::SimpleDomain >::difference_type j) -> vector_simple_dom"""
        return _openmeeg.vector_simple_dom___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::difference_type i, std::vector< OpenMEEG::SimpleDomain >::difference_type j)
        __setslice__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::difference_type i, std::vector< OpenMEEG::SimpleDomain >::difference_type j, vector_simple_dom v)
        """
        return _openmeeg.vector_simple_dom___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::difference_type i, std::vector< OpenMEEG::SimpleDomain >::difference_type j)"""
        return _openmeeg.vector_simple_dom___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::difference_type i)
        __delitem__(vector_simple_dom self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_simple_dom___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_simple_dom self, SWIGPY_SLICEOBJECT * slice) -> vector_simple_dom
        __getitem__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::difference_type i) -> SimpleDomain
        """
        return _openmeeg.vector_simple_dom___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_simple_dom self, SWIGPY_SLICEOBJECT * slice, vector_simple_dom v)
        __setitem__(vector_simple_dom self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::difference_type i, SimpleDomain x)
        """
        return _openmeeg.vector_simple_dom___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_simple_dom self) -> SimpleDomain"""
        return _openmeeg.vector_simple_dom_pop(self)

    def append(self, x):
        r"""append(vector_simple_dom self, SimpleDomain x)"""
        return _openmeeg.vector_simple_dom_append(self, x)

    def empty(self):
        r"""empty(vector_simple_dom self) -> bool"""
        return _openmeeg.vector_simple_dom_empty(self)

    def size(self):
        r"""size(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::size_type"""
        return _openmeeg.vector_simple_dom_size(self)

    def swap(self, v):
        r"""swap(vector_simple_dom self, vector_simple_dom v)"""
        return _openmeeg.vector_simple_dom_swap(self, v)

    def begin(self):
        r"""begin(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::iterator"""
        return _openmeeg.vector_simple_dom_begin(self)

    def end(self):
        r"""end(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::iterator"""
        return _openmeeg.vector_simple_dom_end(self)

    def rbegin(self):
        r"""rbegin(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::reverse_iterator"""
        return _openmeeg.vector_simple_dom_rbegin(self)

    def rend(self):
        r"""rend(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::reverse_iterator"""
        return _openmeeg.vector_simple_dom_rend(self)

    def clear(self):
        r"""clear(vector_simple_dom self)"""
        return _openmeeg.vector_simple_dom_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::allocator_type"""
        return _openmeeg.vector_simple_dom_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_simple_dom self)"""
        return _openmeeg.vector_simple_dom_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::iterator pos) -> std::vector< OpenMEEG::SimpleDomain >::iterator
        erase(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::iterator first, std::vector< OpenMEEG::SimpleDomain >::iterator last) -> std::vector< OpenMEEG::SimpleDomain >::iterator
        """
        return _openmeeg.vector_simple_dom_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_simple_dom self) -> vector_simple_dom
        __init__(vector_simple_dom self, vector_simple_dom other) -> vector_simple_dom
        __init__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::size_type size) -> vector_simple_dom
        __init__(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::size_type size, SimpleDomain value) -> vector_simple_dom
        """
        _openmeeg.vector_simple_dom_swiginit(self, _openmeeg.new_vector_simple_dom(*args))

    def push_back(self, x):
        r"""push_back(vector_simple_dom self, SimpleDomain x)"""
        return _openmeeg.vector_simple_dom_push_back(self, x)

    def front(self):
        r"""front(vector_simple_dom self) -> SimpleDomain"""
        return _openmeeg.vector_simple_dom_front(self)

    def back(self):
        r"""back(vector_simple_dom self) -> SimpleDomain"""
        return _openmeeg.vector_simple_dom_back(self)

    def assign(self, n, x):
        r"""assign(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::size_type n, SimpleDomain x)"""
        return _openmeeg.vector_simple_dom_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::size_type new_size)
        resize(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::size_type new_size, SimpleDomain x)
        """
        return _openmeeg.vector_simple_dom_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::iterator pos, SimpleDomain x) -> std::vector< OpenMEEG::SimpleDomain >::iterator
        insert(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::iterator pos, std::vector< OpenMEEG::SimpleDomain >::size_type n, SimpleDomain x)
        """
        return _openmeeg.vector_simple_dom_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_simple_dom self, std::vector< OpenMEEG::SimpleDomain >::size_type n)"""
        return _openmeeg.vector_simple_dom_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_simple_dom self) -> std::vector< OpenMEEG::SimpleDomain >::size_type"""
        return _openmeeg.vector_simple_dom_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_simple_dom

# Register vector_simple_dom in _openmeeg:
_openmeeg.vector_simple_dom_swigregister(vector_simple_dom)
class vector_domain(object):
    r"""Proxy of C++ std::vector< OpenMEEG::Domain > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_domain self) -> SwigPyIterator"""
        return _openmeeg.vector_domain_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_domain self) -> bool"""
        return _openmeeg.vector_domain___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_domain self) -> bool"""
        return _openmeeg.vector_domain___bool__(self)

    def __len__(self):
        r"""__len__(vector_domain self) -> std::vector< OpenMEEG::Domain >::size_type"""
        return _openmeeg.vector_domain___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_domain self, std::vector< OpenMEEG::Domain >::difference_type i, std::vector< OpenMEEG::Domain >::difference_type j) -> vector_domain"""
        return _openmeeg.vector_domain___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_domain self, std::vector< OpenMEEG::Domain >::difference_type i, std::vector< OpenMEEG::Domain >::difference_type j)
        __setslice__(vector_domain self, std::vector< OpenMEEG::Domain >::difference_type i, std::vector< OpenMEEG::Domain >::difference_type j, vector_domain v)
        """
        return _openmeeg.vector_domain___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_domain self, std::vector< OpenMEEG::Domain >::difference_type i, std::vector< OpenMEEG::Domain >::difference_type j)"""
        return _openmeeg.vector_domain___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_domain self, std::vector< OpenMEEG::Domain >::difference_type i)
        __delitem__(vector_domain self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_domain___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_domain self, SWIGPY_SLICEOBJECT * slice) -> vector_domain
        __getitem__(vector_domain self, std::vector< OpenMEEG::Domain >::difference_type i) -> Domain
        """
        return _openmeeg.vector_domain___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_domain self, SWIGPY_SLICEOBJECT * slice, vector_domain v)
        __setitem__(vector_domain self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_domain self, std::vector< OpenMEEG::Domain >::difference_type i, Domain x)
        """
        return _openmeeg.vector_domain___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_domain self) -> Domain"""
        return _openmeeg.vector_domain_pop(self)

    def append(self, x):
        r"""append(vector_domain self, Domain x)"""
        return _openmeeg.vector_domain_append(self, x)

    def empty(self):
        r"""empty(vector_domain self) -> bool"""
        return _openmeeg.vector_domain_empty(self)

    def size(self):
        r"""size(vector_domain self) -> std::vector< OpenMEEG::Domain >::size_type"""
        return _openmeeg.vector_domain_size(self)

    def swap(self, v):
        r"""swap(vector_domain self, vector_domain v)"""
        return _openmeeg.vector_domain_swap(self, v)

    def begin(self):
        r"""begin(vector_domain self) -> std::vector< OpenMEEG::Domain >::iterator"""
        return _openmeeg.vector_domain_begin(self)

    def end(self):
        r"""end(vector_domain self) -> std::vector< OpenMEEG::Domain >::iterator"""
        return _openmeeg.vector_domain_end(self)

    def rbegin(self):
        r"""rbegin(vector_domain self) -> std::vector< OpenMEEG::Domain >::reverse_iterator"""
        return _openmeeg.vector_domain_rbegin(self)

    def rend(self):
        r"""rend(vector_domain self) -> std::vector< OpenMEEG::Domain >::reverse_iterator"""
        return _openmeeg.vector_domain_rend(self)

    def clear(self):
        r"""clear(vector_domain self)"""
        return _openmeeg.vector_domain_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_domain self) -> std::vector< OpenMEEG::Domain >::allocator_type"""
        return _openmeeg.vector_domain_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_domain self)"""
        return _openmeeg.vector_domain_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_domain self, std::vector< OpenMEEG::Domain >::iterator pos) -> std::vector< OpenMEEG::Domain >::iterator
        erase(vector_domain self, std::vector< OpenMEEG::Domain >::iterator first, std::vector< OpenMEEG::Domain >::iterator last) -> std::vector< OpenMEEG::Domain >::iterator
        """
        return _openmeeg.vector_domain_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_domain self) -> vector_domain
        __init__(vector_domain self, vector_domain other) -> vector_domain
        __init__(vector_domain self, std::vector< OpenMEEG::Domain >::size_type size) -> vector_domain
        __init__(vector_domain self, std::vector< OpenMEEG::Domain >::size_type size, Domain value) -> vector_domain
        """
        _openmeeg.vector_domain_swiginit(self, _openmeeg.new_vector_domain(*args))

    def push_back(self, x):
        r"""push_back(vector_domain self, Domain x)"""
        return _openmeeg.vector_domain_push_back(self, x)

    def front(self):
        r"""front(vector_domain self) -> Domain"""
        return _openmeeg.vector_domain_front(self)

    def back(self):
        r"""back(vector_domain self) -> Domain"""
        return _openmeeg.vector_domain_back(self)

    def assign(self, n, x):
        r"""assign(vector_domain self, std::vector< OpenMEEG::Domain >::size_type n, Domain x)"""
        return _openmeeg.vector_domain_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_domain self, std::vector< OpenMEEG::Domain >::size_type new_size)
        resize(vector_domain self, std::vector< OpenMEEG::Domain >::size_type new_size, Domain x)
        """
        return _openmeeg.vector_domain_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_domain self, std::vector< OpenMEEG::Domain >::iterator pos, Domain x) -> std::vector< OpenMEEG::Domain >::iterator
        insert(vector_domain self, std::vector< OpenMEEG::Domain >::iterator pos, std::vector< OpenMEEG::Domain >::size_type n, Domain x)
        """
        return _openmeeg.vector_domain_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_domain self, std::vector< OpenMEEG::Domain >::size_type n)"""
        return _openmeeg.vector_domain_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_domain self) -> std::vector< OpenMEEG::Domain >::size_type"""
        return _openmeeg.vector_domain_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_domain

# Register vector_domain in _openmeeg:
_openmeeg.vector_domain_swigregister(vector_domain)
class vector_oriented_mesh(object):
    r"""Proxy of C++ std::vector< OpenMEEG::OrientedMesh > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vector_oriented_mesh self) -> SwigPyIterator"""
        return _openmeeg.vector_oriented_mesh_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vector_oriented_mesh self) -> bool"""
        return _openmeeg.vector_oriented_mesh___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vector_oriented_mesh self) -> bool"""
        return _openmeeg.vector_oriented_mesh___bool__(self)

    def __len__(self):
        r"""__len__(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::size_type"""
        return _openmeeg.vector_oriented_mesh___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::difference_type i, std::vector< OpenMEEG::OrientedMesh >::difference_type j) -> vector_oriented_mesh"""
        return _openmeeg.vector_oriented_mesh___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::difference_type i, std::vector< OpenMEEG::OrientedMesh >::difference_type j)
        __setslice__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::difference_type i, std::vector< OpenMEEG::OrientedMesh >::difference_type j, vector_oriented_mesh v)
        """
        return _openmeeg.vector_oriented_mesh___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::difference_type i, std::vector< OpenMEEG::OrientedMesh >::difference_type j)"""
        return _openmeeg.vector_oriented_mesh___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::difference_type i)
        __delitem__(vector_oriented_mesh self, SWIGPY_SLICEOBJECT * slice)
        """
        return _openmeeg.vector_oriented_mesh___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vector_oriented_mesh self, SWIGPY_SLICEOBJECT * slice) -> vector_oriented_mesh
        __getitem__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::difference_type i) -> OrientedMesh
        """
        return _openmeeg.vector_oriented_mesh___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vector_oriented_mesh self, SWIGPY_SLICEOBJECT * slice, vector_oriented_mesh v)
        __setitem__(vector_oriented_mesh self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::difference_type i, OrientedMesh x)
        """
        return _openmeeg.vector_oriented_mesh___setitem__(self, *args)

    def pop(self):
        r"""pop(vector_oriented_mesh self) -> OrientedMesh"""
        return _openmeeg.vector_oriented_mesh_pop(self)

    def append(self, x):
        r"""append(vector_oriented_mesh self, OrientedMesh x)"""
        return _openmeeg.vector_oriented_mesh_append(self, x)

    def empty(self):
        r"""empty(vector_oriented_mesh self) -> bool"""
        return _openmeeg.vector_oriented_mesh_empty(self)

    def size(self):
        r"""size(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::size_type"""
        return _openmeeg.vector_oriented_mesh_size(self)

    def swap(self, v):
        r"""swap(vector_oriented_mesh self, vector_oriented_mesh v)"""
        return _openmeeg.vector_oriented_mesh_swap(self, v)

    def begin(self):
        r"""begin(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::iterator"""
        return _openmeeg.vector_oriented_mesh_begin(self)

    def end(self):
        r"""end(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::iterator"""
        return _openmeeg.vector_oriented_mesh_end(self)

    def rbegin(self):
        r"""rbegin(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::reverse_iterator"""
        return _openmeeg.vector_oriented_mesh_rbegin(self)

    def rend(self):
        r"""rend(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::reverse_iterator"""
        return _openmeeg.vector_oriented_mesh_rend(self)

    def clear(self):
        r"""clear(vector_oriented_mesh self)"""
        return _openmeeg.vector_oriented_mesh_clear(self)

    def get_allocator(self):
        r"""get_allocator(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::allocator_type"""
        return _openmeeg.vector_oriented_mesh_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vector_oriented_mesh self)"""
        return _openmeeg.vector_oriented_mesh_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::iterator pos) -> std::vector< OpenMEEG::OrientedMesh >::iterator
        erase(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::iterator first, std::vector< OpenMEEG::OrientedMesh >::iterator last) -> std::vector< OpenMEEG::OrientedMesh >::iterator
        """
        return _openmeeg.vector_oriented_mesh_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_oriented_mesh self) -> vector_oriented_mesh
        __init__(vector_oriented_mesh self, vector_oriented_mesh other) -> vector_oriented_mesh
        __init__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::size_type size) -> vector_oriented_mesh
        __init__(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::size_type size, OrientedMesh value) -> vector_oriented_mesh
        """
        _openmeeg.vector_oriented_mesh_swiginit(self, _openmeeg.new_vector_oriented_mesh(*args))

    def push_back(self, x):
        r"""push_back(vector_oriented_mesh self, OrientedMesh x)"""
        return _openmeeg.vector_oriented_mesh_push_back(self, x)

    def front(self):
        r"""front(vector_oriented_mesh self) -> OrientedMesh"""
        return _openmeeg.vector_oriented_mesh_front(self)

    def back(self):
        r"""back(vector_oriented_mesh self) -> OrientedMesh"""
        return _openmeeg.vector_oriented_mesh_back(self)

    def assign(self, n, x):
        r"""assign(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::size_type n, OrientedMesh x)"""
        return _openmeeg.vector_oriented_mesh_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::size_type new_size)
        resize(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::size_type new_size, OrientedMesh x)
        """
        return _openmeeg.vector_oriented_mesh_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::iterator pos, OrientedMesh x) -> std::vector< OpenMEEG::OrientedMesh >::iterator
        insert(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::iterator pos, std::vector< OpenMEEG::OrientedMesh >::size_type n, OrientedMesh x)
        """
        return _openmeeg.vector_oriented_mesh_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vector_oriented_mesh self, std::vector< OpenMEEG::OrientedMesh >::size_type n)"""
        return _openmeeg.vector_oriented_mesh_reserve(self, n)

    def capacity(self):
        r"""capacity(vector_oriented_mesh self) -> std::vector< OpenMEEG::OrientedMesh >::size_type"""
        return _openmeeg.vector_oriented_mesh_capacity(self)
    __swig_destroy__ = _openmeeg.delete_vector_oriented_mesh

# Register vector_oriented_mesh in _openmeeg:
_openmeeg.vector_oriented_mesh_swigregister(vector_oriented_mesh)

def new_OpenMEEG_Vector(pyobj):
    r"""new_OpenMEEG_Vector(PyObject * pyobj) -> Vector"""
    return _openmeeg.new_OpenMEEG_Vector(pyobj)

def new_OpenMEEG_Matrix(pyobj):
    r"""new_OpenMEEG_Matrix(PyObject * pyobj) -> Matrix"""
    return _openmeeg.new_OpenMEEG_Matrix(pyobj)

def new_OpenMEEG_SymMatrix(pyobj):
    r"""new_OpenMEEG_SymMatrix(PyObject * pyobj) -> SymMatrix"""
    return _openmeeg.new_OpenMEEG_SymMatrix(pyobj)

def geom_add_vertices(geom, pyobj):
    r"""geom_add_vertices(Geometry * geom, PyObject * pyobj) -> IndexMap"""
    return _openmeeg.geom_add_vertices(geom, pyobj)

def mesh_add_triangles(mesh, pyobj, indmap):
    r"""mesh_add_triangles(Mesh * mesh, PyObject * pyobj, IndexMap const & indmap)"""
    return _openmeeg.mesh_add_triangles(mesh, pyobj, indmap)
DEBUG = _openmeeg.DEBUG

PROGRESS = _openmeeg.PROGRESS

INFORMATION = _openmeeg.INFORMATION

WARNING = _openmeeg.WARNING

ERROR = _openmeeg.ERROR

class Logger(object):
    r"""Proxy of C++ OpenMEEG::Logger class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(Logger self) -> Logger"""
        _openmeeg.Logger_swiginit(self, _openmeeg.new_Logger())

    def set_info_level(self, level):
        r"""set_info_level(Logger self, OpenMEEG::InfoLevel const level)"""
        return _openmeeg.Logger_set_info_level(self, level)

    def get_info_level(self):
        r"""get_info_level(Logger self) -> OpenMEEG::InfoLevel"""
        return _openmeeg.Logger_get_info_level(self)

    def is_verbose(self, level):
        r"""is_verbose(Logger self, OpenMEEG::InfoLevel const level) -> bool"""
        return _openmeeg.Logger_is_verbose(self, level)

    @staticmethod
    def logger():
        r"""logger() -> Logger"""
        return _openmeeg.Logger_logger()
    __swig_destroy__ = _openmeeg.delete_Logger

# Register Logger in _openmeeg:
_openmeeg.Logger_swigregister(Logger)

def log_stream(level):
    r"""log_stream(OpenMEEG::InfoLevel const level) -> std::ostream &"""
    return _openmeeg.log_stream(level)

def sqr(x):
    r"""sqr(double const x) -> double"""
    return _openmeeg.sqr(x)
class Vect3(object):
    r"""Proxy of C++ OpenMEEG::Vect3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Vect3 self, double const x1, double const x2, double const x3) -> Vect3
        __init__(Vect3 self, double const a=0.0) -> Vect3
        __init__(Vect3 self, Vect3 v) -> Vect3
        """
        _openmeeg.Vect3_swiginit(self, _openmeeg.new_Vect3(*args))

    def x(self, *args):
        r"""
        x(Vect3 self) -> double
        x(Vect3 self) -> double
        """
        return _openmeeg.Vect3_x(self, *args)

    def y(self, *args):
        r"""
        y(Vect3 self) -> double
        y(Vect3 self) -> double
        """
        return _openmeeg.Vect3_y(self, *args)

    def z(self, *args):
        r"""
        z(Vect3 self) -> double
        z(Vect3 self) -> double
        """
        return _openmeeg.Vect3_z(self, *args)

    def __lt__(self, v):
        r"""__lt__(Vect3 self, Vect3 v) -> double"""
        return _openmeeg.Vect3___lt__(self, v)

    def norm(self):
        r"""norm(Vect3 self) -> double"""
        return _openmeeg.Vect3_norm(self)

    def norm2(self):
        r"""norm2(Vect3 self) -> double"""
        return _openmeeg.Vect3_norm2(self)

    def __eq__(self, v):
        r"""__eq__(Vect3 self, Vect3 v) -> bool"""
        return _openmeeg.Vect3___eq__(self, v)

    def __ne__(self, v):
        r"""__ne__(Vect3 self, Vect3 v) -> bool"""
        return _openmeeg.Vect3___ne__(self, v)

    def __iadd__(self, v):
        r"""__iadd__(Vect3 self, Vect3 v)"""
        return _openmeeg.Vect3___iadd__(self, v)

    def __isub__(self, v):
        r"""__isub__(Vect3 self, Vect3 v)"""
        return _openmeeg.Vect3___isub__(self, v)

    def __imul__(self, d):
        r"""__imul__(Vect3 self, double const d)"""
        return _openmeeg.Vect3___imul__(self, d)

    def __itruediv__(self, *args):
        return _openmeeg.Vect3___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def multadd(self, d, v):
        r"""multadd(Vect3 self, double const d, Vect3 v)"""
        return _openmeeg.Vect3_multadd(self, d, v)

    def __add__(self, v):
        r"""__add__(Vect3 self, Vect3 v) -> Vect3"""
        return _openmeeg.Vect3___add__(self, v)

    def __sub__(self, v):
        r"""__sub__(Vect3 self, Vect3 v) -> Vect3"""
        return _openmeeg.Vect3___sub__(self, v)

    def __xor__(self, v):
        r"""__xor__(Vect3 self, Vect3 v) -> Vect3"""
        return _openmeeg.Vect3___xor__(self, v)

    def __mul__(self, d):
        r"""__mul__(Vect3 self, double const d) -> Vect3"""
        return _openmeeg.Vect3___mul__(self, d)

    def __truediv__(self, *args):
        return _openmeeg.Vect3___truediv__(self, *args)
    __div__ = __truediv__



    def __call__(self, *args):
        r"""
        __call__(Vect3 self, int const i) -> double
        __call__(Vect3 self, int const i) -> double &
        """
        return _openmeeg.Vect3___call__(self, *args)

    def __neg__(self):
        r"""__neg__(Vect3 self) -> Vect3"""
        return _openmeeg.Vect3___neg__(self)

    def solid_angle(self, v1, v2, v3):
        r"""solid_angle(Vect3 self, Vect3 v1, Vect3 v2, Vect3 v3) -> double"""
        return _openmeeg.Vect3_solid_angle(self, v1, v2, v3)

    def normalize(self):
        r"""normalize(Vect3 self) -> Vect3"""
        return _openmeeg.Vect3_normalize(self)
    __swig_destroy__ = _openmeeg.delete_Vect3

# Register Vect3 in _openmeeg:
_openmeeg.Vect3_swigregister(Vect3)

def dotprod(V1, V2):
    r"""dotprod(Vect3 V1, Vect3 V2) -> double"""
    return _openmeeg.dotprod(V1, V2)

def crossprod(V1, V2):
    r"""crossprod(Vect3 V1, Vect3 V2) -> Vect3"""
    return _openmeeg.crossprod(V1, V2)

def det(V1, V2, V3):
    r"""det(Vect3 V1, Vect3 V2, Vect3 V3) -> double"""
    return _openmeeg.det(V1, V2, V3)
class Vertex(Vect3):
    r"""Proxy of C++ OpenMEEG::Vertex class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Vertex self) -> Vertex
        __init__(Vertex self, Vect3 V, unsigned int const id=-1) -> Vertex
        __init__(Vertex self, double const [3] V, unsigned int const id=-1) -> Vertex
        __init__(Vertex self, double const & x, double const & y, double const & z, unsigned int const id=-1) -> Vertex
        """
        _openmeeg.Vertex_swiginit(self, _openmeeg.new_Vertex(*args))

    def index(self, *args):
        r"""
        index(Vertex self) -> unsigned int
        index(Vertex self) -> unsigned int const &
        """
        return _openmeeg.Vertex_index(self, *args)

    def x(self):
        r"""x(Vertex self) -> double"""
        return _openmeeg.Vertex_x(self)

    def y(self):
        r"""y(Vertex self) -> double"""
        return _openmeeg.Vertex_y(self)

    def z(self):
        r"""z(Vertex self) -> double"""
        return _openmeeg.Vertex_z(self)

    def array(self):
        r"""array(Vertex self) -> PyObject *"""
        return _openmeeg.Vertex_array(self)
    __swig_destroy__ = _openmeeg.delete_Vertex

# Register Vertex in _openmeeg:
_openmeeg.Vertex_swigregister(Vertex)
class TriangleIndices(object):
    r"""Proxy of C++ OpenMEEG::TriangleIndices class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(TriangleIndices self) -> TriangleIndices
        __init__(TriangleIndices self, unsigned int const i, unsigned int const j, unsigned int const k) -> TriangleIndices
        __init__(TriangleIndices self, unsigned int const [3] ind) -> TriangleIndices
        __init__(TriangleIndices self, TriangleIndices ind) -> TriangleIndices
        """
        _openmeeg.TriangleIndices_swiginit(self, _openmeeg.new_TriangleIndices(*args))
    indices = property(_openmeeg.TriangleIndices_indices_get, _openmeeg.TriangleIndices_indices_set, doc=r"""indices : a(3).unsigned int""")

    def array(self):
        r"""array(TriangleIndices self) -> PyObject *"""
        return _openmeeg.TriangleIndices_array(self)
    __swig_destroy__ = _openmeeg.delete_TriangleIndices

# Register TriangleIndices in _openmeeg:
_openmeeg.TriangleIndices_swigregister(TriangleIndices)
class Triangle(object):
    r"""Proxy of C++ OpenMEEG::Triangle class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Triangle self) -> Triangle
        __init__(Triangle self, OpenMEEG::Vertex *[3] pts, unsigned int const index=-1) -> Triangle
        __init__(Triangle self, Vertex p1, Vertex p2, Vertex p3, unsigned int const index=-1) -> Triangle
        __init__(Triangle self, Vertex p1, Vertex p2, Vertex p3, unsigned int const index=-1) -> Triangle
        """
        _openmeeg.Triangle_swiginit(self, _openmeeg.new_Triangle(*args))

    def begin(self, *args):
        r"""
        begin(Triangle self) -> OpenMEEG::Triangle::const_iterator
        begin(Triangle self) -> OpenMEEG::Triangle::iterator
        """
        return _openmeeg.Triangle_begin(self, *args)

    def end(self, *args):
        r"""
        end(Triangle self) -> OpenMEEG::Triangle::const_iterator
        end(Triangle self) -> OpenMEEG::Triangle::iterator
        """
        return _openmeeg.Triangle_end(self, *args)

    def __eq__(self, T):
        r"""__eq__(Triangle self, Triangle T) -> bool"""
        return _openmeeg.Triangle___eq__(self, T)

    def vertex(self, *args):
        r"""
        vertex(Triangle self, unsigned int const & vindex) -> Vertex
        vertex(Triangle self, unsigned int const & vindex) -> Vertex
        """
        return _openmeeg.Triangle_vertex(self, *args)

    def edge(self, V):
        r"""edge(Triangle self, Vertex V) -> Edge"""
        return _openmeeg.Triangle_edge(self, V)

    def edges(self):
        r"""edges(Triangle self) -> Edges"""
        return _openmeeg.Triangle_edges(self)

    def normal(self, *args):
        r"""
        normal(Triangle self) -> Vect3
        normal(Triangle self) -> Vect3
        """
        return _openmeeg.Triangle_normal(self, *args)

    def index(self, *args):
        r"""
        index(Triangle self) -> unsigned int
        index(Triangle self) -> unsigned int
        """
        return _openmeeg.Triangle_index(self, *args)

    def center(self):
        r"""center(Triangle self) -> Vect3"""
        return _openmeeg.Triangle_center(self)

    def contains(self, p):
        r"""contains(Triangle self, Vertex p) -> bool"""
        return _openmeeg.Triangle_contains(self, p)

    def change_orientation(self):
        r"""change_orientation(Triangle self)"""
        return _openmeeg.Triangle_change_orientation(self)

    def intersects(self, triangle):
        r"""intersects(Triangle self, Triangle triangle) -> bool"""
        return _openmeeg.Triangle_intersects(self, triangle)

    def area(self, *args):
        r"""
        area(Triangle self) -> double
        area(Triangle self) -> double
        area(Triangle self) -> double
        """
        return _openmeeg.Triangle_area(self, *args)
    __swig_destroy__ = _openmeeg.delete_Triangle

# Register Triangle in _openmeeg:
_openmeeg.Triangle_swigregister(Triangle)

def sizet_to_int(num):
    r"""sizet_to_int(unsigned int const & num) -> BLAS_INT"""
    return _openmeeg.sizet_to_int(num)
class LinOpInfo(object):
    r"""Proxy of C++ OpenMEEG::LinOpInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    FULL = _openmeeg.LinOpInfo_FULL
    
    SYMMETRIC = _openmeeg.LinOpInfo_SYMMETRIC
    
    BLOCK = _openmeeg.LinOpInfo_BLOCK
    
    BLOCK_SYMMETRIC = _openmeeg.LinOpInfo_BLOCK_SYMMETRIC
    
    SPARSE = _openmeeg.LinOpInfo_SPARSE
    

    def __init__(self, *args):
        r"""
        __init__(LinOpInfo self) -> LinOpInfo
        __init__(LinOpInfo self, OpenMEEG::Dimension const m, OpenMEEG::Dimension const n, OpenMEEG::LinOpInfo::StorageType const st, unsigned int const d) -> LinOpInfo
        """
        _openmeeg.LinOpInfo_swiginit(self, _openmeeg.new_LinOpInfo(*args))
    __swig_destroy__ = _openmeeg.delete_LinOpInfo

    def nlin(self, *args):
        r"""
        nlin(LinOpInfo self) -> OpenMEEG::Dimension
        nlin(LinOpInfo self) -> OpenMEEG::Dimension &
        """
        return _openmeeg.LinOpInfo_nlin(self, *args)

    def ncol(self, *args):
        r"""
        ncol(LinOpInfo self) -> OpenMEEG::Dimension
        ncol(LinOpInfo self) -> OpenMEEG::Dimension &
        """
        return _openmeeg.LinOpInfo_ncol(self, *args)

    def storageType(self, *args):
        r"""
        storageType(LinOpInfo self) -> OpenMEEG::LinOpInfo::StorageType
        storageType(LinOpInfo self) -> OpenMEEG::LinOpInfo::StorageType &
        """
        return _openmeeg.LinOpInfo_storageType(self, *args)

    def dimension(self, *args):
        r"""
        dimension(LinOpInfo self) -> unsigned int
        dimension(LinOpInfo self) -> unsigned int &
        """
        return _openmeeg.LinOpInfo_dimension(self, *args)

    def default_io(self):
        r"""default_io(LinOpInfo self) -> OpenMEEG::LinOpInfo::IO &"""
        return _openmeeg.LinOpInfo_default_io(self)

# Register LinOpInfo in _openmeeg:
_openmeeg.LinOpInfo_swigregister(LinOpInfo)
class LinOp(LinOpInfo):
    r"""Proxy of C++ OpenMEEG::LinOp class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""size(LinOp self) -> size_t"""
        return _openmeeg.LinOp_size(self)

    def info(self):
        r"""info(LinOp self)"""
        return _openmeeg.LinOp_info(self)
    __swig_destroy__ = _openmeeg.delete_LinOp

# Register LinOp in _openmeeg:
_openmeeg.LinOp_swigregister(LinOp)
DEEP_COPY = _openmeeg.DEEP_COPY

class LinOpValue(object):
    r"""Proxy of C++ OpenMEEG::LinOpValue class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(LinOpValue self) -> LinOpValue
        __init__(LinOpValue self, size_t const n) -> LinOpValue
        __init__(LinOpValue self, size_t const n, double const * initval) -> LinOpValue
        __init__(LinOpValue self, size_t const n, LinOpValue v) -> LinOpValue
        """
        _openmeeg.LinOpValue_swiginit(self, _openmeeg.new_LinOpValue(*args))
    __swig_destroy__ = _openmeeg.delete_LinOpValue

    def empty(self):
        r"""empty(LinOpValue self) -> bool"""
        return _openmeeg.LinOpValue_empty(self)

# Register LinOpValue in _openmeeg:
_openmeeg.LinOpValue_swigregister(LinOpValue)
class Vector(LinOp):
    r"""Proxy of C++ OpenMEEG::Vector class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def alloc_data(self):
        r"""alloc_data(Vector self)"""
        return _openmeeg.Vector_alloc_data(self)

    def reference_data(self, array):
        r"""reference_data(Vector self, double const * array)"""
        return _openmeeg.Vector_reference_data(self, array)

    def size(self):
        r"""size(Vector self) -> size_t"""
        return _openmeeg.Vector_size(self)

    def empty(self):
        r"""empty(Vector self) -> bool"""
        return _openmeeg.Vector_empty(self)

    def data(self):
        r"""data(Vector self) -> double *"""
        return _openmeeg.Vector_data(self)

    def __call__(self, *args):
        r"""
        __call__(Vector self, OpenMEEG::Index const i) -> double
        __call__(Vector self, OpenMEEG::Index const i) -> double &
        """
        return _openmeeg.Vector___call__(self, *args)

    def subvect(self, istart, isize):
        r"""subvect(Vector self, OpenMEEG::Index const istart, OpenMEEG::Index const isize) -> Vector"""
        return _openmeeg.Vector_subvect(self, istart, isize)

    def __neg__(self):
        r"""__neg__(Vector self) -> Vector"""
        return _openmeeg.Vector___neg__(self)

    def __iadd__(self, v):
        r"""__iadd__(Vector self, Vector v)"""
        return _openmeeg.Vector___iadd__(self, v)

    def __isub__(self, v):
        r"""__isub__(Vector self, Vector v)"""
        return _openmeeg.Vector___isub__(self, v)

    def __imul__(self, x):
        r"""__imul__(Vector self, double const x)"""
        return _openmeeg.Vector___imul__(self, x)

    def __itruediv__(self, *args):
        return _openmeeg.Vector___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __add__(self, *args):
        r"""
        __add__(Vector self, Vector v) -> Vector
        __add__(Vector self, double const i) -> Vector
        """
        return _openmeeg.Vector___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(Vector self, Vector v) -> Vector
        __sub__(Vector self, double const i) -> Vector
        """
        return _openmeeg.Vector___sub__(self, *args)

    def __truediv__(self, *args):
        return _openmeeg.Vector___truediv__(self, *args)
    __div__ = __truediv__



    def __mul__(self, *args):
        r"""
        __mul__(Vector self, double const x) -> Vector
        __mul__(Vector self, Vector v) -> double
        __mul__(Vector self, Matrix m) -> Vector
        """
        return _openmeeg.Vector___mul__(self, *args)

    def kmult(self, x):
        r"""kmult(Vector self, Vector x) -> Vector"""
        return _openmeeg.Vector_kmult(self, x)

    def outer_product(self, v):
        r"""outer_product(Vector self, Vector v) -> Matrix"""
        return _openmeeg.Vector_outer_product(self, v)

    def norm(self):
        r"""norm(Vector self) -> double"""
        return _openmeeg.Vector_norm(self)

    def sum(self):
        r"""sum(Vector self) -> double"""
        return _openmeeg.Vector_sum(self)

    def mean(self):
        r"""mean(Vector self) -> double"""
        return _openmeeg.Vector_mean(self)

    def set(self, x):
        r"""set(Vector self, double const x)"""
        return _openmeeg.Vector_set(self, x)

    def save(self, *args):
        r"""
        save(Vector self, char const * filename)
        save(Vector self, std::string const & s)
        """
        return _openmeeg.Vector_save(self, *args)

    def load(self, *args):
        r"""
        load(Vector self, char const * filename)
        load(Vector self, std::string const & s)
        """
        return _openmeeg.Vector_load(self, *args)

    def info(self):
        r"""info(Vector self)"""
        return _openmeeg.Vector_info(self)

    def __init__(self, *args):
        r"""
        __init__(Vector self) -> Vector
        __init__(Vector self, OpenMEEG::Dimension const N) -> Vector
        __init__(Vector self, Vector A, OpenMEEG::DeepCopy const arg3) -> Vector
        __init__(Vector self, Matrix A) -> Vector
        __init__(Vector self, SymMatrix A) -> Vector
        __init__(Vector self, PyObject * pyobj) -> Vector
        """
        _openmeeg.Vector_swiginit(self, _openmeeg.new_Vector(*args))

    def array(self):
        r"""array(Vector self) -> PyObject *"""
        return _openmeeg.Vector_array(self)

    def setvalue(self, i, d):
        r"""setvalue(Vector self, unsigned int const i, double const d)"""
        return _openmeeg.Vector_setvalue(self, i, d)

    def value(self, i):
        r"""value(Vector self, unsigned int i) -> double"""
        return _openmeeg.Vector_value(self, i)
    __swig_destroy__ = _openmeeg.delete_Vector

# Register Vector in _openmeeg:
_openmeeg.Vector_swigregister(Vector)

def __mul__(*args):
    r"""
    __mul__(double const d, Vect3 V) -> Vect3
    __mul__(double const d, Vector v) -> Vector
    """
    return _openmeeg.__mul__(*args)

def __rshift__(*args):
    r"""
    __rshift__(std::istream & _is, Vect3 v) -> std::istream
    __rshift__(std::istream & f, Vector M) -> std::istream &
    """
    return _openmeeg.__rshift__(*args)
class Matrix(LinOp):
    r"""Proxy of C++ OpenMEEG::Matrix class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def alloc_data(self):
        r"""alloc_data(Matrix self)"""
        return _openmeeg.Matrix_alloc_data(self)

    def reference_data(self, vals):
        r"""reference_data(Matrix self, double const * vals)"""
        return _openmeeg.Matrix_reference_data(self, vals)

    def empty(self):
        r"""empty(Matrix self) -> bool"""
        return _openmeeg.Matrix_empty(self)

    def size(self):
        r"""size(Matrix self) -> size_t"""
        return _openmeeg.Matrix_size(self)

    def data(self):
        r"""data(Matrix self) -> double *"""
        return _openmeeg.Matrix_data(self)

    def get_shared_data_ptr(self):
        r"""get_shared_data_ptr(Matrix self) -> std::shared_ptr< double [] >"""
        return _openmeeg.Matrix_get_shared_data_ptr(self)

    def __call__(self, *args):
        r"""
        __call__(Matrix self, OpenMEEG::Index const i, OpenMEEG::Index const j) -> double
        __call__(Matrix self, OpenMEEG::Index const i, OpenMEEG::Index const j) -> double &
        """
        return _openmeeg.Matrix___call__(self, *args)

    def submat(self, istart, isize, jstart, jsize):
        r"""submat(Matrix self, OpenMEEG::Index const istart, OpenMEEG::Index const isize, OpenMEEG::Index const jstart, OpenMEEG::Index const jsize) -> Matrix"""
        return _openmeeg.Matrix_submat(self, istart, isize, jstart, jsize)

    def insertmat(self, istart, jstart, B):
        r"""insertmat(Matrix self, OpenMEEG::Index const istart, OpenMEEG::Index const jstart, Matrix B)"""
        return _openmeeg.Matrix_insertmat(self, istart, jstart, B)

    def getcol(self, j):
        r"""getcol(Matrix self, OpenMEEG::Index const j) -> Vector"""
        return _openmeeg.Matrix_getcol(self, j)

    def setcol(self, j, v):
        r"""setcol(Matrix self, OpenMEEG::Index const j, Vector v)"""
        return _openmeeg.Matrix_setcol(self, j, v)

    def getlin(self, i):
        r"""getlin(Matrix self, OpenMEEG::Index const i) -> Vector"""
        return _openmeeg.Matrix_getlin(self, i)

    def setlin(self, i, v):
        r"""setlin(Matrix self, OpenMEEG::Index const i, Vector v)"""
        return _openmeeg.Matrix_setlin(self, i, v)

    def set(self, d):
        r"""set(Matrix self, double const d) -> Matrix"""
        return _openmeeg.Matrix_set(self, d)

    def __add__(self, B):
        r"""__add__(Matrix self, Matrix B) -> Matrix"""
        return _openmeeg.Matrix___add__(self, B)

    def __sub__(self, B):
        r"""__sub__(Matrix self, Matrix B) -> Matrix"""
        return _openmeeg.Matrix___sub__(self, B)

    def __truediv__(self, *args):
        return _openmeeg.Matrix___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, B):
        r"""__iadd__(Matrix self, Matrix B)"""
        return _openmeeg.Matrix___iadd__(self, B)

    def __isub__(self, B):
        r"""__isub__(Matrix self, Matrix B)"""
        return _openmeeg.Matrix___isub__(self, B)

    def __imul__(self, x):
        r"""__imul__(Matrix self, double x)"""
        return _openmeeg.Matrix___imul__(self, x)

    def __itruediv__(self, *args):
        return _openmeeg.Matrix___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __mul__(self, *args):
        r"""
        __mul__(Matrix self, Matrix B) -> Matrix
        __mul__(Matrix self, SymMatrix B) -> Matrix
        __mul__(Matrix self, SparseMatrix B) -> Matrix
        __mul__(Matrix self, double x) -> Matrix
        __mul__(Matrix self, Vector v) -> Vector
        """
        return _openmeeg.Matrix___mul__(self, *args)

    def tmult(self, *args):
        r"""
        tmult(Matrix self, Vector v) -> Vector
        tmult(Matrix self, Matrix m) -> Matrix
        """
        return _openmeeg.Matrix_tmult(self, *args)

    def multt(self, m):
        r"""multt(Matrix self, Matrix m) -> Matrix"""
        return _openmeeg.Matrix_multt(self, m)

    def tmultt(self, m):
        r"""tmultt(Matrix self, Matrix m) -> Matrix"""
        return _openmeeg.Matrix_tmultt(self, m)

    def transpose(self):
        r"""transpose(Matrix self) -> Matrix"""
        return _openmeeg.Matrix_transpose(self)

    def inverse(self):
        r"""inverse(Matrix self) -> Matrix"""
        return _openmeeg.Matrix_inverse(self)

    def pinverse(self, reltol=0.0):
        r"""pinverse(Matrix self, double const reltol=0.0) -> Matrix"""
        return _openmeeg.Matrix_pinverse(self, reltol)

    def svd(self, U, S, V, complete=True):
        r"""svd(Matrix self, Matrix U, SparseMatrix S, Matrix V, bool const complete=True)"""
        return _openmeeg.Matrix_svd(self, U, S, V, complete)

    def frobenius_norm(self):
        r"""frobenius_norm(Matrix self) -> double"""
        return _openmeeg.Matrix_frobenius_norm(self)

    def dot(self, B):
        r"""dot(Matrix self, Matrix B) -> double"""
        return _openmeeg.Matrix_dot(self, B)

    def save(self, *args):
        r"""
        save(Matrix self, char const * filename)
        save(Matrix self, std::string const & s)
        """
        return _openmeeg.Matrix_save(self, *args)

    def load(self, *args):
        r"""
        load(Matrix self, char const * filename)
        load(Matrix self, std::string const & s)
        """
        return _openmeeg.Matrix_load(self, *args)

    def info(self):
        r"""info(Matrix self)"""
        return _openmeeg.Matrix_info(self)

    def __init__(self, *args):
        r"""
        __init__(Matrix self) -> Matrix
        __init__(Matrix self, char const * fname) -> Matrix
        __init__(Matrix self, std::string const & fname) -> Matrix
        __init__(Matrix self, OpenMEEG::Dimension const M, OpenMEEG::Dimension const N) -> Matrix
        __init__(Matrix self, Matrix A, OpenMEEG::DeepCopy const arg3) -> Matrix
        __init__(Matrix self, SymMatrix A) -> Matrix
        __init__(Matrix self, SparseMatrix A) -> Matrix
        __init__(Matrix self, Vector v, OpenMEEG::Dimension const M, OpenMEEG::Dimension const N) -> Matrix
        __init__(Matrix self, PyObject * pyobj) -> Matrix
        """
        _openmeeg.Matrix_swiginit(self, _openmeeg.new_Matrix(*args))

    @staticmethod
    def Free(capsule):
        r"""Free(PyObject * capsule)"""
        return _openmeeg.Matrix_Free(capsule)

    def array(self):
        r"""array(Matrix self) -> PyObject *"""
        return _openmeeg.Matrix_array(self)

    def setvalue(self, i, j, d):
        r"""setvalue(Matrix self, unsigned int const i, unsigned int const j, double const d)"""
        return _openmeeg.Matrix_setvalue(self, i, j, d)

    def value(self, i, j):
        r"""value(Matrix self, unsigned int const i, unsigned int const j) -> double"""
        return _openmeeg.Matrix_value(self, i, j)
    __swig_destroy__ = _openmeeg.delete_Matrix

# Register Matrix in _openmeeg:
_openmeeg.Matrix_swigregister(Matrix)
class SymMatrix(LinOp):
    r"""Proxy of C++ OpenMEEG::SymMatrix class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def size(self):
        r"""size(SymMatrix self) -> size_t"""
        return _openmeeg.SymMatrix_size(self)

    def info(self):
        r"""info(SymMatrix self)"""
        return _openmeeg.SymMatrix_info(self)

    def ncol(self, *args):
        r"""
        ncol(SymMatrix self) -> OpenMEEG::Dimension
        ncol(SymMatrix self) -> OpenMEEG::Dimension &
        """
        return _openmeeg.SymMatrix_ncol(self, *args)

    def alloc_data(self):
        r"""alloc_data(SymMatrix self)"""
        return _openmeeg.SymMatrix_alloc_data(self)

    def reference_data(self, array):
        r"""reference_data(SymMatrix self, double const * array)"""
        return _openmeeg.SymMatrix_reference_data(self, array)

    def empty(self):
        r"""empty(SymMatrix self) -> bool"""
        return _openmeeg.SymMatrix_empty(self)

    def set(self, x):
        r"""set(SymMatrix self, double x)"""
        return _openmeeg.SymMatrix_set(self, x)

    def data(self):
        r"""data(SymMatrix self) -> double *"""
        return _openmeeg.SymMatrix_data(self)

    def __call__(self, *args):
        r"""
        __call__(SymMatrix self, OpenMEEG::Index const i, OpenMEEG::Index const j) -> double
        __call__(SymMatrix self, OpenMEEG::Index const i, OpenMEEG::Index const j) -> double
        __call__(SymMatrix self, OpenMEEG::Index const i_start, OpenMEEG::Index const i_end, OpenMEEG::Index const j_start, OpenMEEG::Index const j_end) -> Matrix
        """
        return _openmeeg.SymMatrix___call__(self, *args)

    def submat(self, *args):
        r"""
        submat(SymMatrix self, OpenMEEG::Index const istart, OpenMEEG::Index const isize, OpenMEEG::Index const jstart, OpenMEEG::Index const jsize) -> Matrix
        submat(SymMatrix self, OpenMEEG::Index const istart, OpenMEEG::Index const iend) -> SymMatrix
        """
        return _openmeeg.SymMatrix_submat(self, *args)

    def getlin(self, i):
        r"""getlin(SymMatrix self, OpenMEEG::Index const i) -> Vector"""
        return _openmeeg.SymMatrix_getlin(self, i)

    def setlin(self, i, v):
        r"""setlin(SymMatrix self, OpenMEEG::Index const i, Vector v)"""
        return _openmeeg.SymMatrix_setlin(self, i, v)

    def solveLin(self, *args):
        r"""
        solveLin(SymMatrix self, Vector B) -> Vector
        solveLin(SymMatrix self, Vector B, int const nbvect)
        solveLin(SymMatrix self, Matrix B) -> Matrix
        """
        return _openmeeg.SymMatrix_solveLin(self, *args)

    def __add__(self, B):
        r"""__add__(SymMatrix self, SymMatrix B) -> SymMatrix"""
        return _openmeeg.SymMatrix___add__(self, B)

    def __sub__(self, B):
        r"""__sub__(SymMatrix self, SymMatrix B) -> SymMatrix"""
        return _openmeeg.SymMatrix___sub__(self, B)

    def __mul__(self, *args):
        r"""
        __mul__(SymMatrix self, SymMatrix B) -> Matrix
        __mul__(SymMatrix self, Matrix B) -> Matrix
        __mul__(SymMatrix self, Vector v) -> Vector
        __mul__(SymMatrix self, double const x) -> SymMatrix
        """
        return _openmeeg.SymMatrix___mul__(self, *args)

    def __truediv__(self, *args):
        return _openmeeg.SymMatrix___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, B):
        r"""__iadd__(SymMatrix self, SymMatrix B)"""
        return _openmeeg.SymMatrix___iadd__(self, B)

    def __isub__(self, B):
        r"""__isub__(SymMatrix self, SymMatrix B)"""
        return _openmeeg.SymMatrix___isub__(self, B)

    def __imul__(self, x):
        r"""__imul__(SymMatrix self, double const x)"""
        return _openmeeg.SymMatrix___imul__(self, x)

    def __itruediv__(self, *args):
        return _openmeeg.SymMatrix___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def inverse(self):
        r"""inverse(SymMatrix self) -> SymMatrix"""
        return _openmeeg.SymMatrix_inverse(self)

    def invert(self):
        r"""invert(SymMatrix self)"""
        return _openmeeg.SymMatrix_invert(self)

    def posdefinverse(self):
        r"""posdefinverse(SymMatrix self) -> SymMatrix"""
        return _openmeeg.SymMatrix_posdefinverse(self)

    def det(self):
        r"""det(SymMatrix self) -> double"""
        return _openmeeg.SymMatrix_det(self)

    def save(self, *args):
        r"""
        save(SymMatrix self, char const * filename)
        save(SymMatrix self, std::string const & s)
        """
        return _openmeeg.SymMatrix_save(self, *args)

    def load(self, *args):
        r"""
        load(SymMatrix self, char const * filename)
        load(SymMatrix self, std::string const & s)
        """
        return _openmeeg.SymMatrix_load(self, *args)

    def __init__(self, *args):
        r"""
        __init__(SymMatrix self) -> SymMatrix
        __init__(SymMatrix self, char const * fname) -> SymMatrix
        __init__(SymMatrix self, OpenMEEG::Dimension N) -> SymMatrix
        __init__(SymMatrix self, OpenMEEG::Dimension M, OpenMEEG::Dimension N) -> SymMatrix
        __init__(SymMatrix self, SymMatrix S, OpenMEEG::DeepCopy const arg3) -> SymMatrix
        __init__(SymMatrix self, Vector v) -> SymMatrix
        __init__(SymMatrix self, Matrix A) -> SymMatrix
        __init__(SymMatrix self, PyObject * pyobj) -> SymMatrix
        """
        _openmeeg.SymMatrix_swiginit(self, _openmeeg.new_SymMatrix(*args))

    def array_flat(self):
        r"""array_flat(SymMatrix self) -> PyObject *"""
        return _openmeeg.SymMatrix_array_flat(self)

    def setvalue(self, i, j, d):
        r"""setvalue(SymMatrix self, unsigned int const i, unsigned int const j, double const d)"""
        return _openmeeg.SymMatrix_setvalue(self, i, j, d)

    def value(self, i, j):
        r"""value(SymMatrix self, unsigned int const i, unsigned int const j) -> double"""
        return _openmeeg.SymMatrix_value(self, i, j)
    __swig_destroy__ = _openmeeg.delete_SymMatrix

# Register SymMatrix in _openmeeg:
_openmeeg.SymMatrix_swigregister(SymMatrix)
class SparseMatrix(LinOp):
    r"""Proxy of C++ OpenMEEG::SparseMatrix class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SparseMatrix self) -> SparseMatrix
        __init__(SparseMatrix self, char const * fname) -> SparseMatrix
        __init__(SparseMatrix self, size_t const N, size_t const M) -> SparseMatrix
        """
        _openmeeg.SparseMatrix_swiginit(self, _openmeeg.new_SparseMatrix(*args))
    __swig_destroy__ = _openmeeg.delete_SparseMatrix

    def __call__(self, *args):
        r"""
        __call__(SparseMatrix self, size_t const i, size_t const j) -> double
        __call__(SparseMatrix self, size_t i, size_t j) -> double &
        """
        return _openmeeg.SparseMatrix___call__(self, *args)

    def size(self):
        r"""size(SparseMatrix self) -> size_t"""
        return _openmeeg.SparseMatrix_size(self)

    def begin(self):
        r"""begin(SparseMatrix self) -> OpenMEEG::SparseMatrix::const_iterator"""
        return _openmeeg.SparseMatrix_begin(self)

    def end(self):
        r"""end(SparseMatrix self) -> OpenMEEG::SparseMatrix::const_iterator"""
        return _openmeeg.SparseMatrix_end(self)

    def transpose(self):
        r"""transpose(SparseMatrix self) -> SparseMatrix"""
        return _openmeeg.SparseMatrix_transpose(self)

    def tank(self):
        r"""tank(SparseMatrix self) -> OpenMEEG::SparseMatrix::Tank const &"""
        return _openmeeg.SparseMatrix_tank(self)

    def set(self, d):
        r"""set(SparseMatrix self, double const d)"""
        return _openmeeg.SparseMatrix_set(self, d)

    def getlin(self, i):
        r"""getlin(SparseMatrix self, size_t const i) -> Vector"""
        return _openmeeg.SparseMatrix_getlin(self, i)

    def setlin(self, v, i):
        r"""setlin(SparseMatrix self, Vector v, size_t const i)"""
        return _openmeeg.SparseMatrix_setlin(self, v, i)

    def save(self, *args):
        r"""
        save(SparseMatrix self, char const * filename)
        save(SparseMatrix self, std::string const & s)
        """
        return _openmeeg.SparseMatrix_save(self, *args)

    def load(self, *args):
        r"""
        load(SparseMatrix self, char const * filename)
        load(SparseMatrix self, std::string const & s)
        """
        return _openmeeg.SparseMatrix_load(self, *args)

    def info(self):
        r"""info(SparseMatrix self)"""
        return _openmeeg.SparseMatrix_info(self)

    def frobenius_norm(self):
        r"""frobenius_norm(SparseMatrix self) -> double"""
        return _openmeeg.SparseMatrix_frobenius_norm(self)

    def __mul__(self, *args):
        r"""
        __mul__(SparseMatrix self, Vector x) -> Vector
        __mul__(SparseMatrix self, SymMatrix m) -> Matrix
        __mul__(SparseMatrix self, Matrix m) -> Matrix
        __mul__(SparseMatrix self, SparseMatrix m) -> SparseMatrix
        """
        return _openmeeg.SparseMatrix___mul__(self, *args)

    def __add__(self, m):
        r"""__add__(SparseMatrix self, SparseMatrix m) -> SparseMatrix"""
        return _openmeeg.SparseMatrix___add__(self, m)

# Register SparseMatrix in _openmeeg:
_openmeeg.SparseMatrix_swigregister(SparseMatrix)
class FastSparseMatrix(object):
    r"""Proxy of C++ OpenMEEG::FastSparseMatrix class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FastSparseMatrix self) -> FastSparseMatrix
        __init__(FastSparseMatrix self, size_t n, size_t p, size_t sp) -> FastSparseMatrix
        __init__(FastSparseMatrix self, SparseMatrix M) -> FastSparseMatrix
        __init__(FastSparseMatrix self, FastSparseMatrix M) -> FastSparseMatrix
        """
        _openmeeg.FastSparseMatrix_swiginit(self, _openmeeg.new_FastSparseMatrix(*args))
    __swig_destroy__ = _openmeeg.delete_FastSparseMatrix

    def nlin(self):
        r"""nlin(FastSparseMatrix self) -> size_t"""
        return _openmeeg.FastSparseMatrix_nlin(self)

    def ncol(self):
        r"""ncol(FastSparseMatrix self) -> size_t"""
        return _openmeeg.FastSparseMatrix_ncol(self)

    def write(self, f):
        r"""write(FastSparseMatrix self, std::ostream & f)"""
        return _openmeeg.FastSparseMatrix_write(self, f)

    def read(self, f):
        r"""read(FastSparseMatrix self, std::istream & f)"""
        return _openmeeg.FastSparseMatrix_read(self, f)

    def __call__(self, *args):
        r"""
        __call__(FastSparseMatrix self, size_t i, size_t j) -> double
        __call__(FastSparseMatrix self, size_t i, size_t j) -> double &
        """
        return _openmeeg.FastSparseMatrix___call__(self, *args)

    def __mul__(self, v):
        r"""__mul__(FastSparseMatrix self, Vector v) -> Vector"""
        return _openmeeg.FastSparseMatrix___mul__(self, v)

    def info(self):
        r"""info(FastSparseMatrix self)"""
        return _openmeeg.FastSparseMatrix_info(self)

# Register FastSparseMatrix in _openmeeg:
_openmeeg.FastSparseMatrix_swigregister(FastSparseMatrix)

def __lshift__(*args):
    r"""
    __lshift__(std::ostream & os, Vect3 v) -> std::ostream
    __lshift__(std::ostream & f, Vector M) -> std::ostream
    __lshift__(std::ostream & os, Matrix M) -> std::ostream
    __lshift__(std::ostream & f, FastSparseMatrix M) -> std::ostream &
    """
    return _openmeeg.__lshift__(*args)

class Geometry(object):
    r"""Proxy of C++ OpenMEEG::Geometry class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def info(self, verbose=False):
        r"""info(Geometry self, bool const verbose=False)"""
        return _openmeeg.Geometry_info(self, verbose)

    def has_conductivities(self):
        r"""has_conductivities(Geometry self) -> bool"""
        return _openmeeg.Geometry_has_conductivities(self)

    def selfCheck(self):
        r"""selfCheck(Geometry self) -> bool"""
        return _openmeeg.Geometry_selfCheck(self)

    def check(self, m):
        r"""check(Geometry self, Mesh m) -> bool"""
        return _openmeeg.Geometry_check(self, m)

    def check_inner(self, m):
        r"""check_inner(Geometry self, Matrix m) -> bool"""
        return _openmeeg.Geometry_check_inner(self, m)

    def check_geometry_is_nested(self):
        r"""check_geometry_is_nested(Geometry self)"""
        return _openmeeg.Geometry_check_geometry_is_nested(self)

    def is_nested(self):
        r"""is_nested(Geometry self) -> bool"""
        return _openmeeg.Geometry_is_nested(self)

    def vertices(self, *args):
        r"""
        vertices(Geometry self) -> vector_vertex
        vertices(Geometry self) -> vector_vertex
        """
        return _openmeeg.Geometry_vertices(self, *args)

    def add_vertex(self, V):
        r"""add_vertex(Geometry self, Vertex V) -> unsigned int"""
        return _openmeeg.Geometry_add_vertex(self, V)

    def add_mesh(self, *args):
        r"""add_mesh(Geometry self, std::string const & name="") -> Mesh"""
        return _openmeeg.Geometry_add_mesh(self, *args)

    def meshes(self, *args):
        r"""
        meshes(Geometry self) -> Meshes
        meshes(Geometry self) -> Meshes const &
        """
        return _openmeeg.Geometry_meshes(self, *args)

    def communicating_mesh_pairs(self):
        r"""communicating_mesh_pairs(Geometry self) -> OpenMEEG::Geometry::MeshPairs const &"""
        return _openmeeg.Geometry_communicating_mesh_pairs(self)

    def domain(self, *args):
        r"""
        domain(Geometry self, std::string const & name) -> Domain const
        domain(Geometry self, Vect3 p) -> Domain const &
        """
        return _openmeeg.Geometry_domain(self, *args)

    def domains(self, *args):
        r"""
        domains(Geometry self) -> vector_domain
        domains(Geometry self) -> vector_domain
        domains(Geometry self, Mesh m) -> OpenMEEG::Geometry::DomainsReference
        """
        return _openmeeg.Geometry_domains(self, *args)

    def nb_parameters(self):
        r"""nb_parameters(Geometry self) -> size_t"""
        return _openmeeg.Geometry_nb_parameters(self)

    def outermost_domain(self):
        r"""outermost_domain(Geometry self) -> Domain &"""
        return _openmeeg.Geometry_outermost_domain(self)

    def set_outermost_domain(self, domain):
        r"""set_outermost_domain(Geometry self, Domain & domain)"""
        return _openmeeg.Geometry_set_outermost_domain(self, domain)

    def is_outermost(self, domain):
        r"""is_outermost(Geometry self, Domain const & domain) -> bool"""
        return _openmeeg.Geometry_is_outermost(self, domain)

    def outermost_interface(self):
        r"""outermost_interface(Geometry self) -> Interface const &"""
        return _openmeeg.Geometry_outermost_interface(self)

    def innermost_interface(self):
        r"""innermost_interface(Geometry self) -> Interface const &"""
        return _openmeeg.Geometry_innermost_interface(self)

    def interface(self, name):
        r"""interface(Geometry self, std::string const & name) -> Interface const &"""
        return _openmeeg.Geometry_interface(self, name)

    def sigma(self, m1, m2):
        r"""sigma(Geometry self, Mesh m1, Mesh m2) -> double"""
        return _openmeeg.Geometry_sigma(self, m1, m2)

    def sigma_inv(self, m1, m2):
        r"""sigma_inv(Geometry self, Mesh m1, Mesh m2) -> double"""
        return _openmeeg.Geometry_sigma_inv(self, m1, m2)

    def indicator(self, m1, m2):
        r"""indicator(Geometry self, Mesh m1, Mesh m2) -> double"""
        return _openmeeg.Geometry_indicator(self, m1, m2)

    def conductivity_jump(self, m):
        r"""conductivity_jump(Geometry self, Mesh m) -> double"""
        return _openmeeg.Geometry_conductivity_jump(self, m)

    def relative_orientation(self, m1, m2):
        r"""relative_orientation(Geometry self, Mesh m1, Mesh m2) -> int"""
        return _openmeeg.Geometry_relative_orientation(self, m1, m2)

    def load(self, *args):
        r"""
        load(Geometry self, std::string const & filename, bool const OLD_ORDERING=False)
        load(Geometry self, std::string const & geomFileName, std::string const & condFileName, bool const OLD_ORDERING=False)
        """
        return _openmeeg.Geometry_load(self, *args)

    def import_(self, meshes):
        r"""import_(Geometry self, OpenMEEG::Geometry::MeshList const & meshes)"""
        return _openmeeg.Geometry_import_(self, meshes)

    def save(self, filename):
        r"""save(Geometry self, std::string const & filename)"""
        return _openmeeg.Geometry_save(self, filename)

    def finalize(self, OLD_ORDERING=False):
        r"""finalize(Geometry self, bool const OLD_ORDERING=False)"""
        return _openmeeg.Geometry_finalize(self, OLD_ORDERING)

    def nb_current_barrier_triangles(self, *args):
        r"""
        nb_current_barrier_triangles(Geometry self) -> size_t
        nb_current_barrier_triangles(Geometry self) -> size_t &
        """
        return _openmeeg.Geometry_nb_current_barrier_triangles(self, *args)

    def nb_invalid_vertices(self):
        r"""nb_invalid_vertices(Geometry self) -> size_t"""
        return _openmeeg.Geometry_nb_invalid_vertices(self)

    def isolated_parts(self):
        r"""isolated_parts(Geometry self) -> OpenMEEG::Geometry::MeshParts const &"""
        return _openmeeg.Geometry_isolated_parts(self)

    def mark_current_barriers(self):
        r"""mark_current_barriers(Geometry self)"""
        return _openmeeg.Geometry_mark_current_barriers(self)

    def mesh(self, *args):
        r"""
        mesh(Geometry self, std::string const & name) -> Mesh
        mesh(Geometry self, std::string const & id) -> Mesh
        """
        return _openmeeg.Geometry_mesh(self, *args)

    def add_vertices(self, *args):
        r"""
        add_vertices(Geometry self, vector_vertex vs) -> OpenMEEG::IndexMap
        add_vertices(Geometry self, PyObject * pyobj) -> OpenMEEG::IndexMap
        """
        return _openmeeg.Geometry_add_vertices(self, *args)

    def __init__(self, *args):
        r"""
        __init__(Geometry self) -> Geometry
        __init__(Geometry self, unsigned int const n) -> Geometry
        __init__(Geometry self, std::string const & geomFileName, bool const OLD_ORDERING=False) -> Geometry
        __init__(Geometry self, std::string const & geomFileName, std::string const & condFileName, bool const OLD_ORDERING=False) -> Geometry
        __init__(Geometry self, char const * geomFileName, bool const OLD_ORDERING=False) -> Geometry
        __init__(Geometry self, char const * geomFileName, char const * condFileName, bool const OLD_ORDERING=False) -> Geometry
        __init__(Geometry self, PyObject * pylist) -> Geometry
        """
        _openmeeg.Geometry_swiginit(self, _openmeeg.new_Geometry(*args))
    __swig_destroy__ = _openmeeg.delete_Geometry

# Register Geometry in _openmeeg:
_openmeeg.Geometry_swigregister(Geometry)
class GeometryIO(object):
    r"""Proxy of C++ OpenMEEG::GeometryIO class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def create(filename):
        r"""create(std::string const & filename) -> GeometryIO"""
        return _openmeeg.GeometryIO_create(filename)

    def name(self):
        r"""name(GeometryIO self) -> char const *"""
        return _openmeeg.GeometryIO_name(self)

    def load(self, *args):
        r"""
        load(GeometryIO self, Geometry geometry)
        load(GeometryIO self, Geometry geometry, Matrix matrix)
        """
        return _openmeeg.GeometryIO_load(self, *args)

    def save(self, *args):
        r"""
        save(GeometryIO self, Geometry geometry)
        save(GeometryIO self, Geometry geometry, Matrix matrix)
        """
        return _openmeeg.GeometryIO_save(self, *args)
    __swig_destroy__ = _openmeeg.delete_GeometryIO

# Register GeometryIO in _openmeeg:
_openmeeg.GeometryIO_swigregister(GeometryIO)
class Sensors(object):
    r"""Proxy of C++ OpenMEEG::Sensors class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Sensors self) -> Sensors
        __init__(Sensors self, Geometry g) -> Sensors
        __init__(Sensors self, char const * filename) -> Sensors
        __init__(Sensors self, char const * filename, Geometry g) -> Sensors
        __init__(Sensors self, Matrix positions, Geometry g) -> Sensors
        __init__(Sensors self, vector_string labels, Matrix positions, Matrix orientations, Vector weights, Vector radii) -> Sensors
        __init__(Sensors self, vector_string labels, Matrix positions, Matrix orientations, Vector weights, Vector radii, Geometry g) -> Sensors
        """
        _openmeeg.Sensors_swiginit(self, _openmeeg.new_Sensors(*args))

    def load(self, *args):
        r"""
        load(Sensors self, char const * filename, char const filetype='t')
        load(Sensors self, std::string const & filename, char const filetype='t')
        load(Sensors self, std::istream & _in)
        """
        return _openmeeg.Sensors_load(self, *args)

    def save(self, *args):
        r"""
        save(Sensors self, char const * filename)
        save(Sensors self, std::string const & filename)
        """
        return _openmeeg.Sensors_save(self, *args)

    def getNumberOfSensors(self):
        r"""getNumberOfSensors(Sensors self) -> size_t"""
        return _openmeeg.Sensors_getNumberOfSensors(self)

    def getNumberOfPositions(self):
        r"""getNumberOfPositions(Sensors self) -> size_t"""
        return _openmeeg.Sensors_getNumberOfPositions(self)

    def getPositions(self, *args):
        r"""
        getPositions(Sensors self) -> Matrix
        getPositions(Sensors self) -> Matrix
        """
        return _openmeeg.Sensors_getPositions(self, *args)

    def getOrientations(self, *args):
        r"""
        getOrientations(Sensors self) -> Matrix
        getOrientations(Sensors self) -> Matrix
        """
        return _openmeeg.Sensors_getOrientations(self, *args)

    def getNames(self, *args):
        r"""
        getNames(Sensors self) -> vector_string
        getNames(Sensors self) -> vector_string
        """
        return _openmeeg.Sensors_getNames(self, *args)

    def hasRadii(self):
        r"""hasRadii(Sensors self) -> bool"""
        return _openmeeg.Sensors_hasRadii(self)

    def hasOrientations(self):
        r"""hasOrientations(Sensors self) -> bool"""
        return _openmeeg.Sensors_hasOrientations(self)

    def hasNames(self):
        r"""hasNames(Sensors self) -> bool"""
        return _openmeeg.Sensors_hasNames(self)

    def getPosition(self, idx):
        r"""getPosition(Sensors self, size_t const idx) -> Vector"""
        return _openmeeg.Sensors_getPosition(self, idx)

    def getOrientation(self, idx):
        r"""getOrientation(Sensors self, size_t const idx) -> Vector"""
        return _openmeeg.Sensors_getOrientation(self, idx)

    def getName(self, idx):
        r"""getName(Sensors self, size_t const idx) -> std::string"""
        return _openmeeg.Sensors_getName(self, idx)

    def setPosition(self, idx, pos):
        r"""setPosition(Sensors self, size_t const idx, Vector pos)"""
        return _openmeeg.Sensors_setPosition(self, idx, pos)

    def setOrientation(self, idx, orient):
        r"""setOrientation(Sensors self, size_t const idx, Vector orient)"""
        return _openmeeg.Sensors_setOrientation(self, idx, orient)

    def hasSensor(self, name):
        r"""hasSensor(Sensors self, std::string const & name) -> bool"""
        return _openmeeg.Sensors_hasSensor(self, name)

    def getSensorIdx(self, name):
        r"""getSensorIdx(Sensors self, std::string const & name) -> size_t"""
        return _openmeeg.Sensors_getSensorIdx(self, name)

    def getInjectionTriangles(self, idx):
        r"""getInjectionTriangles(Sensors self, size_t const idx) -> vector_triangle"""
        return _openmeeg.Sensors_getInjectionTriangles(self, idx)

    def getRadii(self):
        r"""getRadii(Sensors self) -> Vector"""
        return _openmeeg.Sensors_getRadii(self)

    def getWeights(self):
        r"""getWeights(Sensors self) -> Vector"""
        return _openmeeg.Sensors_getWeights(self)

    def getWeightsMatrix(self):
        r"""getWeightsMatrix(Sensors self) -> SparseMatrix"""
        return _openmeeg.Sensors_getWeightsMatrix(self)

    def isEmpty(self):
        r"""isEmpty(Sensors self) -> bool"""
        return _openmeeg.Sensors_isEmpty(self)

    def info(self):
        r"""info(Sensors self)"""
        return _openmeeg.Sensors_info(self)
    __swig_destroy__ = _openmeeg.delete_Sensors

# Register Sensors in _openmeeg:
_openmeeg.Sensors_swigregister(Sensors)
class Mesh(object):
    r"""Proxy of C++ OpenMEEG::Mesh class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _openmeeg.delete_Mesh

    def name(self):
        r"""name(Mesh self) -> std::string const &"""
        return _openmeeg.Mesh_name(self)

    def vertices(self, *args):
        r"""
        vertices(Mesh self) -> vector_pvertex
        vertices(Mesh self) -> vector_pvertex
        """
        return _openmeeg.Mesh_vertices(self, *args)

    def geometry(self):
        r"""geometry(Mesh self) -> Geometry"""
        return _openmeeg.Mesh_geometry(self)

    def triangle(self, t):
        r"""triangle(Mesh self, Triangle t) -> TriangleIndices"""
        return _openmeeg.Mesh_triangle(self, t)

    def current_barrier(self, *args):
        r"""
        current_barrier(Mesh self) -> bool
        current_barrier(Mesh self) -> bool &
        """
        return _openmeeg.Mesh_current_barrier(self, *args)

    def isolated(self, *args):
        r"""
        isolated(Mesh self) -> bool
        isolated(Mesh self) -> bool &
        """
        return _openmeeg.Mesh_isolated(self, *args)

    def add_triangle(self, *args):
        r"""
        add_triangle(Mesh self, TriangleIndices inds) -> Triangle
        add_triangle(Mesh self, TriangleIndices inds, OpenMEEG::IndexMap const & indmap) -> Triangle
        """
        return _openmeeg.Mesh_add_triangle(self, *args)

    def add(self, *args):
        r"""
        add(Mesh self, std::vector< OpenMEEG::TriangleIndices,std::allocator< OpenMEEG::TriangleIndices > > const & trgs)
        add(Mesh self, std::vector< OpenMEEG::TriangleIndices,std::allocator< OpenMEEG::TriangleIndices > > const & trgs, OpenMEEG::IndexMap const & indmap)
        """
        return _openmeeg.Mesh_add(self, *args)

    def __eq__(self, m):
        r"""__eq__(Mesh self, Mesh m) -> bool"""
        return _openmeeg.Mesh___eq__(self, m)

    def __ne__(self, m):
        r"""__ne__(Mesh self, Mesh m) -> bool"""
        return _openmeeg.Mesh___ne__(self, m)

    def info(self, verbose=False):
        r"""info(Mesh self, bool const verbose=False)"""
        return _openmeeg.Mesh_info(self, verbose)

    def has_self_intersection(self):
        r"""has_self_intersection(Mesh self) -> bool"""
        return _openmeeg.Mesh_has_self_intersection(self)

    def intersection(self, arg2):
        r"""intersection(Mesh self, Mesh arg2) -> bool"""
        return _openmeeg.Mesh_intersection(self, arg2)

    def has_correct_orientation(self):
        r"""has_correct_orientation(Mesh self) -> bool"""
        return _openmeeg.Mesh_has_correct_orientation(self)

    def generate_indices(self):
        r"""generate_indices(Mesh self)"""
        return _openmeeg.Mesh_generate_indices(self)

    def update(self, topology_changed):
        r"""update(Mesh self, bool const topology_changed)"""
        return _openmeeg.Mesh_update(self, topology_changed)

    def merge(self, arg2, arg3):
        r"""merge(Mesh self, Mesh arg2, Mesh arg3)"""
        return _openmeeg.Mesh_merge(self, arg2, arg3)

    def vertices_ranges(self):
        r"""vertices_ranges(Mesh self) -> Ranges"""
        return _openmeeg.Mesh_vertices_ranges(self)

    def triangles_range(self):
        r"""triangles_range(Mesh self) -> Range"""
        return _openmeeg.Mesh_triangles_range(self)

    def triangles(self, *args):
        r"""
        triangles(Mesh self) -> vector_triangle
        triangles(Mesh self) -> vector_triangle
        triangles(Mesh self, Vertex V) -> OpenMEEG::TrianglesRefs
        """
        return _openmeeg.Mesh_triangles(self, *args)

    def adjacent_triangles(self, triangle):
        r"""adjacent_triangles(Mesh self, Triangle triangle) -> OpenMEEG::TrianglesRefs"""
        return _openmeeg.Mesh_adjacent_triangles(self, triangle)

    def change_orientation(self):
        r"""change_orientation(Mesh self)"""
        return _openmeeg.Mesh_change_orientation(self)

    def correct_local_orientation(self):
        r"""correct_local_orientation(Mesh self)"""
        return _openmeeg.Mesh_correct_local_orientation(self)

    def correct_global_orientation(self):
        r"""correct_global_orientation(Mesh self)"""
        return _openmeeg.Mesh_correct_global_orientation(self)

    def solid_angle(self, p):
        r"""solid_angle(Mesh self, Vect3 p) -> double"""
        return _openmeeg.Mesh_solid_angle(self, p)

    def normal(self, v):
        r"""normal(Mesh self, Vertex v) -> Vect3"""
        return _openmeeg.Mesh_normal(self, v)

    def laplacian(self, A):
        r"""laplacian(Mesh self, SymMatrix A)"""
        return _openmeeg.Mesh_laplacian(self, A)

    def outermost(self, *args):
        r"""
        outermost(Mesh self) -> bool
        outermost(Mesh self) -> bool
        """
        return _openmeeg.Mesh_outermost(self, *args)

    def smooth(self, smoothing_intensity, niter):
        r"""smooth(Mesh self, double const & smoothing_intensity, unsigned int const & niter)"""
        return _openmeeg.Mesh_smooth(self, smoothing_intensity, niter)

    def gradient_norm2(self, A):
        r"""gradient_norm2(Mesh self, SymMatrix A)"""
        return _openmeeg.Mesh_gradient_norm2(self, A)

    def load(self, filename, verbose=True):
        r"""load(Mesh self, std::string const & filename, bool const verbose=True)"""
        return _openmeeg.Mesh_load(self, filename, verbose)

    def save(self, filename):
        r"""save(Mesh self, std::string const & filename)"""
        return _openmeeg.Mesh_save(self, filename)

    def reference_vertices(self, indmap):
        r"""reference_vertices(Mesh self, OpenMEEG::IndexMap const & indmap)"""
        return _openmeeg.Mesh_reference_vertices(self, indmap)

    def add_triangles(self, pyobj, indmap):
        r"""add_triangles(Mesh self, PyObject * pyobj, OpenMEEG::IndexMap const & indmap)"""
        return _openmeeg.Mesh_add_triangles(self, pyobj, indmap)

    def __init__(self, *args):
        r"""
        __init__(Mesh self, Geometry geometry=None) -> Mesh
        __init__(Mesh self, unsigned int const nv, unsigned int const nt, Geometry geometry=None) -> Mesh
        __init__(Mesh self, Mesh arg2) -> Mesh
        __init__(Mesh self, Mesh m) -> Mesh
        __init__(Mesh self, std::string const & filename, bool const verbose, Geometry geometry=None) -> Mesh
        __init__(Mesh self, std::string const & filename, Geometry geometry=None) -> Mesh
        __init__(Mesh self, PyObject * vertices, PyObject * triangles, std::string const name="", Geometry geom=None) -> Mesh
        """
        _openmeeg.Mesh_swiginit(self, _openmeeg.new_Mesh(*args))

    def __str__(self):
        r"""__str__(Mesh self) -> char const *"""
        return _openmeeg.Mesh___str__(self)

# Register Mesh in _openmeeg:
_openmeeg.Mesh_swigregister(Mesh)
class Integrator(object):
    r"""Proxy of C++ OpenMEEG::Integrator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Integrator self, unsigned int const ord) -> Integrator
        __init__(Integrator self, unsigned int const ord, double const tol) -> Integrator
        __init__(Integrator self, unsigned int const ord, unsigned int const levels, double const tol=0.0001) -> Integrator
        """
        _openmeeg.Integrator_swiginit(self, _openmeeg.new_Integrator(*args))

    def norm(self, *args):
        r"""
        norm(Integrator self, double const a) -> double
        norm(Integrator self, Vect3 a) -> double
        """
        return _openmeeg.Integrator_norm(self, *args)
    __swig_destroy__ = _openmeeg.delete_Integrator

# Register Integrator in _openmeeg:
_openmeeg.Integrator_swigregister(Integrator)
class OrientedMesh(object):
    r"""Proxy of C++ OpenMEEG::OrientedMesh class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Normal = _openmeeg.OrientedMesh_Normal
    
    Opposite = _openmeeg.OrientedMesh_Opposite
    

    def __init__(self, *args):
        r"""
        __init__(OrientedMesh self) -> OrientedMesh
        __init__(OrientedMesh self, Mesh m, OpenMEEG::OrientedMesh::Orientation const o) -> OrientedMesh
        """
        _openmeeg.OrientedMesh_swiginit(self, _openmeeg.new_OrientedMesh(*args))

    def mesh(self, *args):
        r"""
        mesh(OrientedMesh self) -> Mesh
        mesh(OrientedMesh self) -> Mesh
        """
        return _openmeeg.OrientedMesh_mesh(self, *args)

    def orientation(self):
        r"""orientation(OrientedMesh self) -> int"""
        return _openmeeg.OrientedMesh_orientation(self)

    def change_orientation(self):
        r"""change_orientation(OrientedMesh self)"""
        return _openmeeg.OrientedMesh_change_orientation(self)
    __swig_destroy__ = _openmeeg.delete_OrientedMesh

# Register OrientedMesh in _openmeeg:
_openmeeg.OrientedMesh_swigregister(OrientedMesh)
class Interface(object):
    r"""Proxy of C++ OpenMEEG::Interface class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Interface self) -> Interface
        __init__(Interface self, std::string const & interfname) -> Interface
        """
        _openmeeg.Interface_swiginit(self, _openmeeg.new_Interface(*args))

    def name(self):
        r"""name(Interface self) -> std::string const &"""
        return _openmeeg.Interface_name(self)

    def oriented_meshes(self, *args):
        r"""
        oriented_meshes(Interface self) -> vector_oriented_mesh
        oriented_meshes(Interface self) -> vector_oriented_mesh
        """
        return _openmeeg.Interface_oriented_meshes(self, *args)

    def outermost(self):
        r"""outermost(Interface self) -> bool"""
        return _openmeeg.Interface_outermost(self)

    def set_to_outermost(self):
        r"""set_to_outermost(Interface self)"""
        return _openmeeg.Interface_set_to_outermost(self)

    def contains(self, p):
        r"""contains(Interface self, Vect3 p) -> bool"""
        return _openmeeg.Interface_contains(self, p)

    def is_mesh_orientations_coherent(self, doublechecked=False):
        r"""is_mesh_orientations_coherent(Interface self, bool const doublechecked=False) -> bool"""
        return _openmeeg.Interface_is_mesh_orientations_coherent(self, doublechecked)

    def nb_vertices(self):
        r"""nb_vertices(Interface self) -> size_t"""
        return _openmeeg.Interface_nb_vertices(self)

    def nb_triangles(self):
        r"""nb_triangles(Interface self) -> size_t"""
        return _openmeeg.Interface_nb_triangles(self)

    def adjacent_triangles(self, t):
        r"""adjacent_triangles(Interface self, Triangle t) -> OpenMEEG::TrianglesRefs"""
        return _openmeeg.Interface_adjacent_triangles(self, t)
    __swig_destroy__ = _openmeeg.delete_Interface

# Register Interface in _openmeeg:
_openmeeg.Interface_swigregister(Interface)
class SimpleDomain(object):
    r"""Proxy of C++ OpenMEEG::SimpleDomain class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Inside = _openmeeg.SimpleDomain_Inside
    
    Outside = _openmeeg.SimpleDomain_Outside
    

    def __init__(self, *args):
        r"""
        __init__(SimpleDomain self) -> SimpleDomain
        __init__(SimpleDomain self, Interface i, OpenMEEG::SimpleDomain::Side const s) -> SimpleDomain
        """
        _openmeeg.SimpleDomain_swiginit(self, _openmeeg.new_SimpleDomain(*args))
    __swig_destroy__ = _openmeeg.delete_SimpleDomain

    def interface(self, *args):
        r"""
        interface(SimpleDomain self) -> Interface
        interface(SimpleDomain self) -> Interface
        """
        return _openmeeg.SimpleDomain_interface(self, *args)

    def inside(self):
        r"""inside(SimpleDomain self) -> bool"""
        return _openmeeg.SimpleDomain_inside(self)

    def mesh_orientation(self, omesh):
        r"""mesh_orientation(SimpleDomain self, OrientedMesh omesh) -> int"""
        return _openmeeg.SimpleDomain_mesh_orientation(self, omesh)

# Register SimpleDomain in _openmeeg:
_openmeeg.SimpleDomain_swigregister(SimpleDomain)
class Domain(object):
    r"""Proxy of C++ OpenMEEG::Domain class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(Domain self, std::string const & dname="") -> Domain"""
        _openmeeg.Domain_swiginit(self, _openmeeg.new_Domain(*args))
    __swig_destroy__ = _openmeeg.delete_Domain

    def boundaries(self, *args):
        r"""
        boundaries(Domain self) -> vector_simple_dom
        boundaries(Domain self) -> vector_simple_dom
        """
        return _openmeeg.Domain_boundaries(self, *args)

    def name(self, *args):
        r"""
        name(Domain self) -> std::string
        name(Domain self) -> std::string const &
        """
        return _openmeeg.Domain_name(self, *args)

    def set_conductivity(self, c):
        r"""set_conductivity(Domain self, double const c)"""
        return _openmeeg.Domain_set_conductivity(self, c)

    def has_conductivity(self):
        r"""has_conductivity(Domain self) -> bool"""
        return _openmeeg.Domain_has_conductivity(self)

    def conductivity(self):
        r"""conductivity(Domain self) -> double const &"""
        return _openmeeg.Domain_conductivity(self)

    def info(self, outermost=False):
        r"""info(Domain self, bool const outermost=False)"""
        return _openmeeg.Domain_info(self, outermost)

    def contains(self, *args):
        r"""
        contains(Domain self, Mesh m) -> bool
        contains(Domain self, Vect3 point) -> bool
        """
        return _openmeeg.Domain_contains(self, *args)

    def mesh_orientation(self, m):
        r"""mesh_orientation(Domain self, Mesh m) -> int"""
        return _openmeeg.Domain_mesh_orientation(self, m)

# Register Domain in _openmeeg:
_openmeeg.Domain_swigregister(Domain)

def HeadMat(*args):
    r"""HeadMat(Geometry geo, Integrator integrator=OpenMEEG::Integrator(3,0,0.005)) -> SymMatrix"""
    return _openmeeg.HeadMat(*args)

def SurfSourceMat(*args):
    r"""SurfSourceMat(Geometry geo, Mesh sources, Integrator integrator=OpenMEEG::Integrator(3,0,0.005)) -> Matrix"""
    return _openmeeg.SurfSourceMat(*args)

def DipSourceMat(*args):
    r"""
    DipSourceMat(Geometry geo, Matrix dipoles, Integrator integrator, std::string const & domain_name) -> Matrix
    DipSourceMat(Geometry geo, Matrix dipoles, std::string const & domain_name) -> Matrix
    """
    return _openmeeg.DipSourceMat(*args)

def EITSourceMat(*args):
    r"""EITSourceMat(Geometry geo, Sensors electrodes, Integrator integrator=OpenMEEG::Integrator(3,0,0.005)) -> Matrix"""
    return _openmeeg.EITSourceMat(*args)

def Surf2VolMat(geo, points):
    r"""Surf2VolMat(Geometry geo, Matrix points) -> Matrix"""
    return _openmeeg.Surf2VolMat(geo, points)

def Head2EEGMat(geo, electrodes):
    r"""Head2EEGMat(Geometry geo, Sensors electrodes) -> SparseMatrix"""
    return _openmeeg.Head2EEGMat(geo, electrodes)

def Head2ECoGMat(*args):
    r"""
    Head2ECoGMat(Geometry geo, Sensors electrodes, Interface i) -> SparseMatrix
    Head2ECoGMat(Geometry geo, Sensors electrodes, std::string const & id) -> SparseMatrix
    """
    return _openmeeg.Head2ECoGMat(*args)

def Head2MEGMat(geo, sensors):
    r"""Head2MEGMat(Geometry geo, Sensors sensors) -> Matrix"""
    return _openmeeg.Head2MEGMat(geo, sensors)

def SurfSource2MEGMat(sources, sensors):
    r"""SurfSource2MEGMat(Mesh sources, Sensors sensors) -> Matrix"""
    return _openmeeg.SurfSource2MEGMat(sources, sensors)

def DipSource2MEGMat(dipoles, sensors):
    r"""DipSource2MEGMat(Matrix dipoles, Sensors sensors) -> Matrix"""
    return _openmeeg.DipSource2MEGMat(dipoles, sensors)

def DipSource2InternalPotMat(*args):
    r"""DipSource2InternalPotMat(Geometry geo, Matrix dipoles, Matrix points, std::string const & domain_name="") -> Matrix"""
    return _openmeeg.DipSource2InternalPotMat(*args)

def CorticalMat(*args):
    r"""CorticalMat(Geometry geo, SparseMatrix M, std::string const & domain_name="CORTEX", double const alpha=-1.0, double const beta=-1.0, std::string const & filename="", Integrator integrator=OpenMEEG::Integrator(3,0,0.005)) -> Matrix"""
    return _openmeeg.CorticalMat(*args)

def CorticalMat2(*args):
    r"""CorticalMat2(Geometry geo, SparseMatrix M, std::string const & domain_name="CORTEX", double const gamma=1.0, std::string const & filename="", Integrator integrator=OpenMEEG::Integrator(3,0,0.005)) -> Matrix"""
    return _openmeeg.CorticalMat2(*args)
USE_GMRES = _openmeeg.USE_GMRES

class GainMEG(Matrix):
    r"""Proxy of C++ OpenMEEG::GainMEG class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(GainMEG self, Matrix GainMat) -> GainMEG
        __init__(GainMEG self, SymMatrix HeadMatInv, Matrix SourceMat, Matrix Head2MEGMat, Matrix Source2MEGMat) -> GainMEG
        """
        _openmeeg.GainMEG_swiginit(self, _openmeeg.new_GainMEG(*args))
    __swig_destroy__ = _openmeeg.delete_GainMEG

# Register GainMEG in _openmeeg:
_openmeeg.GainMEG_swigregister(GainMEG)
class GainEEG(Matrix):
    r"""Proxy of C++ OpenMEEG::GainEEG class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(GainEEG self, Matrix GainMat) -> GainEEG
        __init__(GainEEG self, SymMatrix HeadMatInv, Matrix SourceMat, SparseMatrix Head2EEGMat) -> GainEEG
        """
        _openmeeg.GainEEG_swiginit(self, _openmeeg.new_GainEEG(*args))
    __swig_destroy__ = _openmeeg.delete_GainEEG

# Register GainEEG in _openmeeg:
_openmeeg.GainEEG_swigregister(GainEEG)
class GainEEGadjoint(Matrix):
    r"""Proxy of C++ OpenMEEG::GainEEGadjoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, geo, dipoles, HeadMat, Head2EEGMat):
        r"""__init__(GainEEGadjoint self, Geometry geo, Matrix dipoles, SymMatrix HeadMat, SparseMatrix Head2EEGMat) -> GainEEGadjoint"""
        _openmeeg.GainEEGadjoint_swiginit(self, _openmeeg.new_GainEEGadjoint(geo, dipoles, HeadMat, Head2EEGMat))
    __swig_destroy__ = _openmeeg.delete_GainEEGadjoint

# Register GainEEGadjoint in _openmeeg:
_openmeeg.GainEEGadjoint_swigregister(GainEEGadjoint)
class GainMEGadjoint(Matrix):
    r"""Proxy of C++ OpenMEEG::GainMEGadjoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, geo, dipoles, HeadMat, Head2MEGMat, Source2MEGMat):
        r"""__init__(GainMEGadjoint self, Geometry geo, Matrix dipoles, SymMatrix HeadMat, Matrix Head2MEGMat, Matrix Source2MEGMat) -> GainMEGadjoint"""
        _openmeeg.GainMEGadjoint_swiginit(self, _openmeeg.new_GainMEGadjoint(geo, dipoles, HeadMat, Head2MEGMat, Source2MEGMat))
    __swig_destroy__ = _openmeeg.delete_GainMEGadjoint

# Register GainMEGadjoint in _openmeeg:
_openmeeg.GainMEGadjoint_swigregister(GainMEGadjoint)
class GainEEGMEGadjoint(object):
    r"""Proxy of C++ OpenMEEG::GainEEGMEGadjoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, geo, dipoles, HeadMat, Head2EEGMat, Head2MEGMat, Source2MEGMat):
        r"""__init__(GainEEGMEGadjoint self, Geometry geo, Matrix dipoles, SymMatrix HeadMat, SparseMatrix Head2EEGMat, Matrix Head2MEGMat, Matrix Source2MEGMat) -> GainEEGMEGadjoint"""
        _openmeeg.GainEEGMEGadjoint_swiginit(self, _openmeeg.new_GainEEGMEGadjoint(geo, dipoles, HeadMat, Head2EEGMat, Head2MEGMat, Source2MEGMat))

    def saveEEG(self, filename):
        r"""saveEEG(GainEEGMEGadjoint self, std::string const filename)"""
        return _openmeeg.GainEEGMEGadjoint_saveEEG(self, filename)

    def saveMEG(self, filename):
        r"""saveMEG(GainEEGMEGadjoint self, std::string const filename)"""
        return _openmeeg.GainEEGMEGadjoint_saveMEG(self, filename)

    def nlin(self):
        r"""nlin(GainEEGMEGadjoint self) -> size_t"""
        return _openmeeg.GainEEGMEGadjoint_nlin(self)
    __swig_destroy__ = _openmeeg.delete_GainEEGMEGadjoint

# Register GainEEGMEGadjoint in _openmeeg:
_openmeeg.GainEEGMEGadjoint_swigregister(GainEEGMEGadjoint)
class GainInternalPot(Matrix):
    r"""Proxy of C++ OpenMEEG::GainInternalPot class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, HeadMatInv, SourceMat, Head2IPMat, Source2IPMat):
        r"""__init__(GainInternalPot self, SymMatrix HeadMatInv, Matrix SourceMat, Matrix Head2IPMat, Matrix Source2IPMat) -> GainInternalPot"""
        _openmeeg.GainInternalPot_swiginit(self, _openmeeg.new_GainInternalPot(HeadMatInv, SourceMat, Head2IPMat, Source2IPMat))
    __swig_destroy__ = _openmeeg.delete_GainInternalPot

# Register GainInternalPot in _openmeeg:
_openmeeg.GainInternalPot_swigregister(GainInternalPot)
class GainEITInternalPot(Matrix):
    r"""Proxy of C++ OpenMEEG::GainEITInternalPot class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, HeadMatInv, SourceMat, Head2IPMat):
        r"""__init__(GainEITInternalPot self, SymMatrix HeadMatInv, Matrix SourceMat, Matrix Head2IPMat) -> GainEITInternalPot"""
        _openmeeg.GainEITInternalPot_swiginit(self, _openmeeg.new_GainEITInternalPot(HeadMatInv, SourceMat, Head2IPMat))
    __swig_destroy__ = _openmeeg.delete_GainEITInternalPot

# Register GainEITInternalPot in _openmeeg:
_openmeeg.GainEITInternalPot_swigregister(GainEITInternalPot)
class Forward(Matrix):
    r"""Proxy of C++ OpenMEEG::Forward class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, GainMatrix, RealSourcesData, NoiseLevel):
        r"""__init__(Forward self, Matrix GainMatrix, Matrix RealSourcesData, double const NoiseLevel) -> Forward"""
        _openmeeg.Forward_swiginit(self, _openmeeg.new_Forward(GainMatrix, RealSourcesData, NoiseLevel))
    __swig_destroy__ = _openmeeg.delete_Forward

# Register Forward in _openmeeg:
_openmeeg.Forward_swigregister(Forward)

