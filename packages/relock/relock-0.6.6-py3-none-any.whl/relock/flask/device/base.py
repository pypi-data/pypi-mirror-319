import binascii
import logging

from .cookie import Cookie

from .signals import (the_signature_validation_has_failed,
					  the_signature_validation_was_successful,
					  the_signature_validation_throws_error)

class Base(Cookie):

	@property
	def verificated(self):
		#: This property is set to True only when the credentials have been successfully verified. 
		#: It is always set to False before request processing begins.
		if not hasattr(self, 'client_key'):
			self.client_key = bytes()
		return self.client_key

	@verificated.setter
	def verificated(self, value:bool = False):
		self.client_key = bool(value)

	@property
	def client(self):
		#: ed25519 public key sent by the user's device, this  user's signature key 
		#: is stored unencrypted and is static (it doesn't rotate over time).

		#: Client signature key is unique, generated by the user device at the moment 
		#: of key agreement and is used to sign and verify authentication tokens.
		if not hasattr(self, 'client_key'):
			self.client_key = bytes()
		return self.client_key

	@client.setter
	def client(self, value:bytes):
		self.client_key = value

	@property
	def user(self):
		#: The user ID received from the `USER object' passed by Flask-Login.
		if hasattr(self, 'user_id'):
			return self.user_id

	@user.setter
	def user(self, value:int):
		self.user_id = value

	@property
	def email(self):
		#: The user email received from the `USER object' passed by Flask-Login.
		if hasattr(self, 'mail'):
			return self.mail

	@email.setter
	def email(self, value:int):
		self.mail = value

	def sign(self, value:bytes) -> bool:
		"""
		This will sign the passed `value' with a private ed25519 key unique to that device. The signature key is random and only available on the server side for the correct user and user device.

		:param value: The data to be singed.
		:type value: bytes
		"""
		return self.kdm.sign(value)

	def verify(self, data:bytes, signature:bytes, valid:bool = False) -> bool:
		"""
		This will sign the passed `value' with a private ed25519 key unique to that device. The signature key is random and only available on the server side for the correct user and user device.

		:param data: The data to be veryficated against signature.
		:type data: bytes
		:param signature: The signature material.
		:type signature: bytes
		:param valid: By default assumed invalid signature.
					   Defaults to ``False``.
		:type valid: bool
		"""
		try:
			if isinstance(data, str) and int(data, 16):
				data = binascii.unhexlify(data)
			if isinstance(signature, str) and int(signature, 16):
				signature = binascii.unhexlify(signature)
			valid = self.kdm.verify(data, signature)
		except:
			the_signature_validation_throws_error.send()
		else:
			if valid:
				the_signature_validation_was_successful.send()
			else:
				the_signature_validation_has_failed.send()
		finally:
			return valid