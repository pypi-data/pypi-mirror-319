# coding: utf-8

"""
    SciCat backend API

    This is the API for the SciCat Backend

    The version of the OpenAPI document: api/v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictStr, conlist

from typing import List, Optional

from scicat_sdk_pydantic.models.attachment import Attachment
from scicat_sdk_pydantic.models.count_api_response import CountApiResponse
from scicat_sdk_pydantic.models.create_attachment_dto import CreateAttachmentDto
from scicat_sdk_pydantic.models.create_dataset_datablock_dto import CreateDatasetDatablockDto
from scicat_sdk_pydantic.models.create_dataset_orig_datablock_dto import CreateDatasetOrigDatablockDto
from scicat_sdk_pydantic.models.datablock import Datablock
from scicat_sdk_pydantic.models.dataset_class import DatasetClass
from scicat_sdk_pydantic.models.datasets_controller_create_request import DatasetsControllerCreateRequest
from scicat_sdk_pydantic.models.datasets_controller_find_by_id_and_replace_request import DatasetsControllerFindByIdAndReplaceRequest
from scicat_sdk_pydantic.models.datasets_controller_find_by_id_and_update_request import DatasetsControllerFindByIdAndUpdateRequest
from scicat_sdk_pydantic.models.full_facet_response import FullFacetResponse
from scicat_sdk_pydantic.models.is_valid_response import IsValidResponse
from scicat_sdk_pydantic.models.logbook import Logbook
from scicat_sdk_pydantic.models.orig_datablock import OrigDatablock
from scicat_sdk_pydantic.models.output_dataset_obsolete_dto import OutputDatasetObsoleteDto
from scicat_sdk_pydantic.models.partial_update_datablock_dto import PartialUpdateDatablockDto
from scicat_sdk_pydantic.models.update_attachment_dto import UpdateAttachmentDto
from scicat_sdk_pydantic.models.update_orig_datablock_dto import UpdateOrigDatablockDto

from scicat_sdk_pydantic.api_client import ApiClient
from scicat_sdk_pydantic.api_response import ApiResponse
from scicat_sdk_pydantic.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DatasetsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def datasets_controller_append_to_array_field(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to be modified")], field_name : Annotated[StrictStr, Field(..., description="Name of the field to be updated")], data : Annotated[conlist(StrictStr), Field(..., description="Json object with the fields to be updated and their values")], **kwargs) -> OutputDatasetObsoleteDto:  # noqa: E501
        """It appends a new value to the specific field.  # noqa: E501

        It appends a new value to the specified field of the dataset with provided pid.<br>The SciCat project is reviewing the purpose of this function and will decide if it will be dropped or changed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_append_to_array_field(pid, field_name, data, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to be modified (required)
        :type pid: str
        :param field_name: Name of the field to be updated (required)
        :type field_name: str
        :param data: Json object with the fields to be updated and their values (required)
        :type data: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OutputDatasetObsoleteDto
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_append_to_array_field_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_append_to_array_field_with_http_info(pid, field_name, data, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_append_to_array_field_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to be modified")], field_name : Annotated[StrictStr, Field(..., description="Name of the field to be updated")], data : Annotated[conlist(StrictStr), Field(..., description="Json object with the fields to be updated and their values")], **kwargs) -> ApiResponse:  # noqa: E501
        """It appends a new value to the specific field.  # noqa: E501

        It appends a new value to the specified field of the dataset with provided pid.<br>The SciCat project is reviewing the purpose of this function and will decide if it will be dropped or changed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_append_to_array_field_with_http_info(pid, field_name, data, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to be modified (required)
        :type pid: str
        :param field_name: Name of the field to be updated (required)
        :type field_name: str
        :param data: Json object with the fields to be updated and their values (required)
        :type data: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OutputDatasetObsoleteDto, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'field_name',
            'data'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_append_to_array_field" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        if _params.get('field_name') is not None:  # noqa: E501
            _query_params.append(('fieldName', _params['field_name']))

        if _params.get('data') is not None:  # noqa: E501
            _query_params.append(('data', _params['data']))
            _collection_formats['data'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "OutputDatasetObsoleteDto",
            '201': "object",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/appendToArrayField', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_count(self, filter : Annotated[Optional[StrictStr], Field(description="Database filters to apply when retrieving count for datasets")] = None, **kwargs) -> CountApiResponse:  # noqa: E501
        """It returns the number of datasets.  # noqa: E501

        It returns a number of datasets matching the where filter if provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_count(filter, async_req=True)
        >>> result = thread.get()

        :param filter: Database filters to apply when retrieving count for datasets
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CountApiResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_count_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_count_with_http_info(filter, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_count_with_http_info(self, filter : Annotated[Optional[StrictStr], Field(description="Database filters to apply when retrieving count for datasets")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """It returns the number of datasets.  # noqa: E501

        It returns a number of datasets matching the where filter if provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_count_with_http_info(filter, async_req=True)
        >>> result = thread.get()

        :param filter: Database filters to apply when retrieving count for datasets
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CountApiResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_count" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('filter', _params['filter']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "CountApiResponse",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/count', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_create(self, datasets_controller_create_request : Annotated[DatasetsControllerCreateRequest, Field(..., description="Input fields for the dataset to be created")], **kwargs) -> OutputDatasetObsoleteDto:  # noqa: E501
        """It creates a new dataset which can be a raw, derived or custom one.  # noqa: E501

        It creates a new dataset and returns it completed with systems fields.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create(datasets_controller_create_request, async_req=True)
        >>> result = thread.get()

        :param datasets_controller_create_request: Input fields for the dataset to be created (required)
        :type datasets_controller_create_request: DatasetsControllerCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OutputDatasetObsoleteDto
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_create_with_http_info(datasets_controller_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_create_with_http_info(self, datasets_controller_create_request : Annotated[DatasetsControllerCreateRequest, Field(..., description="Input fields for the dataset to be created")], **kwargs) -> ApiResponse:  # noqa: E501
        """It creates a new dataset which can be a raw, derived or custom one.  # noqa: E501

        It creates a new dataset and returns it completed with systems fields.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create_with_http_info(datasets_controller_create_request, async_req=True)
        >>> result = thread.get()

        :param datasets_controller_create_request: Input fields for the dataset to be created (required)
        :type datasets_controller_create_request: DatasetsControllerCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OutputDatasetObsoleteDto, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'datasets_controller_create_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['datasets_controller_create_request'] is not None:
            _body_params = _params['datasets_controller_create_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '201': "OutputDatasetObsoleteDto",
        }

        return self.api_client.call_api(
            '/api/v3/datasets', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_create_attachment(self, pid : Annotated[StrictStr, Field(..., description="Persisten identifier of the dataset we would like to create a new attachment for")], create_attachment_dto : CreateAttachmentDto, **kwargs) -> Attachment:  # noqa: E501
        """It creates a new attachement for the dataset specified.  # noqa: E501

        It creates a new attachement for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create_attachment(pid, create_attachment_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persisten identifier of the dataset we would like to create a new attachment for (required)
        :type pid: str
        :param create_attachment_dto: (required)
        :type create_attachment_dto: CreateAttachmentDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_create_attachment_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_create_attachment_with_http_info(pid, create_attachment_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_create_attachment_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persisten identifier of the dataset we would like to create a new attachment for")], create_attachment_dto : CreateAttachmentDto, **kwargs) -> ApiResponse:  # noqa: E501
        """It creates a new attachement for the dataset specified.  # noqa: E501

        It creates a new attachement for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create_attachment_with_http_info(pid, create_attachment_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persisten identifier of the dataset we would like to create a new attachment for (required)
        :type pid: str
        :param create_attachment_dto: (required)
        :type create_attachment_dto: CreateAttachmentDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'create_attachment_dto'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_create_attachment" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_attachment_dto'] is not None:
            _body_params = _params['create_attachment_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '201': "Attachment",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/attachments', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_create_datablock(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset we would like to create a new datablock for")], create_dataset_datablock_dto : CreateDatasetDatablockDto, **kwargs) -> Datablock:  # noqa: E501
        """It creates a new datablock for the dataset specified.  # noqa: E501

        It creates a new datablock for the dataset specified by the pid passed.<br>This endpoint is obsolete and will be dropped in future versions.<br>Creating new datablock will be allowed only from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create_datablock(pid, create_dataset_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset we would like to create a new datablock for (required)
        :type pid: str
        :param create_dataset_datablock_dto: (required)
        :type create_dataset_datablock_dto: CreateDatasetDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Datablock
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_create_datablock_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_create_datablock_with_http_info(pid, create_dataset_datablock_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_create_datablock_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset we would like to create a new datablock for")], create_dataset_datablock_dto : CreateDatasetDatablockDto, **kwargs) -> ApiResponse:  # noqa: E501
        """It creates a new datablock for the dataset specified.  # noqa: E501

        It creates a new datablock for the dataset specified by the pid passed.<br>This endpoint is obsolete and will be dropped in future versions.<br>Creating new datablock will be allowed only from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create_datablock_with_http_info(pid, create_dataset_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset we would like to create a new datablock for (required)
        :type pid: str
        :param create_dataset_datablock_dto: (required)
        :type create_dataset_datablock_dto: CreateDatasetDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Datablock, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'create_dataset_datablock_dto'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_create_datablock" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_dataset_datablock_dto'] is not None:
            _body_params = _params['create_dataset_datablock_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '201': "Datablock",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/datablocks', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_create_orig_datablock(self, pid : Annotated[StrictStr, Field(..., description="PErsistent identifier of the dataset we would like to create a new original datablock for")], create_dataset_orig_datablock_dto : CreateDatasetOrigDatablockDto, **kwargs) -> OrigDatablock:  # noqa: E501
        """It creates a new origDatablock for the dataset specified.  # noqa: E501

        It creates a new original datablock for the dataset specified by the pid passed.<br>This endpoint is obsolete and will be dropped in future versions.<br>Creatign new origDatablocks will be allowed only from the attachments endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create_orig_datablock(pid, create_dataset_orig_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: PErsistent identifier of the dataset we would like to create a new original datablock for (required)
        :type pid: str
        :param create_dataset_orig_datablock_dto: (required)
        :type create_dataset_orig_datablock_dto: CreateDatasetOrigDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrigDatablock
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_create_orig_datablock_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_create_orig_datablock_with_http_info(pid, create_dataset_orig_datablock_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_create_orig_datablock_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="PErsistent identifier of the dataset we would like to create a new original datablock for")], create_dataset_orig_datablock_dto : CreateDatasetOrigDatablockDto, **kwargs) -> ApiResponse:  # noqa: E501
        """It creates a new origDatablock for the dataset specified.  # noqa: E501

        It creates a new original datablock for the dataset specified by the pid passed.<br>This endpoint is obsolete and will be dropped in future versions.<br>Creatign new origDatablocks will be allowed only from the attachments endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_create_orig_datablock_with_http_info(pid, create_dataset_orig_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: PErsistent identifier of the dataset we would like to create a new original datablock for (required)
        :type pid: str
        :param create_dataset_orig_datablock_dto: (required)
        :type create_dataset_orig_datablock_dto: CreateDatasetOrigDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrigDatablock, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'create_dataset_orig_datablock_dto'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_create_orig_datablock" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_dataset_orig_datablock_dto'] is not None:
            _body_params = _params['create_dataset_orig_datablock_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '201': "OrigDatablock",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/origdatablocks', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_all(self, filter : Annotated[Optional[StrictStr], Field(description="Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>")] = None, **kwargs) -> List[OutputDatasetObsoleteDto]:  # noqa: E501
        """It returns a list of datasets.  # noqa: E501

        It returns a list of datasets. The list returned can be modified by providing a filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all(filter, async_req=True)
        >>> result = thread.get()

        :param filter: Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OutputDatasetObsoleteDto]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_all_with_http_info(filter, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_all_with_http_info(self, filter : Annotated[Optional[StrictStr], Field(description="Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """It returns a list of datasets.  # noqa: E501

        It returns a list of datasets. The list returned can be modified by providing a filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all_with_http_info(filter, async_req=True)
        >>> result = thread.get()

        :param filter: Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OutputDatasetObsoleteDto], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_all" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('filter', _params['filter']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[OutputDatasetObsoleteDto]",
        }

        return self.api_client.call_api(
            '/api/v3/datasets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_all_attachments(self, pid : Annotated[StrictStr, Field(..., description="Persisten Identifier of the dataset for which we would like to retrieve all the attachments")], **kwargs) -> List[Attachment]:  # noqa: E501
        """It returns all the attachments for the dataset specified.  # noqa: E501

        It returns all the attachments for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all_attachments(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persisten Identifier of the dataset for which we would like to retrieve all the attachments (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Attachment]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_all_attachments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_all_attachments_with_http_info(pid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_all_attachments_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persisten Identifier of the dataset for which we would like to retrieve all the attachments")], **kwargs) -> ApiResponse:  # noqa: E501
        """It returns all the attachments for the dataset specified.  # noqa: E501

        It returns all the attachments for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all_attachments_with_http_info(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persisten Identifier of the dataset for which we would like to retrieve all the attachments (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Attachment], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_all_attachments" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[Attachment]",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/attachments', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_all_datablocks(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to retrieve all the datablocks")], **kwargs) -> List[Datablock]:  # noqa: E501
        """It returns all the datablock for the dataset specified.  # noqa: E501

        It returns all the datablocks for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all_datablocks(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to retrieve all the datablocks (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Datablock]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_all_datablocks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_all_datablocks_with_http_info(pid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_all_datablocks_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to retrieve all the datablocks")], **kwargs) -> ApiResponse:  # noqa: E501
        """It returns all the datablock for the dataset specified.  # noqa: E501

        It returns all the datablocks for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all_datablocks_with_http_info(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to retrieve all the datablocks (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Datablock], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_all_datablocks" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[Datablock]",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/datablocks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_all_orig_datablocks(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to retrieve all the original datablocks")], **kwargs) -> List[OrigDatablock]:  # noqa: E501
        """It returns all the origDatablock for the dataset specified.  # noqa: E501

        It returns all the original datablocks for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all_orig_datablocks(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to retrieve all the original datablocks (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OrigDatablock]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_all_orig_datablocks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_all_orig_datablocks_with_http_info(pid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_all_orig_datablocks_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to retrieve all the original datablocks")], **kwargs) -> ApiResponse:  # noqa: E501
        """It returns all the origDatablock for the dataset specified.  # noqa: E501

        It returns all the original datablocks for the dataset specified by the pid passed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_all_orig_datablocks_with_http_info(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to retrieve all the original datablocks (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OrigDatablock], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_all_orig_datablocks" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[OrigDatablock]",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/origdatablocks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_by_id(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to return")], **kwargs) -> OutputDatasetObsoleteDto:  # noqa: E501
        """datasets_controller_find_by_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to return (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OutputDatasetObsoleteDto
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_by_id_with_http_info(pid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_by_id_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to return")], **kwargs) -> ApiResponse:  # noqa: E501
        """datasets_controller_find_by_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id_with_http_info(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to return (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OutputDatasetObsoleteDto, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "OutputDatasetObsoleteDto",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_by_id_and_delete(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to be deleted")], **kwargs) -> DatasetClass:  # noqa: E501
        """It deletes the dataset.  # noqa: E501

        It delete the dataset specified through the pid specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id_and_delete(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to be deleted (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DatasetClass
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_by_id_and_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_by_id_and_delete_with_http_info(pid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_by_id_and_delete_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to be deleted")], **kwargs) -> ApiResponse:  # noqa: E501
        """It deletes the dataset.  # noqa: E501

        It delete the dataset specified through the pid specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id_and_delete_with_http_info(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to be deleted (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DatasetClass, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_by_id_and_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "DatasetClass",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_by_id_and_replace(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to modify")], datasets_controller_find_by_id_and_replace_request : Annotated[DatasetsControllerFindByIdAndReplaceRequest, Field(..., description="Dataset object that needs to be updated. The whole dataset object with updated fields have to be passed in.")], **kwargs) -> OutputDatasetObsoleteDto:  # noqa: E501
        """It updates the dataset.  # noqa: E501

        It updates(replaces) the dataset specified through the pid provided. If optional fields are not provided they will be removed.       The PUT method is responsible for modifying an existing entity. The crucial part about it is that it is supposed to replace an entity.       Therefore, if we dont send a field of an entity when performing a PUT request, the missing field should be removed from the document.       (Caution: This operation could result with data loss if all the dataset fields are not provided)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id_and_replace(pid, datasets_controller_find_by_id_and_replace_request, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to modify (required)
        :type pid: str
        :param datasets_controller_find_by_id_and_replace_request: Dataset object that needs to be updated. The whole dataset object with updated fields have to be passed in. (required)
        :type datasets_controller_find_by_id_and_replace_request: DatasetsControllerFindByIdAndReplaceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OutputDatasetObsoleteDto
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_by_id_and_replace_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_by_id_and_replace_with_http_info(pid, datasets_controller_find_by_id_and_replace_request, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_by_id_and_replace_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to modify")], datasets_controller_find_by_id_and_replace_request : Annotated[DatasetsControllerFindByIdAndReplaceRequest, Field(..., description="Dataset object that needs to be updated. The whole dataset object with updated fields have to be passed in.")], **kwargs) -> ApiResponse:  # noqa: E501
        """It updates the dataset.  # noqa: E501

        It updates(replaces) the dataset specified through the pid provided. If optional fields are not provided they will be removed.       The PUT method is responsible for modifying an existing entity. The crucial part about it is that it is supposed to replace an entity.       Therefore, if we dont send a field of an entity when performing a PUT request, the missing field should be removed from the document.       (Caution: This operation could result with data loss if all the dataset fields are not provided)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id_and_replace_with_http_info(pid, datasets_controller_find_by_id_and_replace_request, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to modify (required)
        :type pid: str
        :param datasets_controller_find_by_id_and_replace_request: Dataset object that needs to be updated. The whole dataset object with updated fields have to be passed in. (required)
        :type datasets_controller_find_by_id_and_replace_request: DatasetsControllerFindByIdAndReplaceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OutputDatasetObsoleteDto, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'datasets_controller_find_by_id_and_replace_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_by_id_and_replace" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['datasets_controller_find_by_id_and_replace_request'] is not None:
            _body_params = _params['datasets_controller_find_by_id_and_replace_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "OutputDatasetObsoleteDto",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_by_id_and_update(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to modify")], datasets_controller_find_by_id_and_update_request : Annotated[DatasetsControllerFindByIdAndUpdateRequest, Field(..., description="Fields that needs to be updated in the dataset. Only the fields that needs to be updated have to be passed in.")], **kwargs) -> OutputDatasetObsoleteDto:  # noqa: E501
        """It partially updates the dataset.  # noqa: E501

        It updates the dataset through the pid specified. It updates only the specified fields.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id_and_update(pid, datasets_controller_find_by_id_and_update_request, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to modify (required)
        :type pid: str
        :param datasets_controller_find_by_id_and_update_request: Fields that needs to be updated in the dataset. Only the fields that needs to be updated have to be passed in. (required)
        :type datasets_controller_find_by_id_and_update_request: DatasetsControllerFindByIdAndUpdateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OutputDatasetObsoleteDto
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_by_id_and_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_by_id_and_update_with_http_info(pid, datasets_controller_find_by_id_and_update_request, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_by_id_and_update_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Id of the dataset to modify")], datasets_controller_find_by_id_and_update_request : Annotated[DatasetsControllerFindByIdAndUpdateRequest, Field(..., description="Fields that needs to be updated in the dataset. Only the fields that needs to be updated have to be passed in.")], **kwargs) -> ApiResponse:  # noqa: E501
        """It partially updates the dataset.  # noqa: E501

        It updates the dataset through the pid specified. It updates only the specified fields.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_by_id_and_update_with_http_info(pid, datasets_controller_find_by_id_and_update_request, async_req=True)
        >>> result = thread.get()

        :param pid: Id of the dataset to modify (required)
        :type pid: str
        :param datasets_controller_find_by_id_and_update_request: Fields that needs to be updated in the dataset. Only the fields that needs to be updated have to be passed in. (required)
        :type datasets_controller_find_by_id_and_update_request: DatasetsControllerFindByIdAndUpdateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OutputDatasetObsoleteDto, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'datasets_controller_find_by_id_and_update_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_by_id_and_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['datasets_controller_find_by_id_and_update_request'] is not None:
            _body_params = _params['datasets_controller_find_by_id_and_update_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "OutputDatasetObsoleteDto",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_logbook_by_pid(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to delete the datablock specified")], filters : StrictStr, **kwargs) -> Logbook:  # noqa: E501
        """Retrive logbook associated with dataset.  # noqa: E501

        It fetches specific logbook based on dataset pid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_logbook_by_pid(pid, filters, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to delete the datablock specified (required)
        :type pid: str
        :param filters: (required)
        :type filters: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Logbook
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_logbook_by_pid_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_logbook_by_pid_with_http_info(pid, filters, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_logbook_by_pid_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to delete the datablock specified")], filters : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrive logbook associated with dataset.  # noqa: E501

        It fetches specific logbook based on dataset pid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_logbook_by_pid_with_http_info(pid, filters, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to delete the datablock specified (required)
        :type pid: str
        :param filters: (required)
        :type filters: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Logbook, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'filters'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_logbook_by_pid" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        if _params.get('filters') is not None:  # noqa: E501
            _query_params.append(('filters', _params['filters']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "Logbook",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/logbook', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_one(self, filter : Annotated[Optional[StrictStr], Field(description="Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>")] = None, **kwargs) -> OutputDatasetObsoleteDto:  # noqa: E501
        """It returns the first dataset found.  # noqa: E501

        It returns the first dataset of the ones that matches the filter provided. The list returned can be modified by providing a filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one(filter, async_req=True)
        >>> result = thread.get()

        :param filter: Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OutputDatasetObsoleteDto
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_one_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_one_with_http_info(filter, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_one_with_http_info(self, filter : Annotated[Optional[StrictStr], Field(description="Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """It returns the first dataset found.  # noqa: E501

        It returns the first dataset of the ones that matches the filter provided. The list returned can be modified by providing a filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_with_http_info(filter, async_req=True)
        >>> result = thread.get()

        :param filter: Database filters to apply when retrieving datasets <pre>  {    \"where?\": {      \"field\": \"value\"    },    \"include?\": [      {        \"relation\": \"target\",        \"scope\": {          \"where\" : \"<where_condition>\"        ]      }    ],    \"fields?\": [ \"field1\", \"field2\", ...],    \"limits?\": {      \"limit\": number,      \"skip\": number,      \"order\": [ascending, descending]    }  }  </pre>
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OutputDatasetObsoleteDto, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'filter'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_one" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('filter', _params['filter']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "OutputDatasetObsoleteDto",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/findOne', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_one_attachment_and_remove(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to delete the attachment specified")], aid : Annotated[StrictStr, Field(..., description="Identifier of the attachment of this dataset that we would like to delete")], **kwargs) -> None:  # noqa: E501
        """It deletes the attachment from the dataset.  # noqa: E501

        It deletes the attachment from the dataset.<br>This endpoint is obsolete and will be dropped in future versions.<br>Deleting attachments will be allowed only from the attachments endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_attachment_and_remove(pid, aid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to delete the attachment specified (required)
        :type pid: str
        :param aid: Identifier of the attachment of this dataset that we would like to delete (required)
        :type aid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_one_attachment_and_remove_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_one_attachment_and_remove_with_http_info(pid, aid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_one_attachment_and_remove_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to delete the attachment specified")], aid : Annotated[StrictStr, Field(..., description="Identifier of the attachment of this dataset that we would like to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """It deletes the attachment from the dataset.  # noqa: E501

        It deletes the attachment from the dataset.<br>This endpoint is obsolete and will be dropped in future versions.<br>Deleting attachments will be allowed only from the attachments endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_attachment_and_remove_with_http_info(pid, aid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to delete the attachment specified (required)
        :type pid: str
        :param aid: Identifier of the attachment of this dataset that we would like to delete (required)
        :type aid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'pid',
            'aid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_one_attachment_and_remove" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']

        if _params['aid'] is not None:
            _path_params['aid'] = _params['aid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/attachments/{aid}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_one_attachment_and_update(self, pid : Annotated[StrictStr, Field(..., description="Persisten identifier of the dataset for which we would like to update the attachment specified")], aid : Annotated[StrictStr, Field(..., description="Identifier of the attachment of this dataset that we would like to patch")], update_attachment_dto : UpdateAttachmentDto, **kwargs) -> Attachment:  # noqa: E501
        """It updates the attachment specified for the dataset indicated.  # noqa: E501

        It updates the dataset specified by the aid parameter for the dataset indicated by the pid parameter.<br>This endpoint is obsolete and it will removed in future version.<br>Attachments can be updated from the attachment endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_attachment_and_update(pid, aid, update_attachment_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persisten identifier of the dataset for which we would like to update the attachment specified (required)
        :type pid: str
        :param aid: Identifier of the attachment of this dataset that we would like to patch (required)
        :type aid: str
        :param update_attachment_dto: (required)
        :type update_attachment_dto: UpdateAttachmentDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_one_attachment_and_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_one_attachment_and_update_with_http_info(pid, aid, update_attachment_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_one_attachment_and_update_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persisten identifier of the dataset for which we would like to update the attachment specified")], aid : Annotated[StrictStr, Field(..., description="Identifier of the attachment of this dataset that we would like to patch")], update_attachment_dto : UpdateAttachmentDto, **kwargs) -> ApiResponse:  # noqa: E501
        """It updates the attachment specified for the dataset indicated.  # noqa: E501

        It updates the dataset specified by the aid parameter for the dataset indicated by the pid parameter.<br>This endpoint is obsolete and it will removed in future version.<br>Attachments can be updated from the attachment endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_attachment_and_update_with_http_info(pid, aid, update_attachment_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persisten identifier of the dataset for which we would like to update the attachment specified (required)
        :type pid: str
        :param aid: Identifier of the attachment of this dataset that we would like to patch (required)
        :type aid: str
        :param update_attachment_dto: (required)
        :type update_attachment_dto: UpdateAttachmentDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'aid',
            'update_attachment_dto'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_one_attachment_and_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']

        if _params['aid'] is not None:
            _path_params['aid'] = _params['aid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_attachment_dto'] is not None:
            _body_params = _params['update_attachment_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "Attachment",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/attachments/{aid}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_one_datablock_and_remove(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to delete the datablock specified")], did : Annotated[StrictStr, Field(..., description="Identifier of the datablock of this dataset that we would like to delete")], **kwargs) -> None:  # noqa: E501
        """It deletes the datablock from the dataset.  # noqa: E501

        It deletes the datablock from the dataset.<br>This endpoint is obsolete and will be dropped in future versions.<br>Deleting datablocks will be done only from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_datablock_and_remove(pid, did, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to delete the datablock specified (required)
        :type pid: str
        :param did: Identifier of the datablock of this dataset that we would like to delete (required)
        :type did: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_one_datablock_and_remove_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_one_datablock_and_remove_with_http_info(pid, did, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_one_datablock_and_remove_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to delete the datablock specified")], did : Annotated[StrictStr, Field(..., description="Identifier of the datablock of this dataset that we would like to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """It deletes the datablock from the dataset.  # noqa: E501

        It deletes the datablock from the dataset.<br>This endpoint is obsolete and will be dropped in future versions.<br>Deleting datablocks will be done only from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_datablock_and_remove_with_http_info(pid, did, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to delete the datablock specified (required)
        :type pid: str
        :param did: Identifier of the datablock of this dataset that we would like to delete (required)
        :type did: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'pid',
            'did'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_one_datablock_and_remove" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']

        if _params['did'] is not None:
            _path_params['did'] = _params['did']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/datablocks/{did}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_one_datablock_and_update(self, pid : Annotated[StrictStr, Field(..., description="PErsistent identifier of the dataset for which we would like to update the datablocks specified")], did : Annotated[StrictStr, Field(..., description="Identifier of the datablock of this dataset that we would like to patch")], partial_update_datablock_dto : PartialUpdateDatablockDto, **kwargs) -> Datablock:  # noqa: E501
        """It updates the datablocks specified for the dataset indicated.  # noqa: E501

        It updates the datablock specified by the did parameter for the dataset indicated by the pid parameter.<br>This endpoint is obsolete and it will removed in future version.<br>Datablock can be updated from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_datablock_and_update(pid, did, partial_update_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: PErsistent identifier of the dataset for which we would like to update the datablocks specified (required)
        :type pid: str
        :param did: Identifier of the datablock of this dataset that we would like to patch (required)
        :type did: str
        :param partial_update_datablock_dto: (required)
        :type partial_update_datablock_dto: PartialUpdateDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Datablock
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_one_datablock_and_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_one_datablock_and_update_with_http_info(pid, did, partial_update_datablock_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_one_datablock_and_update_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="PErsistent identifier of the dataset for which we would like to update the datablocks specified")], did : Annotated[StrictStr, Field(..., description="Identifier of the datablock of this dataset that we would like to patch")], partial_update_datablock_dto : PartialUpdateDatablockDto, **kwargs) -> ApiResponse:  # noqa: E501
        """It updates the datablocks specified for the dataset indicated.  # noqa: E501

        It updates the datablock specified by the did parameter for the dataset indicated by the pid parameter.<br>This endpoint is obsolete and it will removed in future version.<br>Datablock can be updated from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_datablock_and_update_with_http_info(pid, did, partial_update_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: PErsistent identifier of the dataset for which we would like to update the datablocks specified (required)
        :type pid: str
        :param did: Identifier of the datablock of this dataset that we would like to patch (required)
        :type did: str
        :param partial_update_datablock_dto: (required)
        :type partial_update_datablock_dto: PartialUpdateDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Datablock, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'did',
            'partial_update_datablock_dto'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_one_datablock_and_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']

        if _params['did'] is not None:
            _path_params['did'] = _params['did']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['partial_update_datablock_dto'] is not None:
            _body_params = _params['partial_update_datablock_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "Datablock",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/datablocks/{did}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_one_orig_datablock_and_remove(self, pid : Annotated[StrictStr, Field(..., description="PErsistent identifier of the dataset for which we would like to delete the original datablock specified")], oid : Annotated[StrictStr, Field(..., description="Identifier of the original datablock of this dataset that we would like to delete")], **kwargs) -> None:  # noqa: E501
        """It deletes the origdatablock from the dataset.  # noqa: E501

        It deletes the original datablock from the dataset.<br>This endpoint is obsolete and will be dropped in future versions.<br>Deleting original datablocks will be done only from the origdatablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_orig_datablock_and_remove(pid, oid, async_req=True)
        >>> result = thread.get()

        :param pid: PErsistent identifier of the dataset for which we would like to delete the original datablock specified (required)
        :type pid: str
        :param oid: Identifier of the original datablock of this dataset that we would like to delete (required)
        :type oid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_one_orig_datablock_and_remove_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_one_orig_datablock_and_remove_with_http_info(pid, oid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_one_orig_datablock_and_remove_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="PErsistent identifier of the dataset for which we would like to delete the original datablock specified")], oid : Annotated[StrictStr, Field(..., description="Identifier of the original datablock of this dataset that we would like to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """It deletes the origdatablock from the dataset.  # noqa: E501

        It deletes the original datablock from the dataset.<br>This endpoint is obsolete and will be dropped in future versions.<br>Deleting original datablocks will be done only from the origdatablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_orig_datablock_and_remove_with_http_info(pid, oid, async_req=True)
        >>> result = thread.get()

        :param pid: PErsistent identifier of the dataset for which we would like to delete the original datablock specified (required)
        :type pid: str
        :param oid: Identifier of the original datablock of this dataset that we would like to delete (required)
        :type oid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'pid',
            'oid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_one_orig_datablock_and_remove" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']

        if _params['oid'] is not None:
            _path_params['oid'] = _params['oid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/origdatablocks/{oid}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_find_one_orig_datablock_and_update(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to update the original datablocks specified")], oid : Annotated[StrictStr, Field(..., description="Identifier of the original datablock of this dataset that we would like to patch")], update_orig_datablock_dto : UpdateOrigDatablockDto, **kwargs) -> OrigDatablock:  # noqa: E501
        """It updates the origDatablocks specified for the dataset indicated.  # noqa: E501

        It updates the original datablock specified by the aid parameter for the dataset indicated by the pid parameter.<br>This endpoint is obsolete and it will removed in future version.<br>Original datablocks can be updated from the origdatablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_orig_datablock_and_update(pid, oid, update_orig_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to update the original datablocks specified (required)
        :type pid: str
        :param oid: Identifier of the original datablock of this dataset that we would like to patch (required)
        :type oid: str
        :param update_orig_datablock_dto: (required)
        :type update_orig_datablock_dto: UpdateOrigDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrigDatablock
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_find_one_orig_datablock_and_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_find_one_orig_datablock_and_update_with_http_info(pid, oid, update_orig_datablock_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_find_one_orig_datablock_and_update_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset for which we would like to update the original datablocks specified")], oid : Annotated[StrictStr, Field(..., description="Identifier of the original datablock of this dataset that we would like to patch")], update_orig_datablock_dto : UpdateOrigDatablockDto, **kwargs) -> ApiResponse:  # noqa: E501
        """It updates the origDatablocks specified for the dataset indicated.  # noqa: E501

        It updates the original datablock specified by the aid parameter for the dataset indicated by the pid parameter.<br>This endpoint is obsolete and it will removed in future version.<br>Original datablocks can be updated from the origdatablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_find_one_orig_datablock_and_update_with_http_info(pid, oid, update_orig_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset for which we would like to update the original datablocks specified (required)
        :type pid: str
        :param oid: Identifier of the original datablock of this dataset that we would like to patch (required)
        :type oid: str
        :param update_orig_datablock_dto: (required)
        :type update_orig_datablock_dto: UpdateOrigDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrigDatablock, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid',
            'oid',
            'update_orig_datablock_dto'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_find_one_orig_datablock_and_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']

        if _params['oid'] is not None:
            _path_params['oid'] = _params['oid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_orig_datablock_dto'] is not None:
            _body_params = _params['update_orig_datablock_dto']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "OrigDatablock",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/origdatablocks/{oid}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_fullfacet(self, facets : Optional[StrictStr] = None, fields : Optional[StrictStr] = None, **kwargs) -> List[FullFacetResponse]:  # noqa: E501
        """datasets_controller_fullfacet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_fullfacet(facets, fields, async_req=True)
        >>> result = thread.get()

        :param facets:
        :type facets: str
        :param fields:
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[FullFacetResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_fullfacet_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_fullfacet_with_http_info(facets, fields, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_fullfacet_with_http_info(self, facets : Optional[StrictStr] = None, fields : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """datasets_controller_fullfacet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_fullfacet_with_http_info(facets, fields, async_req=True)
        >>> result = thread.get()

        :param facets:
        :type facets: str
        :param fields:
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[FullFacetResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'facets',
            'fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_fullfacet" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('facets') is not None:  # noqa: E501
            _query_params.append(('facets', _params['facets']))

        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[FullFacetResponse]",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/fullfacet', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_fullquery(self, limits : Optional[StrictStr] = None, fields : Optional[StrictStr] = None, **kwargs) -> List[OutputDatasetObsoleteDto]:  # noqa: E501
        """It returns a list of datasets matching the query provided.  # noqa: E501

        It returns a list of datasets matching the query provided.<br>This endpoint still needs some work on the query specification.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_fullquery(limits, fields, async_req=True)
        >>> result = thread.get()

        :param limits:
        :type limits: str
        :param fields:
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OutputDatasetObsoleteDto]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_fullquery_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_fullquery_with_http_info(limits, fields, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_fullquery_with_http_info(self, limits : Optional[StrictStr] = None, fields : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """It returns a list of datasets matching the query provided.  # noqa: E501

        It returns a list of datasets matching the query provided.<br>This endpoint still needs some work on the query specification.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_fullquery_with_http_info(limits, fields, async_req=True)
        >>> result = thread.get()

        :param limits:
        :type limits: str
        :param fields:
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OutputDatasetObsoleteDto], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'limits',
            'fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_fullquery" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('limits') is not None:  # noqa: E501
            _query_params.append(('limits', _params['limits']))

        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[OutputDatasetObsoleteDto]",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/fullquery', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_is_valid(self, datasets_controller_create_request : Annotated[DatasetsControllerCreateRequest, Field(..., description="Input fields for the dataset that needs to be validated")], **kwargs) -> IsValidResponse:  # noqa: E501
        """It validates the dataset provided as input.  # noqa: E501

        It validates the dataset provided as input, and returns true if the information is a valid dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_is_valid(datasets_controller_create_request, async_req=True)
        >>> result = thread.get()

        :param datasets_controller_create_request: Input fields for the dataset that needs to be validated (required)
        :type datasets_controller_create_request: DatasetsControllerCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IsValidResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_is_valid_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_is_valid_with_http_info(datasets_controller_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_is_valid_with_http_info(self, datasets_controller_create_request : Annotated[DatasetsControllerCreateRequest, Field(..., description="Input fields for the dataset that needs to be validated")], **kwargs) -> ApiResponse:  # noqa: E501
        """It validates the dataset provided as input.  # noqa: E501

        It validates the dataset provided as input, and returns true if the information is a valid dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_is_valid_with_http_info(datasets_controller_create_request, async_req=True)
        >>> result = thread.get()

        :param datasets_controller_create_request: Input fields for the dataset that needs to be validated (required)
        :type datasets_controller_create_request: DatasetsControllerCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IsValidResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'datasets_controller_create_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_is_valid" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['datasets_controller_create_request'] is not None:
            _body_params = _params['datasets_controller_create_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "IsValidResponse",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/isValid', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_metadata_keys(self, limits : Annotated[Optional[StrictStr], Field(description="Define further query parameters like skip, limit, order")] = None, fields : Annotated[Optional[StrictStr], Field(description="Define the filter conditions by specifying the name of values of fields requested. There is also support for a `text` search to look for strings anywhere in the dataset.")] = None, **kwargs) -> List[str]:  # noqa: E501
        """It returns a list of metadata keys contained in the datasets matching the filter provided.  # noqa: E501

        It returns a list of metadata keys contained in the datasets matching the filter provided.<br>This endpoint still needs some work on the filter and facets specification.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_metadata_keys(limits, fields, async_req=True)
        >>> result = thread.get()

        :param limits: Define further query parameters like skip, limit, order
        :type limits: str
        :param fields: Define the filter conditions by specifying the name of values of fields requested. There is also support for a `text` search to look for strings anywhere in the dataset.
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[str]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_metadata_keys_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_metadata_keys_with_http_info(limits, fields, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_metadata_keys_with_http_info(self, limits : Annotated[Optional[StrictStr], Field(description="Define further query parameters like skip, limit, order")] = None, fields : Annotated[Optional[StrictStr], Field(description="Define the filter conditions by specifying the name of values of fields requested. There is also support for a `text` search to look for strings anywhere in the dataset.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """It returns a list of metadata keys contained in the datasets matching the filter provided.  # noqa: E501

        It returns a list of metadata keys contained in the datasets matching the filter provided.<br>This endpoint still needs some work on the filter and facets specification.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_metadata_keys_with_http_info(limits, fields, async_req=True)
        >>> result = thread.get()

        :param limits: Define further query parameters like skip, limit, order
        :type limits: str
        :param fields: Define the filter conditions by specifying the name of values of fields requested. There is also support for a `text` search to look for strings anywhere in the dataset.
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[str], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'limits',
            'fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_metadata_keys" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('limits') is not None:  # noqa: E501
            _query_params.append(('limits', _params['limits']))

        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[str]",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/metadataKeys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_orig_datablock_is_valid(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset we would like to create a new original datablock for")], create_dataset_orig_datablock_dto : CreateDatasetOrigDatablockDto, **kwargs) -> None:  # noqa: E501
        """It validates the origDatablock values passed.  # noqa: E501

        It validates the original datablock values pased as input.<br>This endpoint is obsolete and will be dropped in future versions.<br>Validating orginal datablocks will be allowed only from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_orig_datablock_is_valid(pid, create_dataset_orig_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset we would like to create a new original datablock for (required)
        :type pid: str
        :param create_dataset_orig_datablock_dto: (required)
        :type create_dataset_orig_datablock_dto: CreateDatasetOrigDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_orig_datablock_is_valid_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_orig_datablock_is_valid_with_http_info(pid, create_dataset_orig_datablock_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_orig_datablock_is_valid_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset we would like to create a new original datablock for")], create_dataset_orig_datablock_dto : CreateDatasetOrigDatablockDto, **kwargs) -> ApiResponse:  # noqa: E501
        """It validates the origDatablock values passed.  # noqa: E501

        It validates the original datablock values pased as input.<br>This endpoint is obsolete and will be dropped in future versions.<br>Validating orginal datablocks will be allowed only from the datablocks endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_orig_datablock_is_valid_with_http_info(pid, create_dataset_orig_datablock_dto, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset we would like to create a new original datablock for (required)
        :type pid: str
        :param create_dataset_orig_datablock_dto: (required)
        :type create_dataset_orig_datablock_dto: CreateDatasetOrigDatablockDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'pid',
            'create_dataset_orig_datablock_dto'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_orig_datablock_is_valid" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_dataset_orig_datablock_dto'] is not None:
            _body_params = _params['create_dataset_orig_datablock_dto']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/origdatablocks/isValid', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_controller_thumbnail(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset")], **kwargs) -> Attachment:  # noqa: E501
        """It returns the thumbnail associated with the dataset.  # noqa: E501

        It returns the thumbnail associated with the dataset with the provided pid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_thumbnail(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attachment
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_controller_thumbnail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_controller_thumbnail_with_http_info(pid, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_controller_thumbnail_with_http_info(self, pid : Annotated[StrictStr, Field(..., description="Persistent identifier of the dataset")], **kwargs) -> ApiResponse:  # noqa: E501
        """It returns the thumbnail associated with the dataset.  # noqa: E501

        It returns the thumbnail associated with the dataset with the provided pid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_controller_thumbnail_with_http_info(pid, async_req=True)
        >>> result = thread.get()

        :param pid: Persistent identifier of the dataset (required)
        :type pid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attachment, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'pid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_controller_thumbnail" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['pid'] is not None:
            _path_params['pid'] = _params['pid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearer']  # noqa: E501

        _response_types_map = {
            '200': "Attachment",
        }

        return self.api_client.call_api(
            '/api/v3/datasets/{pid}/thumbnail', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
