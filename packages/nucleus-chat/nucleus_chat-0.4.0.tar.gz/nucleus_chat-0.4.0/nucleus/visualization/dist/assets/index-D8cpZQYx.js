import{aQ as M}from"./index-Bm2SqMk3.js";function L(o){const e=[];let n="",i=!1,t=!1;for(const r of o)r==='"'?(i=!i,n+=r):r==="["?(t=!0,n+=r):r==="]"?(t=!1,n+=r):r===","&&!i&&!t?(e.push(n.trim()),n=""):n+=r;return n&&e.push(n.trim()),e}function C(o){const e=o.replace(/^<|>$/g,"");return Object.fromEntries(L(e).map(n=>{const[i,t]=n.split("=").map(r=>r.trim());return t&&t.startsWith("[")&&t.endsWith("]")?[i,t.slice(1,-1).split(",").map(r=>r.trim())]:t&&t.startsWith('"')&&t.endsWith('"')?[i,t.slice(1,-1)]:[i,t==null?void 0:t.replaceAll(/^"|"$/g,"")]}))}const N={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function w(o){try{return decodeURIComponent(o)}catch{return o}}class Q{constructor({header:e="",strict:n=!0}){if(!e.length)throw new Error("empty header received");const i=e.split(/[\r\n]+/).filter(Boolean);if(!i.length)throw new Error("no non-empty header lines specified");this.strict=n,this.metadata=JSON.parse(JSON.stringify({INFO:N.InfoFields,FORMAT:N.GenotypeFields,ALT:N.AltTypes,FILTER:N.FilterTypes}));let t;if(i.forEach(a=>{if(a.startsWith("#"))a.startsWith("##")?this.parseMetadata(a):t=a;else throw new Error(`Bad line in header:
${a}`)}),!t)throw new Error("No format line found in header");const r=t.trim().split("	"),l=r.slice(0,8),s=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(r.length<8)throw new Error(`VCF header missing columns:
${t}`);if(l.length!==s.length||!l.every((a,c)=>a===s[c]))throw new Error(`VCF column headers not correct:
${t}`);this.samples=r.slice(9)}parseSamples(e,n){const i={};if(e){const t=n.split("	"),r=e.split(":"),l=r.map(s=>{const a=this.getMetadata("FORMAT",s,"Type");return a==="Integer"||a==="Float"});for(let s=0;s<this.samples.length;s++){const a=this.samples[s];i[a]={};const c=t[s].split(":");for(let p=0;p<c.length;p++){const m=c[p];i[a][r[p]]=m===""||m==="."?void 0:m.split(",").map(f=>f==="."?void 0:l[p]?+f:f)}}}return i}parseGenotypesOnly(e,n){const i=n.split("	"),t={};let r=0;const l=e.split(":");if(l.length===1)for(const s of this.samples)t[s]=i[r++];else{const s=l.indexOf("GT");if(s===0)for(const a of this.samples){const c=i[r++],p=c.indexOf(":");p!==-1?t[a]=c.slice(0,p):console.warn("unknown")}else for(const a of this.samples){const c=i[r++].split(":");t[a]=c[s]}}return t}parseMetadata(e){const n=/^##(.+?)=(.*)/.exec(e.trim());if(!n)throw new Error(`Line is not a valid metadata line: ${e}`);const[i,t]=n.slice(1,3),r=i;if(t!=null&&t.startsWith("<")){r in this.metadata||(this.metadata[r]={});const[l,s]=this.parseStructuredMetaVal(t);l?this.metadata[r][l]=s:this.metadata[r]=s}else this.metadata[r]=t}parseStructuredMetaVal(e){const n=C(e),i=n.ID;return delete n.ID,"Number"in n&&(Number.isNaN(Number(n.Number))||(n.Number=Number(n.Number))),[i,n]}getMetadata(...e){let n=this.metadata;for(const i of e)if(n=n[i],!n)return n;return n}parseLine(e){var n;let i=0;for(let u=0;i<e.length&&(e[i]==="	"&&(u+=1),u!==9);i+=1);const t=e.slice(0,i).split("	"),r=e.slice(i+1),[l,s,a,c,p,m,f]=t,S=l,v=+s,A=a==="."?void 0:a.split(";"),E=c,R=p==="."?void 0:p.split(","),F=m==="."?void 0:+m,y=f==="."?void 0:f.split(";");if(this.strict&&!t[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const P=(n=t[7])===null||n===void 0?void 0:n.includes("%"),O=t[7]===void 0||t[7]==="."?{}:Object.fromEntries(t[7].split(";").map(u=>{const[g,b]=u.split("="),h=b==null?void 0:b.split(",").map(d=>d==="."?void 0:d).map(d=>d&&P?w(d):d),T=this.getMetadata("INFO",g,"Type");return T==="Integer"||T==="Float"?[g,h==null?void 0:h.map(d=>d===void 0?void 0:Number(d))]:T==="Flag"?[g,!0]:[g,h??!0]}));return{CHROM:S,POS:v,ALT:R,INFO:O,REF:E,FILTER:y&&y.length===1&&y[0]==="PASS"?"PASS":y,ID:A,QUAL:F,SAMPLES:()=>{var u;return this.parseSamples((u=t[8])!==null&&u!==void 0?u:"",r)},GENOTYPES:()=>{var u;return this.parseGenotypesOnly((u=t[8])!==null&&u!==void 0?u:"",r)}}}}const V={DEL:"deletion",INS:"insertion",DUP:"duplication",INV:"inversion",INVDUP:"inverted_duplication",CNV:"copy_number_variation",TRA:"translocation","DUP:TANDEM":"tandem_duplication",NON_REF:"sequence_variant","*":"sequence_variant"};function G(o,e,n){if(!e||e.length===0)return["remark","no alternative alleles"];const i=new Set;let t=new Set;if(e.forEach(r=>{let[l,s]=I(r,n);l||([l,s]=k(o,r)),l&&s&&(i.add(l),t.add(s))}),t.size>1){const r=[...t],l=new Set(r.map(s=>{const a=s.split("->");return a[1]?a[0]:s}).filter(s=>!!s));t=new Set([...l].map(s=>s.trim()).map(s=>{const a=r.map(c=>c.split("->").map(p=>p.trim())).map(c=>c[1]&&c[0]===s?c[1]:"").filter(c=>!!c);return a.length?`${s} -> ${a.join(",")}`:s}))}return i.size?[[...i].join(","),[...t].join(",")]:[]}function I(o,e){if(typeof o=="string"&&!o.startsWith("<"))return[];let n=V[o];if(!n&&e.getMetadata("ALT",o)&&(n="sequence_variant"),n)return[n,o];const i=o.split(":");return i.length>1?I(`<${i.slice(0,-1).join(":")}>`,e):[]}function k(o,e){if(M(e))return["breakend",e];if(o.length===1&&e.length===1)return["SNV",D("SNV",o,e)];if(e==="<INS>")return["insertion",e];if(e==="<DEL>")return["deletion",e];if(e==="<DUP>")return["duplication",e];if(e==="<CNV>")return["cnv",e];if(e==="<INV>")return["inversion",e];if(e==="<TRA>")return["translocation",e];if(e.includes("<"))return["sv",e];if(o.length===e.length)return o.split("").reverse().join("")===e?["inversion",D("inversion",o,e)]:["substitution",D("substitution",o,e)];if(o.length<=e.length){const i=e.length-o.length,t=i.toLocaleString("en-US");return["insertion",i>5?`${t}bp INS`:D("insertion",o,e)]}if(o.length>e.length){const i=o.length-e.length,t=i.toLocaleString("en-US");return["deletion",i>5?`${t}bp DEL`:D("deletion",o,e)]}return["indel",D("indel",o,e)]}function D(o,e,n){return`${o} ${e} -> ${n}`}function _(o,e){const{REF:n="",ALT:i,POS:t,CHROM:r,ID:l}=o,s=t-1,[a,c]=G(n,i,e);return{refName:r,start:s,end:q(o),description:c,type:a,name:l==null?void 0:l.join(","),aliases:l&&l.length>1?l.slice(1):void 0}}function q(o){const{POS:e,REF:n="",ALT:i}=o,t=i==null?void 0:i.includes("<TRA>"),r=e-1;if(i==null?void 0:i.some(s=>s.includes("<"))){const s=o.INFO;if(s.END&&!t)return+s.END[0]}return r+n.length}class ${constructor(e){this.variant=e.variant,this.parser=e.parser,this.data=_(this.variant,this.parser),this._id=e.id}get(e){var n;return e==="samples"?this.variant.SAMPLES():e==="genotypes"?this.variant.GENOTYPES():(n=this.data[e])!==null&&n!==void 0?n:this.variant[e]}parent(){}children(){}id(){return this._id}toJSON(){const{SAMPLES:e,GENOTYPES:n,...i}=this.variant;return{uniqueId:this._id,...i,...this.data,samples:this.variant.SAMPLES()}}}export{Q as V,$ as a};
