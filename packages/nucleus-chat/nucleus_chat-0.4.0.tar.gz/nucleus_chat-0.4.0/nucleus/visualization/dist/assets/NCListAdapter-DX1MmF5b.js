import{g as D,au as U,by as q,s as M}from"./rpcWorker-CVTx5FIM.js";import{A as _}from"./AbortablePromiseCache-xs5eyOH3.js";import{B as O}from"./index-P3rx-5SH.js";import{r as I}from"./rxjs-Dgg09m9e.js";var S={exports:{}},J=S.exports,A;function P(){return A||(A=1,function(y,t){(function(e,s){y.exports=s()})(J,function(){const e=/^[\w+.-]+:\/\//,s=/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,i=/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;function r(n){return e.test(n)}function a(n){return n.startsWith("//")}function c(n){return n.startsWith("/")}function u(n){return n.startsWith("file:")}function m(n){return/^[.?#]/.test(n)}function g(n){const h=s.exec(n);return l(h[1],h[2]||"",h[3],h[4]||"",h[5]||"/",h[6]||"",h[7]||"")}function d(n){const h=i.exec(n),o=h[2];return l("file:","",h[1]||"","",c(o)?o:"/"+o,h[3]||"",h[4]||"")}function l(n,h,o,p,w,f,k){return{scheme:n,user:h,host:o,port:p,path:w,query:f,hash:k,type:7}}function b(n){if(a(n)){const o=g("http:"+n);return o.scheme="",o.type=6,o}if(c(n)){const o=g("http://foo.com"+n);return o.scheme="",o.host="",o.type=5,o}if(u(n))return d(n);if(r(n))return g(n);const h=g("http://foo.com/"+n);return h.scheme="",h.host="",h.type=n?n.startsWith("?")?3:n.startsWith("#")?2:4:1,h}function C(n){if(n.endsWith("/.."))return n;const h=n.lastIndexOf("/");return n.slice(0,h+1)}function T(n,h){L(h,h.type),n.path==="/"?n.path=h.path:n.path=C(h.path)+n.path}function L(n,h){const o=h<=4,p=n.path.split("/");let w=1,f=0,k=!1;for(let F=1;F<p.length;F++){const R=p[F];if(!R){k=!0;continue}if(k=!1,R!=="."){if(R===".."){f?(k=!0,f--,w--):o&&(p[w++]=R);continue}p[w++]=R,f++}}let x="";for(let F=1;F<w;F++)x+="/"+p[F];(!x||k&&!x.endsWith("/.."))&&(x+="/"),n.path=x}function z(n,h){if(!n&&!h)return"";const o=b(n);let p=o.type;if(h&&p!==7){const f=b(h),k=f.type;switch(p){case 1:o.hash=f.hash;case 2:o.query=f.query;case 3:case 4:T(o,f);case 5:o.user=f.user,o.host=f.host,o.port=f.port;case 6:o.scheme=f.scheme}k>p&&(p=k)}L(o,p);const w=o.query+o.hash;switch(p){case 2:case 3:return w;case 4:{const f=o.path.slice(1);return f?m(h||n)&&!m(f)?"./"+f+w:f+w:w||"."}case 5:return o.path+w;default:return o.scheme+"//"+o.user+o.host+o.port+o.path+w}}return z})}(S)),S.exports}var W=P(),$=D(W);async function E(y,t,e={}){const{defaultContent:s={}}=e;let i;try{return i=await t(y,{encoding:"utf8"}),JSON.parse(i)}catch(r){if(r.code==="ENOENT"||r.status===404||r.message.includes("404")||r.message.includes("ENOENT"))return s;throw r}}function N(y,t="."){return $(y,t)}class G{constructor({readFile:t,cacheSize:e=100}){if(this.topList=[],this.chunkCache=new _({cache:new U({maxSize:e}),fill:this.readChunkItems.bind(this)}),this.readFile=t,!this.readFile)throw new Error('must provide a "readFile" function')}importExisting(t,e,s,i,r){this.topList=t,this.attrs=e,this.start=e.makeFastGetter("Start"),this.end=e.makeFastGetter("End"),this.lazyClass=r,this.baseURL=s,this.lazyUrlTemplate=i}binarySearch(t,e,s){let i=-1,r=t.length,a;for(;r-i>1;)a=i+r>>>1,s(t[a])>=e?r=a:i=a;return s===this.end?r:i}readChunkItems(t){const e=N(this.lazyUrlTemplate.replace(/\{Chunk\}/gi,t),this.baseURL);return E(e,this.readFile,{defaultContent:[]})}async*iterateSublist(t,e,s,i,r,a,c){const u=this.attrs.makeGetter("Chunk"),m=this.attrs.makeGetter("Sublist"),g=[];for(let d=this.binarySearch(t,e,r);d<t.length&&d>=0&&i*a(t[d])<i*s;d+=i){if(t[d][0]===this.lazyClass){const b=u(t[d]),C=this.chunkCache.get(b,b).then(T=>[T,b]);g.push(C)}else yield[t[d],c.concat(d)];const l=m(t[d]);l&&(yield*this.iterateSublist(l,e,s,i,r,a,c.concat(d)))}for(let d=0;d<g.length;d+=1){const[l,b]=await g[d];l&&(yield*this.iterateSublist(l,e,s,i,r,a,[...c,b]))}}async*iterate(t,e){const s=t>e?-1:1,i=t>e?this.start:this.end,r=t>e?this.end:this.start;this.topList.length>0&&(yield*this.iterateSublist(this.topList,t,e,s,i,r,[0]))}async histogram(t,e,s){const i=new Array(s);i.fill(0);const r=(e-t)/s;for await(const a of this.iterate(t,e)){const c=Math.max(0,(this.start(a)-t)/r|0),u=Math.min(s,(this.end(a)-t)/r|0);for(let m=c;m<=u;m+=1)i[m]+=1}return i}}class H{constructor(t){this.classes=t,this.fields=[];for(let e=0;e<t.length;e+=1){this.fields[e]={};for(let s=0;s<t[e].attributes.length;s+=1)this.fields[e][t[e].attributes[s]]=s+1;t[e].proto===void 0&&(t[e].proto={}),t[e].isArrayAttr===void 0&&(t[e].isArrayAttr={})}}attrIndices(t){return this.classes.map(e=>e.attributes.indexOf(t)+1||e.attributes.indexOf(t.toLowerCase())+1||void 0)}get(t,e){if(e in this.fields[t[0]])return t[this.fields[t[0]][e]];const s=e.toLowerCase();if(s in this.fields[t[0]])return t[this.fields[t[0]][s]];const i=this.classes[t[0]].attributes.length+1;return i>=t.length||!(e in t[i])?e in this.classes[t[0]].proto?this.classes[t[0]].proto[e]:void 0:t[i][e]}makeSetter(t){return(e,s)=>{this.set(e,t,s)}}makeGetter(t){return e=>this.get(e,t)}makeFastGetter(t){const e=this.attrIndices(t);return function(i){if(e[i[0]]!==void 0)return i[e[i[0]]]}}accessors(){return this._accessors||(this._accessors=this._makeAccessors()),this._accessors}_makeAccessors(){const t={},e={get(i){const r=this.get.field_accessors[i.toLowerCase()];if(r)return r.call(this)},set(i,r){const a=this.set.field_accessors[i];if(a)return a.call(this,r)},tags(){return s[this[0]]||[]}};e.get.field_accessors={},e.set.field_accessors={},this.classes.forEach((i,r)=>{(i.attributes||[]).forEach((a,c)=>{t[a]=t[a]||[],t[a][r]=c+1,a=a.toLowerCase(),t[a]=t[a]||[],t[a][r]=c+1})});const s=this.classes.map(i=>i.attributes);return Object.keys(t).forEach(i=>{const r=t[i];e.get.field_accessors[i]=r?function(){return this[r[this[0]]]}:function(){}}),e}}class Q{constructor({urlTemplate:t,chunkSize:e,length:s,cacheSize:i=100,readFile:r},a){if(this.urlTemplate=t,this.chunkSize=e,this.length=s,this.baseUrl=a===void 0?"":a,this.readFile=r,!r)throw new Error("must provide readFile callback");this.chunkCache=new _({cache:new U({maxSize:i}),fill:this.getChunk.bind(this)})}index(t,e,s){this.range(t,t,e,void 0,s)}async*range(t,e){t=Math.max(0,t),e=Math.min(e,this.length-1);const s=Math.floor(t/this.chunkSize),i=Math.floor(e/this.chunkSize),r=[];for(let a=s;a<=i;a+=1)r.push(this.chunkCache.get(a,a));for(let a=0;a<r.length;a+=1){const[c,u]=await r[a];yield*this.filterChunkData(t,e,c,u)}}async getChunk(t){let e=this.urlTemplate.replace(/\{Chunk\}/gi,t);this.baseUrl&&(e=N(e,this.baseUrl));const s=await E(e,this.readFile);return[t,s]}*filterChunkData(t,e,s,i){const r=s*this.chunkSize,a=Math.max(0,t-r),c=Math.min(e-r,this.chunkSize-1);for(let u=a;u<=c;u+=1)yield[u+r,i[u]]}}function j(){return this._uniqueID}function B(){return this._parent}function K(){return this.get("subfeatures")}class V{constructor({baseUrl:t,urlTemplate:e,readFile:s,cacheSize:i=10}){if(this.baseUrl=t,this.urlTemplates={root:e},this.readFile=s,!this.readFile)throw new Error('must provide a "readFile" function argument');this.dataRootCache=new _({cache:new U({maxSize:i}),fill:this.fetchDataRoot.bind(this)})}makeNCList(){return new G({readFile:this.readFile})}loadNCList(t,e,s){t.nclist.importExisting(e.intervals.nclist,t.attrs,s,e.intervals.urlTemplate,e.intervals.lazyClass)}getDataRoot(t){return this.dataRootCache.get(t,t)}fetchDataRoot(t){const e=N(this.urlTemplates.root.replace(/{\s*refseq\s*}/g,t),this.baseUrl);return E(e,this.readFile).then(s=>this.parseTrackInfo(s,e))}parseTrackInfo(t,e){const s={nclist:this.makeNCList(),stats:{featureCount:t.featureCount||0}};t.intervals&&(s.attrs=new H(t.intervals.classes),this.loadNCList(s,t,e));const{histograms:i}=t;if(i&&i.meta){for(let r=0;r<i.meta.length;r+=1)i.meta[r].lazyArray=new Q({...i.meta[r].arrayParams,readFile:this.readFile},e);s._histograms=i}return s._histograms&&Object.keys(s._histograms).forEach(r=>{s._histograms[r].forEach(c=>{Object.keys(c).forEach(u=>{typeof c[u]=="string"&&String(Number(c[u]))===c[u]&&(c[u]=Number(c[u]))})})}),s}async getRegionStats(t){return(await this.getDataRoot(t.ref)).stats}async getRegionFeatureDensities({refName:t,start:e,end:s,numBins:i,basesPerBin:r}){const a=await this.getDataRoot(t);if(i)r=(s-e)/i;else if(r)i=Math.ceil((s-e)/r);else throw new TypeError("numBins or basesPerBin arg required for getRegionFeatureDensities");const u=(a._histograms.stats||[]).find(l=>l.basesPerBin>=r);let m=a._histograms.meta[0];for(let l=0;l<a._histograms.meta.length;l+=1)r>=a._histograms.meta[l].basesPerBin&&(m=a._histograms.meta[l]);let g=r/m.basesPerBin;if(g>.9&&Math.abs(g-Math.round(g))<1e-4){const l=Math.floor(e/m.basesPerBin);g=Math.round(g);const b=[];for(let C=0;C<i;C+=1)b[C]=0;for await(const[C,T]of m.lazyArray.range(l,l+g*i-1))b[Math.floor((C-l)/g)]+=T;return{bins:b,stats:u}}return{bins:await a.nclist.histogram(e,s,i),stats:u}}async*getFeatures({refName:t,start:e,end:s}){const i=await this.getDataRoot(t),r=i.attrs&&i.attrs.accessors();for await(const[a,c]of i.nclist.iterate(e,s)){if(!a.decorated){const u=c.join(",");this.decorateFeature(r,a,`${t},${u}`)}yield a}}decorateFeature(t,e,s,i){e.get=t.get,e.tags=t.tags,e._uniqueID=s,e.id=j,e._parent=i,e.parent=B,e.children=K,(e.get("subfeatures")||[]).forEach((r,a)=>{this.decorateFeature(t,r,`${s}-${a}`,e)}),e.decorated=!0}}const X={refName:"seq_id"},Y={seq_id:"refName"};class v{constructor(t,e,s){this.ncFeature=t,this.uniqueId=s||t.id(),this.parentHandle=e}set(){throw new Error("not implemented")}jb2TagToJb1Tag(t){return(X[t]||t).toLowerCase()}jb1TagToJb2Tag(t){const e=t.toLowerCase();return Y[e]||e}get(t){const e=this.ncFeature.get(this.jb2TagToJb1Tag(t));return e&&t==="subfeatures"?e.map(s=>new v(s,this)):e}tags(){return this.ncFeature.tags().map(t=>this.jb1TagToJb2Tag(t))}id(){return this.uniqueId}parent(){return this.parentHandle}children(){return this.get("subfeatures")}toJSON(){const t={uniqueId:this.id()};return this.ncFeature.tags().forEach(e=>{const s=this.jb1TagToJb2Tag(e),i=this.ncFeature.get(e);s==="subfeatures"?t.subfeatures=(i||[]).map(r=>new v(r,this).toJSON()):t[s]=i}),t}}class it extends O.BaseFeatureDataAdapter{constructor(t,e,s){super(t,e,s);const i=this.getConf("refNames"),r=this.getConf("rootUrlTemplate");this.configRefNames=i,this.nclist=new V({baseUrl:"",urlTemplate:r.uri,readFile:a=>new q(String(r.baseUri?new URL(a,r.baseUri).toString():a)).readFile()})}getFeatures(t,e={}){return I.ObservableCreate(async s=>{const{stopToken:i}=e;for await(const r of this.nclist.getFeatures(t,e))M.checkStopToken(i),s.next(this.wrapFeature(r));s.complete()})}wrapFeature(t){return new v(t,void 0,`${this.id}-${t.id()}`)}async hasDataForRefName(t){var e;const s=await this.nclist.getDataRoot(t);return!!(!((e=s==null?void 0:s.stats)===null||e===void 0)&&e.featureCount)}async getRefNames(){return this.configRefNames||[]}freeResources(){}}export{it as default};
