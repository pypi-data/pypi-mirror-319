import{aS as I,ar as g,c as z,i as S}from"./rpcWorker-CVTx5FIM.js";import{B as U}from"./index-P3rx-5SH.js";import{r as _}from"./rxjs-Dgg09m9e.js";import{S as P}from"./simpleFeature-DW3q5zmr.js";const y=BigInt(32);function q(f,e,t){const s=+!!t,o=+!t;return BigInt(f.getInt32(e,t)*o+f.getInt32(e+4,t)*s)<<y|BigInt(f.getUint32(e,t)*s+f.getUint32(e+4,t)*o)}function O(f,e,t){const s=f.getUint32(e,t),o=f.getUint32(e+4,t),i=+!!t,n=+!t;return BigInt(s*n+o*i)<<y|BigInt(s*i+o*n)}"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(f,e){return q(this,f,e)});"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(f,e){return O(this,f,e)});const x=440477507,w=["T","C","A","G"],p=[];for(let f=0;f<256;f++)p.push(w[f>>6&3]+w[f>>4&3]+w[f>>2&3]+w[f&3]);const C=p.map(f=>f.toLowerCase());class D{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else if(t)this.filehandle=new I(t);else throw new Error("must supply path or filehandle")}async _detectEndianness(){const e=await this.filehandle.read(g.Buffer.allocUnsafe(8),0,8,0),{buffer:t}=e;if(t.readInt32LE(0)===x)this.version=t.readInt32LE(4);else throw t.readInt32BE(0)===x?new Error("big endian not supported"):new Error("not a 2bit file")}getHeader(){return this.headerP||(this.headerP=this._getHeader().catch(e=>{throw this.headerP=void 0,e})),this.headerP}async _getHeader(){await this._detectEndianness();const{buffer:e}=await this.filehandle.read(g.Buffer.allocUnsafe(16),0,16,0),t=e,s=!0,o=new DataView(t.buffer,t.byteOffset,t.length);let i=0;const n=o.getInt32(i,s);if(i+=4,n!==440477507)throw new Error(`Wrong magic number ${n}`);const a=o.getInt32(i,s);i+=4;const r=o.getUint32(i,s);i+=4;const u=o.getUint32(i,s);return{version:a,magic:n,sequenceCount:r,reserved:u}}getIndex(){return this.indexP||(this.indexP=this._getIndex().catch(e=>{throw this.indexP=void 0,e})),this.indexP}async _getIndex(){const e=await this.getHeader(),t=8+e.sequenceCount*(257+(this.version===1?8:4)),{buffer:s}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,8),o=!0,i=s,n=new DataView(i.buffer,i.byteOffset,i.length);let a=0;const r=n.getUint32(a,o);a+=4,a+=4;const u=[];for(let d=0;d<r;d++){const h=n.getUint8(a);a+=1;const l=s.subarray(a,a+h).toString();if(a+=h,e.version===1){const c=Number(n.getBigUint64(a,o));a+=8,u.push({offset:c,name:l})}else{const c=n.getUint32(a,o);a+=4,u.push({offset:c,name:l})}}return Object.fromEntries(u.map(({name:d,offset:h})=>[d,h]))}async getSequenceNames(){const e=await this.getIndex();return Object.keys(e)}async getSequenceSizes(){const e=await this.getIndex(),t=Object.keys(e),s=Object.values(e).map(n=>this._getSequenceSize(n)),o=await Promise.all(s),i={};for(const[n,a]of t.entries())i[a]=o[n];return i}async getSequenceSize(e){const s=(await this.getIndex())[e];if(s)return this._getSequenceSize(s)}async _getSequenceSize(e){return this._record1(e).then(t=>t.dnaSize)}async _record1(e,t=8){const{buffer:s}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,e),o=s,i=!0;let n=0;const a=new DataView(o.buffer,o.byteOffset,o.length),r=a.getUint32(n,i);n+=4;const u=a.getUint32(n,i);return n+=4,{dnaSize:r,nBlockCount:u}}async _record2(e,t){const{buffer:s}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,e),o=s,i=!0;let n=0;const a=new DataView(o.buffer,o.byteOffset,o.length),r=a.getUint32(n,i);n+=4;const u=[];for(let l=0;l<r;l++){const c=a.getUint32(n,i);n+=4,u.push(c)}const d=[];for(let l=0;l<r;l++){const c=a.getUint32(n,i);n+=4,d.push(c)}return{maskBlockCount:a.getUint32(n,i),nBlockSizes:d,nBlockStarts:u}}async _record3(e,t){const{buffer:s}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,e),o=s,i=!0;let n=0;const a=new DataView(o.buffer,o.byteOffset,o.length),r=a.getUint32(n,i);n+=4;const u=[];for(let l=0;l<r;l++){const c=a.getUint32(n,i);n+=4,u.push(c)}const d=[];for(let l=0;l<r;l++){const c=a.getUint32(n,i);n+=4,d.push(c)}const h=a.getInt32(n,i);return{maskBlockCount:r,maskBlockSizes:d,maskBlockStarts:u,reserved:h}}async _getSequenceRecord(e){const t=await this._record1(e),s=t.nBlockCount*8+8,o=await this._record2(e+4,s),i=o.maskBlockCount*8+8,n=await this._record3(e+4+s-4,i);return{dnaSize:t.dnaSize,nBlocks:{starts:o.nBlockStarts,sizes:o.nBlockSizes},maskBlocks:{starts:n.maskBlockStarts,sizes:n.maskBlockSizes},dnaPosition:e+4+s-4+i}}async getSequence(e,t=0,s=Number.POSITIVE_INFINITY){const i=(await this.getIndex())[e];if(!i)return;const n=await this._getSequenceRecord(i);if(t<0)throw new TypeError("regionStart cannot be less than 0");s>n.dnaSize&&(s=n.dnaSize);const a=this._getOverlappingBlocks(t,s,n.nBlocks.starts,n.nBlocks.sizes),r=this._getOverlappingBlocks(t,s,n.maskBlocks.starts,n.maskBlocks.sizes),u=g.Buffer.allocUnsafe(Math.ceil((s-t)/4)+1),d=Math.floor(t/4),{buffer:h}=await this.filehandle.read(u,0,u.length,n.dnaPosition+d);let l="";for(let c=t;c<s;c+=1){for(;r.length>0&&r[0].end<=c;)r.shift();const m=r[0]&&r[0].start<=c&&r[0].end>c;if(a[0]&&c>=a[0].start&&c<a[0].end){const B=a.shift();for(;c<B.end&&c<s;c+=1)l+=m?"n":"N";c-=1}else{const B=Math.floor(c/4)-d,b=c%4,k=h[B];l+=m?C[k][b]:p[k][b]}}return l}_getOverlappingBlocks(e,t,s,o){let i,n;for(const[r,u]of s.entries()){const d=o[r];if(e>=u+d||t<=u){if(i!==void 0){n=r;break}}else i===void 0&&(i=r)}if(i===void 0)return[];n===void 0&&(n=s.length);const a=new Array(n-i);for(let r=i;r<n;r+=1)a[r-i]={start:s[r],end:s[r]+o[r],size:o[r]};return a}}class N extends U.BaseSequenceAdapter{async initChromSizes(){const e=z.readConfObject(this.config,"chromSizesLocation");if(e.uri!=="/path/to/default.chrom.sizes"&&e.uri!==""){const s=await S.openLocation(e,this.pluginManager).readFile("utf8");return Object.fromEntries(s.split(/\n|\r\n|\r/).filter(o=>!!o.trim()).map(o=>{const[i,n]=o.split("	");return[i,+n]}))}}async setupPre(){return{twobit:new D({filehandle:S.openLocation(this.getConf("twoBitLocation"),this.pluginManager)}),chromSizesData:await this.initChromSizes()}}async setup(){return this.setupP||(this.setupP=this.setupPre().catch(e=>{throw this.setupP=void 0,e})),this.setupP}async getRefNames(){const{chromSizesData:e,twobit:t}=await this.setup();return e?Object.keys(e):t.getSequenceNames()}async getRegions(){const{chromSizesData:e,twobit:t}=await this.setup();if(e)return Object.keys(e).map(s=>({refName:s,start:0,end:e[s]}));{const s=await t.getSequenceSizes();return Object.keys(s).map(o=>({refName:o,start:0,end:s[o]}))}}getFeatures({refName:e,start:t,end:s}){return _.ObservableCreate(async o=>{const{twobit:i}=await this.setup(),n=await i.getSequenceSize(e),a=n!==void 0?Math.min(n,s):s,r=await i.getSequence(e,t,a);r&&o.next(new P({id:`${e} ${t}-${a}`,data:{refName:e,start:t,end:a,seq:r}})),o.complete()})}freeResources(){}}export{N as default};
