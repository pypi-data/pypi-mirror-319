import{I as x}from"./main-BPWpXae6.js";import{B as F}from"./index-P3rx-5SH.js";import{u as b,i as E}from"./rpcWorker-CVTx5FIM.js";import{r as A}from"./rxjs-Dgg09m9e.js";const L=new Set(["DUP","TRA","INV","CNV","DEL"]);function T(h,e,t,a){const s=h.split("	"),n=s[t?3:0],p=+s[t?4:1],o=+s[t?5:2],c=s[t?0:3],i=+s[t?1:4],g=+s[t?2:5],d=s[6],r=+s[7],l=w(s[8]),u=w(s[9]),f=s.slice(10),v=a?Object.fromEntries(a.slice(10).map((y,D)=>[y,f[D]])):f,m=L.has(f[0])?`<${f[0]}>`:void 0;return new b.SimpleFeature({...v,start:p,end:o,type:"paired_feature",refName:n,strand:l,name:d,score:r,uniqueId:e,mate:{refName:c,start:i,end:g,strand:u},...m?{ALT:[m]}:{}})}function w(h){if(h==="+")return 1;if(h==="-")return-1;if(h===".")return 0}class $ extends F.BaseFeatureDataAdapter{constructor(){super(...arguments),this.intervalTrees={}}async loadDataP(e){const t=this.pluginManager,a=this.getConf("bedpeLocation"),s=E.openLocation(a,t),n=await b.fetchAndMaybeUnzip(s,e);if(n.length>536870888)throw new Error("Data exceeds maximum string length (512MB)");const o=new TextDecoder("utf8",{fatal:!0}).decode(n).split(/\n|\r\n|\r/).filter(u=>!!u),c=[];let i=0;for(;i<o.length&&o[i].startsWith("#");i++)c.push(o[i]);const g=c.join(`
`),d={},r={};for(;i<o.length;i++){const u=o[i],f=u.split("	"),v=f[0],m=f[3];d[v]||(d[v]=[]),r[m]||(r[m]=[]),d[v].push(u),r[m].push(u)}const l=this.getConf("columnNames");return{header:g,feats1:d,feats2:r,columnNames:l}}async loadData(e={}){return this.bedpeFeatures||(this.bedpeFeatures=this.loadDataP(e).catch(t=>{throw this.bedpeFeatures=void 0,t})),this.bedpeFeatures}async getRefNames(e={}){const{feats1:t,feats2:a}=await this.loadData(e);return[...new Set([...Object.keys(t),...Object.keys(a)])]}async getHeader(e={}){const{header:t}=await this.loadData(e);return t}async getNames(){const{header:e,columnNames:t}=await this.loadData();if(t.length)return t;const s=e.split(/\n|\r\n|\r/).filter(n=>!!n).at(-1);return s!=null&&s.includes("	")?s.slice(1).split("	").map(n=>n.trim()):void 0}async loadFeatureTreeP(e){var t,a,s,n;const{feats1:p,feats2:o}=await this.loadData(),c=await this.getNames(),i=new x,g=(a=(t=p[e])===null||t===void 0?void 0:t.map((r,l)=>T(r,`${this.id}-${e}-${l}-r1`,!1,c)))!==null&&a!==void 0?a:[],d=(n=(s=o[e])===null||s===void 0?void 0:s.map((r,l)=>T(r,`${this.id}-${e}-${l}-r2`,!0,c)))!==null&&n!==void 0?n:[];for(const r of[...g,...d])i.insert([r.get("start"),r.get("end")],r);return i}async loadFeatureTree(e){return this.intervalTrees[e]||(this.intervalTrees[e]=this.loadFeatureTreeP(e).catch(t=>{throw this.intervalTrees[e]=void 0,t})),this.intervalTrees[e]}getFeatures(e,t={}){return A.ObservableCreate(async a=>{const{start:s,end:n,refName:p}=e,o=await this.loadFeatureTree(p);o==null||o.search([s,n]).forEach(c=>{a.next(c)}),a.complete()},t.stopToken)}freeResources(){}}$.capabilities=["getFeatures","getRefNames"];export{$ as default,T as featureData};
