import{I as x}from"./main-BPWpXae6.js";import{B as D,f as F}from"./util-CK2N18We.js";import{B as C}from"./index-P3rx-5SH.js";import{u as g,i as y}from"./rpcWorker-CVTx5FIM.js";import{r as E}from"./rxjs-Dgg09m9e.js";class B extends C.BaseFeatureDataAdapter{constructor(){super(...arguments),this.intervalTrees={}}async loadDataP(e={}){const t=this.pluginManager,i=this.getConf("bedLocation"),s=await g.fetchAndMaybeUnzip(y.openLocation(i,t),e);if(s.length>536870888)throw new Error("Data exceeds maximum string length (512MB)");const n=new TextDecoder("utf8",{fatal:!0}).decode(s).split(/\n|\r\n|\r/).filter(u=>!!u),o=[];let a=0;for(;a<n.length&&n[a].startsWith("#");a++)o.push(n[a]);const f=o.join(`
`),c={};for(;a<n.length;a++){const u=n[a],b=u.indexOf("	"),m=u.slice(0,b);c[m]||(c[m]=[]),c[m].push(u)}const l=this.getConf("autoSql"),h=new D({autoSql:l}),p=this.getConf("columnNames"),d=this.getConf("scoreColumn"),v=this.getConf("colRef"),w=this.getConf("colStart"),T=this.getConf("colEnd");return{header:f,features:c,parser:h,columnNames:p,scoreColumn:d,colRef:v,colStart:w,colEnd:T}}async loadData(e={}){return this.bedFeatures||(this.bedFeatures=this.loadDataP(e).catch(t=>{throw this.bedFeatures=void 0,t})),this.bedFeatures}async getRefNames(e={}){const{features:t}=await this.loadData(e);return Object.keys(t)}async getHeader(e={}){const{header:t}=await this.loadData(e);return t}async getNames(){const{header:e,columnNames:t}=await this.loadData();if(t.length)return t;const s=e.split(/\n|\r\n|\r/).filter(r=>!!r).at(-1);return s!=null&&s.includes("	")?s.slice(1).split("	").map(r=>r.trim()):void 0}async loadFeatureIntervalTreeHelper(e){const{colRef:t,colStart:i,colEnd:s,features:r,parser:n,scoreColumn:o}=await this.loadData(),a=r[e];if(!a)return;const f=await this.getNames(),c=new x;for(let l=0;l<a.length;l++){const h=a[l],p=`${this.id}-${e}-${l}`,d=new g.SimpleFeature(F({line:h,colRef:t,colStart:i,colEnd:s,scoreColumn:o,parser:n,uniqueId:p,names:f}));c.insert([d.get("start"),d.get("end")],d)}return c}async loadFeatureIntervalTree(e){return this.intervalTrees[e]||(this.intervalTrees[e]=this.loadFeatureIntervalTreeHelper(e).catch(t=>{throw this.intervalTrees[e]=void 0,t})),this.intervalTrees[e]}getFeatures(e,t={}){return E.ObservableCreate(async i=>{const{start:s,end:r,refName:n}=e,o=await this.loadFeatureIntervalTree(n);o==null||o.search([s,r]).forEach(a=>{i.next(a)}),i.complete()},t.stopToken)}freeResources(){}}B.capabilities=["getFeatures","getRefNames"];export{B as default};
