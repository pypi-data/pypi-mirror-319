import{B as k}from"./index-6rN3ss-L.js";import{r as F}from"./rxjs-DT7GVwt0.js";import{S as x}from"./simpleFeature-B-AvwKyW.js";import{u as A,ak as O,bD as R,G as $,bE as P,a7 as N,a8 as T}from"./index-Bm2SqMk3.js";import{g as B}from"./getMaximumModificationAtEachPosition-CxK0lV1P.js";function I({feature:s,bins:e,region:t}){const o=s.get("start"),c=s.get("end"),n=s.get("strand"),f=t.end-t.start;for(let a=o;a<c+1;a++){const i=a-t.start;i>=0&&i<f&&(e[i]===void 0&&(e[i]={depth:0,readsCounted:0,ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},snps:{},mods:{},nonmods:{},delskips:{},noncov:{}}),a!==c&&(e[i].depth++,e[i].readsCounted++,e[i].ref.entryDepth++,e[i].ref[n]++))}}function G(s){return E(s.type)?1:s.length}function E(s){return s==="softclip"||s==="hardclip"||s==="insertion"}function q(s,e,t,o){let c=s[t][o];c===void 0&&(c=s[t][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),c.entryDepth++,c[e]++}function D(s,e,t,o,c){let n=s[t][o];n===void 0&&(n=s[t][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),n.entryDepth++,n.probabilities.push(c),n[e]++}function L({feature:s,region:e,bins:t,skipmap:o}){var c;const n=s.get("start"),f=s.get("strand"),a=(c=s.get("mismatches"))!==null&&c!==void 0?c:[];for(const i of a){const p=n+i.start,h=G(i),u=p+h;for(let r=p;r<p+h;r++){const d=r-e.start;if(d>=0&&d<t.length){const b=t[d],{base:l,altbase:m,type:g}=i,S=E(g);g==="deletion"||g==="skip"?(q(b,f,"delskips",g),b.depth--):S?q(b,f,"noncov",g):(q(b,f,"snps",l),b.ref.entryDepth--,b.ref[f]--,b.refbase=m)}}if(i.type==="skip"){const r=s.get("tags"),d=(r==null?void 0:r.XS)||(r==null?void 0:r.TS),b=r==null?void 0:r.ts,l=d==="+"?1:d==="-"?-1:(b==="+"?1:d==="-"?-1:0)*f,m=`${p}_${u}_${l}`;o[m]===void 0&&(o[m]={feature:s,start:p,end:u,strand:f,effectiveStrand:l,score:0}),o[m].score++}}}function V({feature:s,colorBy:e,region:t,bins:o,regionSequence:c}){var n,f,a;const i=s.get("start"),p=s.get("strand"),h=s.get("end"),u=(n=e==null?void 0:e.modifications)===null||n===void 0?void 0:n.twoColor,r=(f=e==null?void 0:e.modifications)===null||f===void 0?void 0:f.isolatedModification;(a=B(s))===null||a===void 0||a.forEach(({type:d,prob:b,allProbs:l},m)=>{if(r&&d!==r)return;const g=m+i-t.start;if(g>=0&&g<o.length&&m+i<h){o[g]===void 0&&(o[g]={depth:0,readsCounted:0,refbase:c[g],snps:{},ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},mods:{},nonmods:{},delskips:{},noncov:{}});const S=1-A.sum(l),v=o[g];u&&S>A.max(l)?D(v,p,"nonmods",`nonmod_${d}`,S):D(v,p,"mods",`mod_${d}`,b)}})}function W({feature:s,region:e,bins:t,regionSequence:o}){var c;const n=s.get("start"),f=s.get("end"),a=s.get("strand"),i=s.get("seq"),p=(c=s.get("mismatches"))!==null&&c!==void 0?c:[],h=o.toLowerCase();if(i){const u=O(s.get("CIGAR")),{methBins:r,methProbs:d}=R(s,u),b=p.filter(l=>l.type==="deletion");for(let l=0;l<f-n;l++){const m=l+n,g=h[m-e.start+1],S=h[m-e.start+2];if(g==="c"&&S==="g"){const v=t[m-e.start],y=t[m-e.start+1],M=r[l],j=r[l+1],C=d[l],_=d[l+1];M&&(C===void 0||C>.5)||j&&(_===void 0||_>.5)?(v&&(D(v,a,"mods","cpg_meth",C||0),v.ref.entryDepth--,v.ref[a]--),y&&(D(y,a,"mods","cpg_meth",_||0),y.ref.entryDepth--,y.ref[a]--)):(v&&(b.some(w=>A.doesIntersect2(m,m+1,w.start+n,w.start+n+w.length))||(D(v,a,"nonmods","cpg_unmeth",1-(C||0)),v.ref.entryDepth--,v.ref[a]--)),y&&(b.some(w=>A.doesIntersect2(m+1,m+2,w.start+n,w.start+n+w.length))||(D(y,a,"nonmods","cpg_unmeth",1-(_||0)),y.ref.entryDepth--,y.ref[a]--)))}}}}async function X({fetchSequence:s,features:e,region:t,opts:o}){const{stopToken:c,colorBy:n}=o,f={},a=[],i=Math.max(0,t.start-1),p=t.start-i;let h=performance.now();for(const u of e){if(performance.now()-h>400&&($.checkStopToken(c),h=performance.now()),I({feature:u,bins:a,region:t}),(n==null?void 0:n.type)==="modifications"){const r=await s({...t,start:i,end:t.end+1})||"";V({feature:u,colorBy:n,bins:a,region:t,regionSequence:r.slice(p)})}else if((n==null?void 0:n.type)==="methylation"){const r=await s({...t,start:i,end:t.end+1})||"";W({feature:u,bins:a,region:t,regionSequence:r})}L({feature:u,skipmap:f,bins:a,region:t})}for(const u of a)u&&(u.mods=Object.fromEntries(Object.entries(u.mods).map(([r,d])=>[r,{...d,avgProbability:d.probabilities.length?A.sum(d.probabilities)/d.probabilities.length:void 0}])),u.nonmods=Object.fromEntries(Object.entries(u.nonmods).map(([r,d])=>[r,{...d,avgProbability:d.probabilities.length?A.sum(d.probabilities)/d.probabilities.length:void 0}])));return{bins:a,skipmap:f}}class U extends k.BaseFeatureDataAdapter{async configure(){var e,t;const o=this.getConf("subadapter"),c=o.sequenceAdapter,n=await((e=this.getSubAdapter)===null||e===void 0?void 0:e.call(this,o)),f=c?await((t=this.getSubAdapter)===null||t===void 0?void 0:t.call(this,c)):void 0;if(!n)throw new Error("Failed to get subadapter");return{subadapter:n.dataAdapter,sequenceAdapter:f==null?void 0:f.dataAdapter}}async fetchSequence(e){const{sequenceAdapter:t}=await this.configure();if(t)return P(e,t)}getFeatures(e,t={}){return F.ObservableCreate(async o=>{const{subadapter:c}=await this.configure(),n=await N(c.getFeatures(e,t).pipe(T())),{bins:f,skipmap:a}=await X({features:n,region:e,opts:t,fetchSequence:i=>this.fetchSequence(i)});f.forEach((i,p)=>{const h=e.start+p;o.next(new x({id:`${this.id}-${h}`,data:{score:i.depth,snpinfo:i,start:h,end:h+1,refName:e.refName}}))}),Object.entries(a).forEach(([i,p])=>{o.next(new x({id:i,data:{type:"skip",start:p.start,end:p.end,strand:p.strand,score:p.score,effectiveStrand:p.effectiveStrand}}))}),o.complete()},t.stopToken)}async getMultiRegionFeatureDensityStats(e,t){const{subadapter:o}=await this.configure();return o.getMultiRegionFeatureDensityStats(e,t)}async getRefNames(e={}){const{subadapter:t}=await this.configure();return t.getRefNames(e)}freeResources(){}}export{U as default};
