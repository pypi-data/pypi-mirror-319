class h{}class d{constructor(){this.signals=new Set,this.abortController=new AbortController}addSignal(t=new h){if(this.signal.aborted)throw new Error("cannot add a signal, already aborted!");this.signals.add(t),t.aborted?this.handleAborted(t):typeof t.addEventListener=="function"&&t.addEventListener("abort",()=>{this.handleAborted(t)})}handleAborted(t){this.signals.delete(t),this.signals.size===0&&this.abortController.abort()}get signal(){return this.abortController.signal}abort(){this.abortController.abort()}}class b{constructor(){this.callbacks=new Set}addCallback(t=()=>{}){this.callbacks.add(t),t(this.currentMessage)}callback(t){this.currentMessage=t;for(const e of this.callbacks)e(t)}}class l{constructor({fill:t,cache:e}){if(typeof t!="function")throw new TypeError("must pass a fill function");if(typeof e!="object")throw new TypeError("must pass a cache object");if(typeof e.get!="function"||typeof e.set!="function"||typeof e.delete!="function")throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");this.cache=e,this.fillCallback=t}static isAbortException(t){return t.name==="AbortError"||t.code==="ERR_ABORTED"||t.message==="AbortError: aborted"||t.message==="Error: aborted"}evict(t,e){this.cache.get(t)===e&&this.cache.delete(t)}fill(t,e,r,s){const o=new d,i=new b;i.addCallback(s);const a={aborter:o,promise:this.fillCallback(e,o.signal,n=>{i.callback(n)}),settled:!1,statusReporter:i,get aborted(){return this.aborter.signal.aborted}};a.aborter.addSignal(r),a.aborter.signal.addEventListener("abort",()=>{a.settled||this.evict(t,a)}),a.promise.then(()=>{a.settled=!0},()=>{a.settled=!0,this.evict(t,a)}).catch(n=>{throw console.error(n),n}),this.cache.set(t,a)}static checkSinglePromise(t,e){function r(){if(e!=null&&e.aborted)throw Object.assign(new Error("aborted"),{code:"ERR_ABORTED"})}return t.then(s=>(r(),s),s=>{throw r(),s})}has(t){return this.cache.has(t)}get(t,e,r,s){if(!r&&e instanceof AbortSignal)throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");const o=this.cache.get(t);return o?o.aborted&&!o.settled?(this.evict(t,o),this.get(t,e,r,s)):o.settled?o.promise:(o.aborter.addSignal(r),o.statusReporter.addCallback(s),l.checkSinglePromise(o.promise,r)):(this.fill(t,e,r,s),l.checkSinglePromise(this.cache.get(t).promise,r))}delete(t){const e=this.cache.get(t);e&&(e.settled||e.aborter.abort(),this.cache.delete(t))}clear(){const t=this.cache.keys();let e=0;for(let r=t.next();!r.done;r=t.next())this.delete(r.value),e+=1;return e}}export{l as A};
