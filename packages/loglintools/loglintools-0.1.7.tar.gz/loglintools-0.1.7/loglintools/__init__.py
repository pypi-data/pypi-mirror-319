def help():
    print(''' q1() -  код, q1_th() - теория
    q1 - Наивное умножение матрицы на вектор и умножение матриц
    q2 - Иерархия памяти, план кеша и LRU, промахи в обращении к кешу
    q3 - Алгоритм Штрассена
    q4 - Собственные векторы, собственные значения (важность, Google PageRank)
    q5 - Разложение Шура и QR-алгоритм
    q6 - Степенной метод
    q7 - Круги Гершгорина
    q8 - Разложение Шура, теорема Шура
    q9 - Нормальные матрицы, эрмитовы матрицы, унитарно диагонализуемые матрицы, верхне-гессенбергова форма матриц
    q10 - Спектр и псевдоспектр
    q11 - Неявный QR алгоритм (со сдвигами)
    q12 - Алгоритм на основе стратегии "разделяй и властвуй"
    q13 - Разреженные матрицы, форматы хранения разреженных матриц, прямые методы для решения больших разреженных систем
    q14 - Обыкновенные дифференциальные уравнения, задача Коши
    q15 - Локальная, глобальная ошибки
    q16 - Метод центральной разности
    q17 - Метод Эйлера
    q18 - Метод предиктора-корректора
    q19 - Метод Рунге-Кутты 1-4 порядков
    q20 - Методы Адамса-Мултона, методы Адамса-Бэшфорта
    q21 - Метод Милна
    q22 - Согласованность, устойчивость, сходимость, условия устойчивости
    q23 - Моделирование волны с использованием математических инструментов (амплитуда, период, длина волны, частота, Герц, дискретизация, частота дискретизации, фаза, угловая частота)
    q24 - Дискретное преобразование Фурье, обратное дискретное преобразование Фурье их ограничения, симметрии в дискретном преобразовании Фурье
    q25 - Быстрое преобразование Фурье, его принципы, фильтрация сигнала с использованием быстрого преобразования Фурье
    q26 - Операции свёртки, связь с быстрым преобразованием Фурье, операции дискретной свёртки
    q27 - Дискретная свёртка и Тёплицевы матрицы (Ганкелевы матрицы)
    q28 - Циркулянтные матрицы. Матрицы Фурье.
    q29 - Быстрый матвек с циркулянтом''')
    
def q9_th():
    print('''**Определение.** Нормальная матрица — это квадратная матрица $A$, которая коммутирует со своей эрмитово-сопряжённой матрицей $
A^*$, то есть матрица $A$ нормальная, если 
$$ AA^* = A^* A. $$

**Нормальные матрицы**

**Теорема**: $A$ – **нормальная матрица**, тогда и только тогда, когда существует такая унитарная матрица $U$, что $$A = U \Lambda U^*$$, где $\Lambda$-диагональная матрица, содержащая собственные значения матрицы $A$ на диагонали.

**Важное следствие**
Любая нормальная матрица – **унитарно диагонализуема**. Это означает, что она может быть приведена к диагональному виду с помощью унитарной матрицы $U$. Другими словами, каждая нормальная матрица имеет ортогональный базис из собственных векторов.

-----
**Эрмитова** (или самосопряжённая) ма́трица — квадратная матрица, элементы которой являются комплексными числами, и которая, будучи транспонирована, равна комплексно сопряжённой:
$A^T = \overline{A}$. То есть для любого столбца $i$ и строки $j$ справедливо равенство $a_{ij} = \overline{a_{ji}}$ где $\overline{a}$— комплексно сопряжённое число к $a$, или $A = (\overline{A})^T = A^*$,
где * — эрмитово сопряжение. То есть эрмитова матрица — это квадратная матрица, которая равна своей эрмитово-сопряжённой матрице.

**Эрмитово - сопряженная матрица(сопряженно-транспонированная)** - матрица $A^*$ с комплексными элементами, полученная из исходной матрицы $A$ транспонированием и заменой каждого эелемента комплексно-сопряженным ему.

Пример:

$$\begin{equation*}
A =
\begin{pmatrix}
3 & 2+i\\
2 - i & 1\\
\end{pmatrix}
\end{equation*}$$

$$\begin{equation*}
A^* =
\begin{pmatrix}
3 & 2+2i\\
2-i & 1
\\
\end{pmatrix}
\end{equation*}$$

-----
**Унитарно - диагонализуемые матрицы**: матрица $A$ унитарно - диагонализуемая, если сущетвует унитарная матрица $U$ такая, что $U^*AU$ - диагональная матрица.

(Унитарная матрица - квадратная матрица с комплексными элементами, результат умножения которой на эрмитово - сопряженную равен единичной матрице $U^*U = UU^* = I$. Иначе говоря, матрица унитарна тогда и т.т., когда существует обратная к ней матрица, удовлетворяющая условию $U^{-1} = U^*$)

----
**Верхне-гессенбергова форма матрицы**
Матрица $A$ имеет верхне-гессенбергову форму, если $$a_{ij} = 0, при \space i\geq j+2.$$

$$H =
\begin{bmatrix}
* & * & * & * & * \\
* & * & * & * & * \\
0 & * & * & * & * \\  
0 & 0 & * & * & * \\
0 & 0 & 0 & * & *  
\end{bmatrix}
$$


**Приведение произвольной матрицы к верхне-гессенберговой форме**

С помощью отражений Хаусхолдера можно привести любую матрицу к верхне-гессенберговой форме:
$$U^*AU = H$$

* Единственное отличие от вычисления разложения Шура заключается в занулении последних $n-2, n-3,...$
 элементов в первом, втором и так далее столбцах

* Сложность такого приведения $O(n^3)$ операций

* Если матрица приведена к верхне-гессенберговой форме, то одна итерация QR алгоритма имеет сложность
$O(n^2)$ операций (например, используя вращения Гивенса)

* Также верхне-гессенбергова форма матрицы сохраняется после выполнения одной итерации QR алгоритма.''')
    
    
def q9():
    print('''
    #весь код
from collections import OrderedDict
import scipy.linalg
# Пример нормальной матрицы
A = np.array([[4, 1], [1, 4]])
# Проверка нормальности
is_normal = np.allclose(A.T.conj() @ A, A @ A.T.conj())
print("Матрица нормальна:", is_normal)


# Пример эрмитовой матрицы
B = np.array([[3, 2+1j], [2-1j, 1]])
# Проверка эрмитовости
is_hermitian = np.allclose(B, B.T.conj())
print("Матрица эрмитова:", is_hermitian)


# Проверка унитарной диагонализуемости
def is_unitarily_diagonalizable(A, tol=1e-10):
    A_star = A.conj().T  # Эрмитово-сопряжённая матрица A
    norm_diff = np.linalg.norm(A @ A_star - A_star @ A)  # Норма разности A A* и A* A
    return norm_diff < tol
# Пример использования
A = np.array([[1, 0], [0, 1]], dtype=complex)  
print(is_unitarily_diagonalizable(A))  # Вывод: True или False


# Пример приведения к верхне-гессенберговой форме
D = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# Use scipy.linalg.hessenberg instead of np.linalg.hessenberg
H = scipy.linalg.hessenberg(D) # scipy.linalg contains the hessenberg function
print("Верхне-гессенбергова форма:")
H''')
    
    
    
    
def q8():
    print('''def gram_schmidt(A):
    """
    QR разложение
    """
    # Инициализация матриц Q и R
    m, n = A.shape
    Q = np.zeros((m, n))
    R = np.zeros((n, n))

    for j in range(n):
        v = A[:, j]

        # Ортогонализация текущего вектора
        for i in range(j):
            R[i, j] = Q[:, i] @ A[:, j]
            v = v - R[i, j] * Q[:, i]
        # Нормализация вектора
        R[j, j] = sum(i**2 for i in v) ** 0.5
        Q[:, j] = [i / R[j, j] for i in v]

    return Q, R

def schur_decomposition(A, accuracy=0.001):
    """
    Реализация QR-алгоритма для разложения Шура
    """
    n = A.shape[0]
    U = np.eye(n)  # Инициализация единичной матрицы U

    while np.triu(A, 1).max() > accuracy:
        # Выполняем QR-разложение
        Q, R = gram_schmidt(A)
        A = R @ Q  # Обновление A
        U = U @ Q  # Накопление произведений Q для получения U

    T = A  # После завершения итераций A становится почти треугольной
    return U, T

A = np.array([[1, 2, 3],
       [2, 3, 4],
       [3, 4, 4]])
U, T = schur_decomposition(A)

print("Матрица U (унитарная):")
print(U)

print("Матрица T (верхнетреугольная):")
print(T)

# Проверка
print("Проверка разложения Шура (A ≈ U @ T @ U^*):")
print(np.allclose(A, U @ T @ U.T.conj()))''')
    
def q8_th():
    print('''$\LargeТеорема\spaceШура$


**Теорема:** Пусть матрица $A \in \mathbb{C}^{n \times n}$. ТОгда существует матрица $U$ унитарная и матрица $T$ верхнетреугольная такие, что $$T = U^*AU$$

$A = UTU^* - $разложение Шура

**Набросок доказательства**.
1. Каждая матрица имеет как минимум один ненулевой собственный вектор (для корня характеристического многочлена матрица $(A-\lambda I)$ вырождена и имеет нетривиальное ядро). Пусть

$$Av_1 = \lambda_1 v_1, \quad \Vert v_1 \Vert_2 = 1.$$

2. Пусть $U_1 = [v_1,v_2,\dots,v_n]$, где $v_2,\dots, v_n$ любые векторы ортогональные $v_1$. Тогда
  
  $$
      U^*_1 A U_1 = \begin{pmatrix}
      \lambda_1 & *  \\
      0 & A_2
      \end{pmatrix},
  $$
  
  где $A_2$ матрица размера $(n-1) \times (n-1)$. Это называется **блочнотреугольной формой**. Теперь мы можем проделать аналогичную процедуру для матрицы $A_2$ и так далее.  
  
  
**Замечание**: Поскольку в доказательстве необходимы собственные векторы, оно не является практичным алгоритмом.

**Приложение теоремы Шура**

Важное приложение теоремы Шура связано с так называемыми **нормальными матрицами**.  

**Определение.** Матрица $A$ называется **нормальной матрицей**, если  

$$ AA^* = A^* A. $$

**Q:** Какие примеры нормальных матриц вы можете привести?

Примеры: эрмитовы матрицы, унитарные матрицы.

$\LargeРазложение\spaceШура$
- Нужно найти унитарную матрицу $U$ и верхнетреугольную матрицу $T$, такие что для данной матрице $A$ выполнено

$$ A = U T U^*. $$

- <font color='red'> **Не путайте** QR алгоритм и QR разложение! </font>

- QR разложение – это представление матрицы в виде произведения двух матриц, а QR алгоритм использует QR разложение для вычисления разложения Шура.

Зачем нужно разложение Шура?

- Численные методы:
Разложение Шура часто используется как основа для численного поиска собственных значений. В частности, QR-алгоритм сводится к нахождению разложения Шура.

- Контроль собственных значений:
Так как разложение Шура даёт матрицу $T$, где на диагонали стоят собственные значения, оно полезно для анализа спектра матрицы.

**Путь к QR алгоритму**

Рассмотрим выражение

$$A = Q T Q^*,$$

и перепишем его в виде

$$
   Q T = A Q.
$$

Слева замечаем QR разложение матрицы $AQ$.

Используем его чтобы записать одну итерацию метода неподвижной точки для разложения Шура.

**Вывод QR алгоритма из уравнения неподвижной точки**

Запишем следующий итерационный процесс

$$
    Q_{k+1} R_{k+1} = A Q_k, \quad Q_{k+1}^* A = R_{k+1} Q^*_k
$$

Введём новую матрицу

$$A_k = Q^* _k A Q_k = Q^*_k Q_{k+1} R_{k+1} = \widehat{Q}_k R_{k+1}$$

тогда аппроксимация для $A_{k+1}$ имеет вид

$$A_{k+1} = Q^*_{k+1} A Q_{k+1} = ( Q_{k+1}^* A = R_{k+1} Q^*_k)  = R_{k+1} \widehat{Q}_k.$$

Итак, мы получили стандартную форму записи QR алгоритма.

Финальные формулы обычно записывают в **QRRQ**-форме:

1. Инициализируем $A_0 = A$.
2. Вычислим QR разложение матрицы $A_k$: $A_k = Q_k R_k$.
3. Обновим аппроксимацию $A_{k+1} = R_k Q_k$.

Продолжаем итерации пока $A_k$ не станет достаточно треугольной (например, норма подматрицы под главной диагональю не станет достаточно мала).

**Что известно о сходимости и сложности**

**Утверждение**

Матрицы $A_k$ унитарно подобны матрице $A$

$$A_k = Q^*_{k-1} A_{k-1} Q_{k-1} = (Q_{k-1} \ldots Q_1)^* A (Q_{k-1} \ldots Q_1)$$

а произведение унитарных матриц – унитарная матрица.

Сложность одной итерации $\mathscr{O}(n^3)$, если используется QR разложение для общего случая.

Мы ожидаем, что $A_k$ будет **очень близка к треугольной матрице** для достаточно большого $k$.''')
    
    
def q7():
    print('''n = 3
fig, ax = plt.subplots(1, 1)
a = np.array([[5, 1, 1], [1, 0, 0.5], [2, 0, 10]])
a = a + 2 * np.random.randn(n, n)
xg = np.diag(a).real
yg = np.diag(a).imag
rg = np.zeros(n)
ev = np.linalg.eigvals(a)
for i in range(n):
    rg[i] = np.sum(np.abs(a[i, :])) - np.abs(a[i, i])
    crc = plt.Circle((xg[i], yg[i]), radius=rg[i], fill=False)
    ax.add_patch(crc)
plt.scatter(ev.real, ev.imag, color='r', label="Eigenvalues")
plt.axis('equal')
plt.legend()
ax.set_title('Eigenvalues and Gershgorin circles')
fig.tight_layout()''')
    
def q7_th():
    print('''$\textbf{Круги Гершгорина}$

Есть интересная теорема, которая часто помогает локализовать собственные значения.
Она называется $\it\text{теоремой Гершгорина}$.

Она утверждает, что все собственные значения $\lambda_i, i = \overline{1,n}$ находятся внутри объединения кругов Гершгорина $C_i$, где $C_i$– окружность на комплексной плоскости с центром в $a_{ii}$ и радиусом $r_i = \sum_{j \neq i} |a_{ij}|$


Более того, если круги не пересекаются, то они содержат по одному собственному значению внутри каждого круга.


**Доказательство**(на всякий случай)

Сначала покажем, что если матрица $A$ обладает строгим диагональным преобладанием, то есть $$|a_{ii}| > \sum_{j \neq i} |a_{ij}|,$$

тогда такая матрица невырождена.


Разделим диагональную и недиагональную часть и получим $$A = D+S = D(I+D^{-1}S),$$

где $||D^{-1}S||_1 < 1$. Поэтому, в силу теоремы о ряде Неймана, матрица $I + D^{-1}S$ обратима и, следовательно, матрица $A$ также обратима.

Теперь докажем утверждение теоремы от противного:

* если любое из собственных чисел лежит вне всех кругов, то матрица $(A - \lambda I)$ обладает свойством строгого диагонального преобладания
* поэтому она обратима
* это означает, что если $(A - \lambda I)x = 0$, то $x = 0$.''')
    
    
def q6_th():
    print('''$\it\textbf{Степенной метод}$

* Часто в вычислительной практике требуется найти не весь спектр, а только некоторую его часть, например самое большое или самое маленькое собственые значения.
* Также отметим, что для Эрмитовых матриц $(A = A^*)$
 собственные значения всегда действительны.

* Степенной метод – простейший метод вычисления $\it\text{максимального по модулю}$ собственного значения. Это также первый пример итерационного метода и Крыловского метода.

**Что необходимо помнить о степенном методе**

* Степенной метод даёт оценку для максимального по модулю собственного числа или спектрального радиуса матрицы
* Одна итерация требует одного умножения матрицы на вектор. Если можно умножить вектор на матрицу зa $O(n)$(например, она разреженная), тогда степенной метод можно использовать для больших $n$
* Сходимость может быть медленной
* Для грубой оценки максимального по модулю собственного значения и соответствующего вектора достаточно небольшого числа итераций

**Степенной метод: вид**

Задача на собственые значения $$Ax = \lambda x, ||x||_2 = 1 \text{(для устройчивости)}$$

может быть записана как итерации с неподвижной точкой, которые называются $\it\text{степенным методом}$ и дают максимальное по модулю собственное значение матрицы $A$.

Степенной метод имеет вид
$$x_{k+1} = Ax_k, x_{k+1} := \frac{x_{k+1}}{||x_{k+1}||_2}$$
и $x_{k+1} → v_1$, где $Av_1 = \lambda_1v_1 $ и $\lambda_1$ максимальное по модулю собственное значение, и $v_1$ – соответствующий собственный вектор.

На $(k+1)$-ой итерации приближение для $\lambda_1$ может быть найдено следующим образом $$\lambda^{k+1} = (Ax_{k+1}, x_{k+1})$$

Заметим, что $\lambda^{(k+1)}$ не требуется для $(k+2)$-ой итерации, но может быть полезно для оценки ошибки на каждой итерации: $||Ax_{k+1} - \lambda^{(k+1)}x_{k+1}||$
.

Метод сходится со скоростью геометричекой прогрессии, с константой $q = |\frac{\lambda_2}{\lambda_1}| < 1$, где $\lambda_1 > \lambda_2 \geq ... \geq \lambda_n$
. Это означает, что сходимость может быть сколь угодно медленной при близких значениях у $\lambda_1$ и $\lambda_2$.

**Общая сложность степенного метода**

Пусть $k$ — число итераций, необходимых для достижения заданной точности $ε$. Тогда общая сложность метода будет равна:
$O(k⋅n^2)$''')
    
def q6():
    print('''def power_method(A, x0, max_iter, eps):
    x = x0.copy()
    conv = [x]
    for i in range(max_iter):
        x = A @ x
        x = x / np.linalg.norm(x)
        conv.append(x)
        eigval = x @ (A @ x)
        res = A @ x - eigval * x
        if np.linalg.norm(res) < eps:
            break
    return x, eigval, conv

n = 10
A = np.random.randn(n, n)

#в случае нессиметричной матрицы значения могут быть комплексными
true_eigvals, true_eigvec = np.linalg.eig(A)#подсчет через библиотечные методы
print(true_eigvals)
print(max(true_eigvals))

x0 = np.random.randn(n)
max_eigvec, max_eigval, conv = power_method(A, x0, 50, 1e-20)
print(max_eigval)''')

def q5():
    print('''# QR-разложение с использованием Грама-Шмидта
def gram_schmidt(A):
    """
    QR разложение
    """
    # Инициализация матриц Q и R
    m, n = A.shape
    Q = np.zeros((m, n))
    R = np.zeros((n, n))

    for j in range(n):
        v = A[:, j]

        # Ортогонализация текущего вектора
        for i in range(j):
            R[i, j] = Q[:, i] @ A[:, j]
            v = v - R[i, j] * Q[:, i]
        # Нормализация вектора
        R[j, j] = sum(i**2 for i in v) ** 0.5
        Q[:, j] = [i / R[j, j] for i in v]

    return Q, R
A = np.array([[1, 2, 3],
       [2, 3, 4],
       [3, 4, 4]])
Q, R = gram_schmidt(A)


#qr - алгоритм
def QR_method(A, accuracy=0.001):
    Q_final = np.eye(A.shape[0])  # Инициализация единичной матрицы
    Q_list = []

    while np.triu(A, 1).max() > accuracy:
        Q, R = gram_schmidt(A)
        Q_list.append(Q)
        A = R @ Q
        Q_final = Q_final @ Q  # Постепенное обновление итоговой матрицы Q

    return A, np.diag(A), [Q_final[:, i] for i in range(Q_final.shape[1])]

A, nums, vecs = QR_method(A)

#qr - алгоритм библиотечный
def qr_algorithm(A, iter_ = 100):
    n = A.shape[0]
    Q_accumulated = np.eye(n)

    for _ in range(iter_):
        # QR-разложение
        Q, R = np.linalg.qr(A)
        # Обновление A
        A = R @ Q
        # Накопление Q
        Q_accumulated = Q_accumulated @ Q

    eigenvalues = np.diag(A)
    eigenvectors = Q_accumulated
    return A, eigenvalues, eigenvectors

A, eigenvalues, eigenvectors = qr_algorithm(A)''')
    
def q5_th():
    print('''$\LargeРазложение\spaceШура$
- Нужно найти унитарную матрицу $U$ и верхнетреугольную матрицу $T$, такие что для данной матрице $A$ выполнено

$$ A = U T U^*. $$
  * Собственные значения матрицы $A$ находятся на диагонали матрицы $T$.

 **Не путайте** QR алгоритм и QR разложение!

- QR разложение – это представление матрицы в виде произведения двух матриц, а QR алгоритм использует QR разложение для вычисления разложения Шура.

**Путь к QR алгоритму**

Рассмотрим выражение

$$A = Q T Q^*,$$

и перепишем его в виде

$$
   Q T = A Q.
$$

Слева замечаем QR разложение матрицы $AQ$.

Используем его чтобы записать одну итерацию метода неподвижной точки для разложения Шура.

**Вывод QR алгоритма из уравнения неподвижной точки**

Запишем следующий итерационный процесс

$$
    Q_{k+1} R_{k+1} = A Q_k, \quad Q_{k+1}^* A = R_{k+1} Q^*_k
$$

Введём новую матрицу

$$A_k = Q^* _k A Q_k = Q^*_k Q_{k+1} R_{k+1} = \widehat{Q}_k R_{k+1}$$

тогда аппроксимация для $A_{k+1}$ имеет вид

$$A_{k+1} = Q^*_{k+1} A Q_{k+1} = ( Q_{k+1}^* A = R_{k+1} Q^*_k)  = R_{k+1} \widehat{Q}_k.$$

Итак, мы получили стандартную форму записи QR алгоритма.

Финальные формулы обычно записывают в **QRRQ**-форме:

1. Инициализируем $A_0 = A$.
2. Вычислим QR разложение матрицы $A_k$: $A_k = Q_k R_k$.
3. Обновим аппроксимацию $A_{k+1} = R_k Q_k$.

Продолжаем итерации пока $A_k$ не станет достаточно треугольной (например, норма подматрицы под главной диагональю не станет достаточно мала).

**Что известно о сходимости и сложности**

**Утверждение**

Матрицы $A_k$ унитарно подобны матрице $A$

$$A_k = Q^*_{k-1} A_{k-1} Q_{k-1} = (Q_{k-1} \ldots Q_1)^* A (Q_{k-1} \ldots Q_1)$$

а произведение унитарных матриц – унитарная матрица.

Сложность одной итерации $\mathscr{O}(n^3)$, если используется QR разложение для общего случая.

Мы ожидаем, что $A_k$ будет **очень близка к треугольной матрице** для достаточно большого $k$.

**Сходимость и сложность QR алгоритма**

- QR алгоритм сходится от первого диагонального элемента к последнему.

- По крайней мере 2-3 итерации необходимо для определения каждого диагонального элемента матрицы $T$.

- Каждый шаг состоит в вычислении QR разложения и одного произведения двух матриц, в результате имеем сложность $\mathscr{O}(n^3)$.

**Q**: означает ли это итоговую сложность $\mathscr{O}(n^4)$?

**A**: к счастью, нет!

- Мы можем ускорить QR алгоритм, используя сдвиги, поскольку матрица $A_k - \lambda I$ имеет те же векторы Шура (столбцы матрицы $U$).''')
    
def q4_th():
    print('''Что такое собственный вектор?

**Определение**. Вектор $x \neq 0$ называется собственным для квадратной матрицы A, если найдётся такое число $\lambda$, что $$Ax = \lambda x$$


Число $\lambda$ называется $\it{собственным}$ значением.

Так как матрица $A - \lambda I$ должна иметь нетривиальное ядро (что такое ядро?), собственные значения являются корнями характеристического полинома $$det(A - \lambda I) = 0$$

**Важность**

$\it\text{Собственные значения – это частоты выбраций}$

Обычно вычисление собственных значений и собственных векторов необходимо для изучения:

* вибраций в механических структурах
* снижения сложности моделей сложных систем


**Google PageRank**

Одна из самых известных задач, сводящихся к вычислению собственного вектора, – это задача вычисления Google PageRank.

* Задача состои в ранжировании веб-страницы: какие из них являются важными, а какие нет
* В интернете страницы ссылаются друг на друга
* PageRank определяется рекурсивно.

  Обозначим $p_i$ за важность $i$-ой страницы. Тогда определим эту важность как усреднённую важность всех страниц, которые ссылаются на данную страницу. Это определение приводит к следующей линейной системе $$p_i = \sum_{j \in N(i)}\frac{p_j}{L(j)},$$



  где

  * $L(j)$ – число исходящих ссылок с $j$-ой страницы,
  * $N(i)$– число соседей $i$-ой страницы.

  Это может быть записано следующим образом $$p = Gp,   G_{ij} = \frac{1}{L(j)}$$

  

  или как задача на собственные значения $$Gp = 1p$$


  то есть мы уже знаем, что у матрицы $G$ есть собственное значение равное $1$. Заметим, что $G$ – левостохастичная матрица, то есть сумма в каждом столбце равна $1$.''')
    
    
def q3_th():
    print('''Алгоритм Штрассена — это эффективный алгоритм умножения квадратных матриц, снижающий сложность с $O(n^3)$ до $O(n^{log_27}) \approx O(n^{2.81})$. В стандартном методе умножения матриц используется 8 умножений подматриц, что приводит к сложности  $O(n^3)$. Алгоритм Штрассена заменяет 8 умножений на 7,поэтому сложность становится равной  $O(n^{log_27})$

Метод Штрассена становится быстрее наивного алгоритма, если

$$2n^3>7n^{log_27},$$ $$n>667$$''')
    
def q3():
    print('''def strassen_multiply(A, B):
        n = A.shape[0]

        # Базовый случай: умножение 1x1 матриц -> база рекурсии
        if n == 1:
            return A * B

        # Разделение матриц на блоки
        mid = n // 2
        A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:]
        B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:]

        # Вычисление 7 промежуточных матриц
        M1 = strassen_multiply(A11 + A22, B11 + B22)
        M2 = strassen_multiply(A21 + A22, B11)
        M3 = strassen_multiply(A11, B12 - B22)
        M4 = strassen_multiply(A22, B21 - B11)
        M5 = strassen_multiply(A11 + A12, B22)
        M6 = strassen_multiply(A21 - A11,B11 + B12)
        M7 = strassen_multiply(A12 - A22, B21 + B22)

        # Сборка результирующей матрицы
        C11 = M1 +M4 - M5 + M7
        C12 = M3 + M5
        C21 = M2 + M4
        C22 = M1 + M3 - M2 + M6

        # Объединение блоков в одну матрицу
        C = np.vstack((np.hstack((C11, C12)), np.hstack((C21, C22))))
        return C

    A = np.array([[1, 2.4, 3, 4], [5, 6.8, 7, 8], [9.5, 10, 11, 12.7], [13.5, 14, 15, 16]])
    B = np.array([[1, 15, 14, 13], [1, 11.4, 10, 9], [8, 72, 6, 5], [4, 3.5, 2, 1]])
    C = strassen_multiply(A, B)
    print("Результат умножения матриц:")
    print(C)
    ''')

         

def q1_th():
    print('''**Определение**. Произведение матрицы $A$ размера $n×k$ и матрицы $B$ размера $k×m$– это матрица $C$ размера $n×m$ такая что её элементы записываются как $$c_{ij}=∑_{s=1}^{k}a_{is}b_{sj},i=1,…,n,j=1,…,m$$

Для $m=k=n$ сложность наивного алгоритма составляет $2n^3−n^2=O(n^3)$:

Почему рукописная(наивная) реализация такая медленная?

1) не используется параллелилизм

2) не используются преимущества быстрой памяти, в целом архитектуры памяти

**Определение**. Произведение матрицы $A$ размера $n×k$ и вектора $B$ размера $1×k$– это вектор $C$ длины $n$, такой, что его элементы записываются как $$c_{i}=∑_{j=1}^{k}a_{ij}b_{j},i=1,…,n$$''')
    
def q1():
    print('''def matmul(a, b): #наивное перемножение матриц
        n = a.shape[0]
        k = a.shape[1]
        m = b.shape[1]
        c = np.zeros((n, m))
        for i in range(n):
            for j in range(m):
                for s in range(k):
                    c[i, j] += a[i, s] * b[s, j]
        return c


    def mat_vec_mult(matrix, vector): # Наивное перемножение матрицы на вектор
        num_rows = len(matrix)
        num_cols = len(matrix[0])
        result = [0] * num_rows

        for i in range(num_rows):
            for j in range(num_cols):
                result[i] += matrix[i,j] * vector[j]

        return result


    mat_vec_mult(np.array([[1,2],[2,3],[4,7]]),[4,5]), matmul(np.array([[1,2],[2,3]]),np.array([[1,2],[2,3]]))''')
    
    
def q2():
    print('''
    from collections import OrderedDict

    class LRUCache:
        def __init__(self, capacity: int):
            """
            Инициализация кэша с заданной ёмкостью.
            """
            self.cache = OrderedDict()
            self.capacity = capacity

        def get(self, key: int) -> int:
            """
            Получить значение из кэша по ключу.
            Если ключа нет, вернуть -1.
            """
            if key in self.cache:
                # Переместить используемый элемент в конец (считается недавно использованным)
                self.cache.move_to_end(key)
                return self.cache[key]
            return -1

        def put(self, key: int, value: int):
            """
            Добавить элемент в кэш. Если кэш заполнен, удалить наименее используемый элемент.
            """
            if key in self.cache:
                # Если ключ уже существует, обновить значение и переместить в конец
                self.cache.move_to_end(key)
            self.cache[key] = value
            if len(self.cache) > self.capacity:
                # Удалить первый (наименее недавно использованный) элемент
                self.cache.popitem(last=False)

    # Пример использования
    cache = LRUCache(2)

    # Операции
    cache.put(1, 1)  # Кэш: {1: 1}
    cache.put(2, 2)  # Кэш: {1: 1, 2: 2}
    print(cache.get(1))  # Вернет 1, Кэш: {2: 2, 1: 1}
    cache.put(3, 3)  # Кэш: {1: 1, 3: 3} (удален 2)
    print(cache.get(2))  # Вернет -1 (так как 2 удален)
    cache.put(4, 4)  # Кэш: {3: 3, 4: 4} (удален 1)
    print(cache.get(1))  # Вернет -1
    print(cache.get(3))  # Вернет 3, Кэш: {4: 4, 3: 3}
    print(cache.get(4))  # Вернет 4, Кэш: {3: 3, 4: 4}''')


def q2_th():
    print('''Иерархия памяти — это способ организации различных типов памяти компьютера так, чтобы ускорить работу процессора. Память делится на уровни по скорости доступа и размеру: быстрые уровни маленькие и дорогие, а медленные — большие и дешевые.

**Уровни иерархии:**

**1. Регистр процессора:**

- Самый верхний уровень.
- Находится внутри процессора.
- Скорость: сверхбыстрая, доступ за один такт процессора.
- Объем: крошечный (несколько килобайт).
- Стоимость: очень высокая.

**2. Кэш-память процессора (CPU Cache):**
Состоит из 3 уровней:
- L1 (уровень 1):
  - Самая быстрая и дорогая кэш-память.
  - Очень маленький объем (16–128 КБ).
-L2 (уровень 2):
  - Чуть медленнее, но больше (256 КБ – несколько МБ).
- L3 (уровень 3):
  - Медленнее L1 и L2, общий для всех ядер процессора.
  - Объем до десятков МБ.
- Назначение: хранение данных, часто используемых процессором, для минимизации задержек.

**3. Оперативная память (RAM):**

- Скорость: медленнее кэша, но быстрее SSD.
- Объем: значительно больше (гигабайты).
- Стоимость: относительно дорогая.
- Используется для хранения данных и инструкций программ во время выполнения.

**4. Твердотельные накопители (Solid State Drives):**

- Включают неэнергозависимую флэш-память.
- Скорость: медленнее RAM, но быстрее, чем механические жесткие диски.
- Объем: большие (терабайты).
- Стоимость: средняя.
- Используются для долговременного хранения данных.
- Механические жесткие диски (HDD):

**5. Самый нижний уровень.**
- Скорость: самая медленная.
- Объем: очень большой (терабайты).
- Стоимость: самая низкая.
- Используются для долговременного хранения данных, к которым доступ требуется редко.


**План кеша (Cache Planning)**
Кэш работает как промежуточный буфер между процессором и оперативной памятью для ускорения доступа к часто используемым данным. Процесс организации кэша включает следующие аспекты:

**1. Кэш-линии:**

- Данные организуются в блоки фиксированного размера (обычно 32–128 байт).
- При кэшировании загружается вся кэш-линия, а не только отдельный байт.

**2. Ассоциативность кэша:**

- Определяет, как строки памяти сопоставляются с блоками в кэше.
  - Прямое отображение: каждая строка памяти может храниться только в определенном блоке кэша.
  - Полностью ассоциативный кэш: каждая строка памяти может находиться в любом блоке кэша.
  - N-канальный ассоциативный кэш: компромисс между двумя подходами.
  
**3. Алгоритмы замещения:**

- Когда кэш заполняется, нужно освободить место для новых данных.
- Пример: LRU (Least Recently Used), FIFO (First In, First Out), Random Replacement.


**Алгоритм LRU (Least Recently Used)**
LRU — один из самых распространенных алгоритмов замещения данных в кэше.

**Принцип работы:**

- При кэш-промахе (отсутствие данных в кэше) заменяется тот блок данных, который дольше всех не использовался.
- Данные, к которым был последний доступ, считаются самыми "свежими".

**Реализация:**

- Используется структура данных (обычно связанный список или стек).

**При каждом доступе к данным:**

- Если данные уже в кэше — переместить их в начало списка.
- Если данных нет в кэше:
- Если кэш заполнен, удалить последний элемент списка (самый "старый").
- Добавить новые данные в начало списка.

**Плюсы:**

- Эффективно для данных с локальностью запросов.
- Снижает частоту промахов.

**Минусы:**

Увеличенные затраты на обновление структуры (в худшем случае $\mathscr{O}(n)$)''')
