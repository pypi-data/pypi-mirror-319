

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>snpio.popgenstats.pop_gen_statistics &mdash; SNPio 1.1.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=859da57e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=00f267c6"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SNPio
              <img src="../../../_static/snpio_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example_script.html">Example script</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">snpio</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SNPio</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">snpio.popgenstats.pop_gen_statistics</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for snpio.popgenstats.pop_gen_statistics</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Logger</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">kneed</span> <span class="kn">import</span> <span class="n">KneeLocator</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.multitest</span> <span class="kn">import</span> <span class="n">multipletests</span>

<span class="kn">from</span> <span class="nn">snpio</span> <span class="kn">import</span> <span class="n">GenotypeEncoder</span><span class="p">,</span> <span class="n">Plotting</span>
<span class="kn">from</span> <span class="nn">snpio.popgenstats.amova</span> <span class="kn">import</span> <span class="n">AMOVA</span>
<span class="kn">from</span> <span class="nn">snpio.popgenstats.d_statistics</span> <span class="kn">import</span> <span class="n">DStatistics</span>
<span class="kn">from</span> <span class="nn">snpio.utils.logging</span> <span class="kn">import</span> <span class="n">LoggerManager</span>


<div class="viewcode-block" id="PopGenStatistics">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics">[docs]</a>
<span class="k">class</span> <span class="nc">PopGenStatistics</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for calculating population genetics statistics from SNP data.</span>

<span class="sd">    This class provides methods for calculating population genetics statistics from SNP data. It is designed to work with GenotypeData objects. The PopGenStatistics class can calculate Patterson&#39;s D-statistic, partitioned D-statistic, D-foil statistic, summary statistics, and perform PCA and DAPC dimensionality reduction analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">genotype_data</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the PopGenStatistics object.</span>

<span class="sd">        This class provides methods for calculating population genetics statistics from SNP data. It is designed to work with GenotypeData objects. The PopGenStatistics class can calculate Patterson&#39;s D-statistic, partitioned D-statistic, D-foil statistic, summary statistics, and perform PCA and DAPC dimensionality reduction analysis.</span>

<span class="sd">        Args:</span>
<span class="sd">            genotype_data (GenotypeData): GenotypeData object containing SNP data and metadata.</span>
<span class="sd">            verbose (bool): Whether to display verbose output. Defaults to False.</span>
<span class="sd">            debug (bool): Whether to display debug output. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">genotype_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">genotype_data</span><span class="o">.</span><span class="n">snp_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">popmap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">genotype_data</span><span class="o">.</span><span class="n">popmap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">genotype_data</span><span class="o">.</span><span class="n">populations</span>

        <span class="n">plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">genotype_data</span><span class="o">.</span><span class="n">plot_kwargs</span>
        <span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;debug&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># Initialize plotting and dstats objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">Plotting</span><span class="p">(</span><span class="n">genotype_data</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>

        <span class="c1"># Initialize logger</span>
        <span class="n">logman</span> <span class="o">=</span> <span class="n">LoggerManager</span><span class="p">(</span>
            <span class="vm">__name__</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="c1"># Get logger object and set logging level</span>
        <span class="n">level</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;DEBUG&quot;</span> <span class="k">if</span> <span class="n">debug</span> <span class="k">else</span> <span class="s2">&quot;INFO&quot;</span>
        <span class="n">logman</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span> <span class="o">=</span> <span class="n">logman</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d_stats</span> <span class="o">=</span> <span class="n">DStatistics</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">GenotypeEncoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">genotypes_012</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<div class="viewcode-block" id="PopGenStatistics.calculate_d_statistics">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.calculate_d_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_d_statistics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">population1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">population2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">population3</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">outgroup</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">population4</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_heterozygous</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">num_bootstraps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_individuals_per_pop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">individual_selection</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="n">output_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate D-statistics, Z-scores, and P-values from D-statistics.</span>

<span class="sd">        This method calculates D-statistics, Z-scores, and P-values for all possible sample combinations based on the chosen ``method``. The results are saved to a CSV file and returned as a pandas DataFrame. The overall mean D-statistic, Z-score, and P-value are also returned as a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (str): The method to use for calculating D-statistics. Supported options include &quot;patterson&quot;, &quot;partitioned&quot;, &quot;dfoil&quot;. &quot;patterson&quot; is the default and represents the traditional 4-taxon D-statistic. &quot;partitioned&quot; is a generalization of the D-statistic that allows for more than 4 populations. &quot;dfoil&quot; is a method that calculates D-statistics for all possible combinations of 4 populations (i.e., the FOIL method). Defaults to &quot;patterson&quot;.</span>
<span class="sd">            population1 (str | List[str]): Population ID or list of IDs.</span>
<span class="sd">            population2 (str | List[str]): Population ID or list of IDs.</span>
<span class="sd">            population3 (str | List[str]): Population ID or list of IDs.</span>
<span class="sd">            outgroup (str | List[str]): Population ID or list of IDs.</span>
<span class="sd">            population4 (str | List[str], optional): Population ID or list of IDs. Required for &quot;partitioned&quot; and &quot;dfoil&quot; methods.</span>
<span class="sd">            include_heterozygous (bool): Whether to include heterozygous genotypes. Defaults to False.</span>
<span class="sd">            num_bootstraps (int): Number of bootstrap replicates.</span>
<span class="sd">            n_jobs (int): Number of parallel jobs. -1 uses all available cores. Defaults to -1.</span>
<span class="sd">            max_individuals_per_pop (Optional[int]): Max individuals per population. Defaults to None. If specified, will select individuals from each population based on the criteria specified in ``individual_selection``.</span>
<span class="sd">            individual_selection (str | Dict[str, List[str]]): Method for selecting individuals. Defaults to &quot;random&quot;. If max_individuals_per_pop is specified, can be a dictionary with population IDs as keys and lists of selected individuals as values.</span>
<span class="sd">            output_file (Optional[str]): Path to save the results CSV file. If not specified, results will be saved to a default location. Defaults to None.</span>
<span class="sd">            save_plot (bool): Whether to save the plots D-statistic plots. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple: A tuple containing the results of all sample combinations as a pandas DataFrame and the overall mean D-statistic, Z-score, and P-value as a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating </span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2"> D-statistics...&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_population_indices</span><span class="p">(</span><span class="n">population</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Retrieve sample indices for a population or list of populations.</span>

<span class="sd">            Args:</span>
<span class="sd">                population (Union[str, List[str]]): Population ID or list of IDs.</span>

<span class="sd">            Returns:</span>
<span class="sd">                List[int]: List of sample indices.</span>

<span class="sd">            Raises:</span>
<span class="sd">                ValueError: If a population ID is not found.</span>
<span class="sd">                ValueError: If an invalid ``individual_selection`` method is specified.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">populations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">population</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">population</span>
            <span class="p">)</span>
            <span class="n">selected_samples</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">popmap_inverse</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">popmap_inverse</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">populations</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">samples</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">popmap_inverse</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span>
                    <span class="c1"># Limit individuals per population if specified</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">max_individuals_per_pop</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_individuals_per_pop</span>
                    <span class="p">):</span>
                        <span class="k">if</span> <span class="n">individual_selection</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                            <span class="n">selected_samples</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                                    <span class="n">samples</span><span class="p">,</span> <span class="n">max_individuals_per_pop</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">individual_selection</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="n">selected_samples</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="n">individual_selection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                    <span class="n">pop</span><span class="p">,</span> <span class="n">samples</span><span class="p">[:</span><span class="n">max_individuals_per_pop</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Invalid individual_selection: &#39;</span><span class="si">{</span><span class="n">individual_selection</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                            <span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">selected_samples</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Population ID &#39;</span><span class="si">{</span><span class="n">pop</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Population ID &#39;</span><span class="si">{</span><span class="n">pop</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>

            <span class="c1"># Convert sample IDs to indices</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">samples</span>
            <span class="n">sample_id_to_index</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">sample</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">sample_id_to_index</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">selected_samples</span>
                <span class="k">if</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">sample_id_to_index</span>
            <span class="p">]</span>

        <span class="c1"># Retrieve sample indices for each population</span>
        <span class="n">d1_inds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_population_indices</span><span class="p">(</span><span class="n">population1</span><span class="p">)</span>
        <span class="n">d2_inds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_population_indices</span><span class="p">(</span><span class="n">population2</span><span class="p">)</span>
        <span class="n">d3_inds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_population_indices</span><span class="p">(</span><span class="n">population3</span><span class="p">)</span>
        <span class="n">d4_inds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">get_population_indices</span><span class="p">(</span><span class="n">population4</span><span class="p">)</span> <span class="k">if</span> <span class="n">population4</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">outgroup_inds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_population_indices</span><span class="p">(</span><span class="n">outgroup</span><span class="p">)</span>

        <span class="c1"># Calculate Z-scores and P-values</span>
        <span class="n">combo_z_p_values</span><span class="p">,</span> <span class="n">overall_z_score</span><span class="p">,</span> <span class="n">overall_p_value</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d_stats</span><span class="o">.</span><span class="n">calculate_z_and_p_values</span><span class="p">(</span>
                <span class="n">d1_inds</span><span class="p">,</span>
                <span class="n">d2_inds</span><span class="p">,</span>
                <span class="n">d3_inds</span><span class="p">,</span>
                <span class="n">outgroup_inds</span><span class="p">,</span>
                <span class="n">d4_inds</span><span class="p">,</span>
                <span class="n">include_heterozygous</span><span class="p">,</span>
                <span class="n">num_bootstraps</span><span class="p">,</span>
                <span class="n">method</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Directory and filename setup</span>
        <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outdir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_output&quot;</span><span class="p">,</span> <span class="s2">&quot;analysis&quot;</span><span class="p">,</span> <span class="s2">&quot;d_stats&quot;</span><span class="p">)</span>
            <span class="n">outdir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">output_file</span> <span class="o">=</span> <span class="n">outdir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_dstat_results.csv&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Prepare columns for sample combinations</span>
        <span class="n">max_combo_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span> <span class="k">for</span> <span class="n">combo</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">combo_z_p_values</span><span class="p">)</span>
        <span class="n">combo_columns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Sample_</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_combo_len</span><span class="p">)]</span>

        <span class="c1"># Create data entries with columns for each sample in combination</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">combo</span><span class="p">,</span> <span class="n">observed_d</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">combo_z_p_values</span><span class="p">:</span>
            <span class="n">combo_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">combo_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="nb">str</span><span class="p">(</span><span class="n">combo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_combo_len</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">combo_data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;Observed D-Statistic&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">observed_d</span><span class="p">),</span>
                    <span class="s2">&quot;Z-Score&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">),</span>
                    <span class="s2">&quot;P-Value&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combo_data</span><span class="p">)</span>

        <span class="c1"># Get overall mean results.</span>
        <span class="n">overall_d_stat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="p">[</span><span class="n">obs</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">combo_z_p_values</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">overall_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Observed D-Statistic&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">overall_d_stat</span><span class="p">),</span>
            <span class="s2">&quot;Z-Score&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">overall_z_score</span><span class="p">),</span>
            <span class="s2">&quot;P-Value&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">overall_p_value</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="c1"># Create DataFrame from data</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Bonferroni and FDR corrections</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjust_p_values</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="c1"># Save results to CSV</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Results saved to </span><span class="si">{</span><span class="n">output_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
            <span class="c1"># Plot D-statistic results</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_d_statistics</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;D-statistics calculation complete!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">overall_data</span></div>


    <span class="k">def</span> <span class="nf">_adjust_p_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust P-values using multiple testing correction methods.</span>

<span class="sd">        This method adjusts P-values using the Bonferroni and FDR B-H methods. The adjusted P-values are added to the DataFrame, along with significance columns for each correction.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): DataFrame containing P-values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: DataFrame with adjusted P-values and significance columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adjusting P-values...&quot;</span><span class="p">)</span>

        <span class="c1"># Make a copy of the DataFrame to avoid modifying the original</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Bonferroni P-Value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;P-Value&quot;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bonferroni&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;FDR-BH P-Value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;P-Value&quot;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fdr_bh&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Add significance columns for each correction</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Significant (Raw)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;P-Value&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Significant (Bonferroni)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Bonferroni P-Value&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Significant (FDR-BH)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;FDR-BH P-Value&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span>

        <span class="k">return</span> <span class="n">df</span>

<div class="viewcode-block" id="PopGenStatistics.detect_fst_outliers">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.detect_fst_outliers">[docs]</a>
    <span class="k">def</span> <span class="nf">detect_fst_outliers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">correction_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">use_bootstrap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">n_bootstraps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">save_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detect Fst outliers from SNP data using bootstrapping or DBSCAN.</span>

<span class="sd">        This method detects Fst outliers from SNP data using bootstrapping or DBSCAN clustering. Outliers are identified based on the distribution of Fst values between population pairs. The method returns a DataFrame containing the Fst outliers and contributing population pairs, as well as a DataFrame containing the adjusted or unadjusted P-values, depending on whether a multiple testing correction method was specified.</span>

<span class="sd">        Args:</span>
<span class="sd">            correction_method (str, optional): Multiple testing correction method that performs P-value adjustment, &#39;bonf&#39; (Bonferroni) or &#39;fdr&#39; (FDR B-H). If not specified, no correction or P-value adjustment is applied. Defaults to None.</span>
<span class="sd">            alpha (float): Significance level for multiple test correction (with adjusted P-values). Defaults to 0.05.</span>
<span class="sd">            use_bootstrap (bool): Whether to use bootstrapping to estimate variance of Fst per SNP. If False, DBSCAN clustering is used instead. Defaults to False.</span>
<span class="sd">            n_bootstraps (int): Number of bootstrap replicates to use for estimating variance of Fst per SNP. Defaults to 1000.</span>
<span class="sd">            n_jobs (int): Number of CPU threads to use for parallelization. If set to -1, all available CPU threads are used. Defaults to 1.</span>
<span class="sd">            save_plot (bool): Whether to save the heatmap plot of Fst outliers. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[pd.DataFrame, pd.DataFrame]: A DataFrame containing the Fst outliers and contributing population pairs, and a DataFrame containing the adjusted P-values if ``correction_method`` was provided or the un-adjusted P-values otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Detecting Fst outliers...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">correction_method</span><span class="p">:</span>
            <span class="n">correction_method</span> <span class="o">=</span> <span class="n">correction_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">correction_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;bonf&quot;</span><span class="p">,</span> <span class="s2">&quot;fdr&quot;</span><span class="p">}:</span>
                <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid correction_method. Supported options: &#39;bonferroni&#39;, &#39;fdr&#39;, but got: </span><span class="si">{</span><span class="n">correction_method</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">correction_method</span> <span class="o">=</span> <span class="s2">&quot;fdr_bh&quot;</span> <span class="k">if</span> <span class="n">correction_method</span> <span class="o">==</span> <span class="s2">&quot;fdr&quot;</span> <span class="k">else</span> <span class="s2">&quot;bonferroni&quot;</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap_fst</span> <span class="k">if</span> <span class="n">use_bootstrap</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dbscan_fst</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">correction_method</span><span class="p">,</span> <span class="n">alpha</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">use_bootstrap</span><span class="p">:</span>
            <span class="c1"># Step 1: Calculate bootstrapped Fst values between population pairs</span>
            <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">n_bootstraps</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">])</span>

        <span class="n">outlier_snps</span><span class="p">,</span> <span class="n">contributing_pairs</span><span class="p">,</span> <span class="n">adjusted_pvals_df</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Add contributing pairs to the outlier_snps DataFrame</span>
        <span class="n">outlier_snps</span><span class="p">[</span><span class="s2">&quot;Contributing_Pairs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contributing_pairs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">outlier_snps</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outlier_snps</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No Fst outliers detected. Skipping correspoding plot.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">outlier_snps</span><span class="p">)</span><span class="si">}</span><span class="s2"> Fst outliers detected.&quot;</span><span class="p">)</span>

            <span class="c1"># Plot the outlier SNPs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_fst_outliers</span><span class="p">(</span><span class="n">outlier_snps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fst outlier detection complete!&quot;</span><span class="p">)</span>

        <span class="c1"># Return outlier SNPs</span>
        <span class="k">return</span> <span class="n">outlier_snps</span><span class="p">,</span> <span class="n">adjusted_pvals_df</span></div>


    <span class="k">def</span> <span class="nf">_dbscan_fst</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">correction_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detect Fst outliers using DBSCAN clustering.</span>

<span class="sd">        This method detects Fst outliers from SNP data using DBSCAN clustering. Outliers are identified based on the distribution of Fst values between population pairs. The method returns a DataFrame containing the Fst outliers and contributing population pairs, as well as a DataFrame containing the adjusted or unadjusted P-values, depending on whether a multiple testing correction method was specified.</span>

<span class="sd">        Args:</span>
<span class="sd">            correction_method (str): Multiple testing correction method.</span>
<span class="sd">            alpha (float): Significance level for multiple test correction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[pd.DataFrame, List[Tuple[str]], pd.DataFrame]: A DataFrame containing the Fst outliers, a list of contributing population pairs, and a DataFrame containing the adjusted P-values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Detecting Fst outliers using DBSCAN...&quot;</span><span class="p">)</span>

        <span class="c1"># Step 1: Calculate Fst values between population pairs</span>
        <span class="n">fst_per_population_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weir_cockerham_fst_between_populations</span><span class="p">()</span>

        <span class="c1"># Step 2: Combine Fst values into a DataFrame</span>
        <span class="n">fst_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fst_per_population_pair</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;columns&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Optionally, add SNP identifiers as index if available</span>
        <span class="n">fst_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fst_df</span><span class="p">))</span>

        <span class="c1"># Handle missing values</span>
        <span class="n">fst_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Step 3: Prepare data for DBSCAN</span>
        <span class="n">fst_values</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">n_population_pairs</span> <span class="o">=</span> <span class="n">fst_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_data_points</span> <span class="o">=</span> <span class="n">fst_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_population_pairs</span><span class="p">),</span> <span class="n">n_data_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Scale the data</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">fst_values_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">fst_values</span><span class="p">)</span>

        <span class="c1"># Step 4: Estimate optimal eps</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_eps</span><span class="p">(</span><span class="n">fst_values_scaled</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">)</span>

        <span class="c1"># Step 5: Apply DBSCAN</span>
        <span class="n">db</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">fst_values_scaled</span><span class="p">)</span>

        <span class="c1"># Step 6: Identify outliers</span>
        <span class="n">outlier_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">outlier_snps</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">outlier_indices</span><span class="p">]</span>

        <span class="c1"># Step 7: Identify contributing population pairs with multiple testing correction</span>
        <span class="c1"># Compute mean and std of Fst values per population pair across all SNPs</span>
        <span class="n">fst_means</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">fst_stds</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

        <span class="c1"># Avoid division by zero</span>
        <span class="n">fst_stds</span> <span class="o">=</span> <span class="n">fst_stds</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>

        <span class="c1"># For each outlier SNP, compute z-scores</span>
        <span class="n">z_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">outlier_snps</span> <span class="o">-</span> <span class="n">fst_means</span><span class="p">)</span> <span class="o">/</span> <span class="n">fst_stds</span>

        <span class="c1"># Compute two-tailed p-values for z-scores</span>
        <span class="n">p_values</span> <span class="o">=</span> <span class="n">z_scores</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="p">)</span>

        <span class="c1"># Flatten all p-values into one array, excluding NaNs</span>
        <span class="n">all_p_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">p_values</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">all_p_values</span><span class="p">)</span>
        <span class="n">all_p_values_valid</span> <span class="o">=</span> <span class="n">all_p_values</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">correction_method</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_p_values_valid</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;No valid p-values found. Skipping multiple testing correction.&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All p-values: </span><span class="si">{</span><span class="n">all_p_values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Valid indices: </span><span class="si">{</span><span class="n">valid_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Valid p-values: </span><span class="si">{</span><span class="n">all_p_values_valid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">adjusted_pvals_valid</span> <span class="o">=</span> <span class="n">all_p_values_valid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Apply multiple testing correction</span>
                <span class="n">adjusted_pvals_valid</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span>
                    <span class="n">all_p_values_valid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">correction_method</span>
                <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adjusted_pvals_valid</span> <span class="o">=</span> <span class="n">all_p_values_valid</span>

            <span class="c1"># Create adjusted p-values DataFrame</span>
        <span class="n">adjusted_pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">all_p_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">adjusted_pvals</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_pvals_valid</span>

        <span class="c1"># Reshape adjusted_pvals to match p_values DataFrame</span>
        <span class="n">adjusted_pvals_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">adjusted_pvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p_values</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">p_values</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">p_values</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Identify population pairs contributing to outlier status</span>
        <span class="n">contributing_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">snp</span> <span class="ow">in</span> <span class="n">adjusted_pvals_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">adjusted_pvals_row</span> <span class="o">=</span> <span class="n">adjusted_pvals_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">snp</span><span class="p">]</span>
            <span class="n">significant_pairs</span> <span class="o">=</span> <span class="n">adjusted_pvals_row</span><span class="p">[</span><span class="n">adjusted_pvals_row</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">]</span>
            <span class="n">significant_pairs</span> <span class="o">=</span> <span class="n">significant_pairs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">contributing_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">significant_pairs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outlier_snps</span><span class="p">,</span> <span class="n">contributing_pairs</span><span class="p">,</span> <span class="n">adjusted_pvals_df</span>

    <span class="k">def</span> <span class="nf">_bootstrap_fst</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">correction_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">n_bootstraps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detect Fst outliers using bootstrapping approach.</span>

<span class="sd">        This method detects Fst outliers from SNP data using bootstrapping. Outliers are identified based on the distribution of Fst values between population pairs. The method returns a DataFrame containing the Fst outliers and contributing population pairs, as well as a DataFrame containing the adjusted or unadjusted P-values, depending on whether a multiple testing correction method was specified.</span>

<span class="sd">        Args:</span>
<span class="sd">            correction_method (str): Multiple testing correction method.</span>
<span class="sd">            alpha (float): Significance level for multiple test correction.</span>
<span class="sd">            n_bootstraps (int): Number of bootstrap replicates.</span>
<span class="sd">            n_jobs (int): Number of parallel jobs. If set to -1, all available CPU threads are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[pd.DataFrame, List[Tuple[str]], pd.DataFrame]: A DataFrame containing the Fst outliers, a list of contributing population pairs, and a DataFrame containing the adjusted P-values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Detecting Fst outliers using bootstrapping...&quot;</span><span class="p">)</span>

        <span class="c1"># Step 1: Calculate bootstrapped Fst values between population pairs</span>
        <span class="n">fst_bootstrap_per_population_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weir_cockerham_fst_between_populations</span><span class="p">(</span>
            <span class="n">n_bootstraps</span><span class="o">=</span><span class="n">n_bootstraps</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span>
        <span class="p">)</span>

        <span class="c1"># Compute mean and std of Fst per SNP over bootstraps</span>
        <span class="n">fst_means</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fst_stds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pop_pair</span><span class="p">,</span> <span class="n">fst_bootstrap</span> <span class="ow">in</span> <span class="n">fst_bootstrap_per_population_pair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">fst_means</span><span class="p">[</span><span class="n">pop_pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">fst_bootstrap</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fst_stds</span><span class="p">[</span><span class="n">pop_pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">fst_bootstrap</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Prepare DataFrames</span>
        <span class="n">fst_mean_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fst_means</span><span class="p">)</span>
        <span class="n">fst_std_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fst_stds</span><span class="p">)</span>

        <span class="c1"># Add SNP identifiers as index</span>
        <span class="n">fst_mean_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fst_mean_df</span><span class="p">))</span>
        <span class="n">fst_std_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">fst_mean_df</span><span class="o">.</span><span class="n">index</span>

        <span class="c1"># Determine the threshold for acceptable missing data</span>
        <span class="n">missing_threshold</span> <span class="o">=</span> <span class="mf">0.2</span>  <span class="c1"># Allow up to 20% missing data per SNP</span>

        <span class="c1"># Calculate the proportion of missing data per SNP</span>
        <span class="n">missing_proportion</span> <span class="o">=</span> <span class="n">fst_mean_df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Identify SNPs with acceptable missing data</span>
        <span class="n">valid_snps</span> <span class="o">=</span> <span class="n">missing_proportion</span> <span class="o">&lt;=</span> <span class="n">missing_threshold</span>

        <span class="c1"># Filter DataFrames to retain only valid SNPs</span>
        <span class="n">fst_mean_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">fst_mean_df</span><span class="p">[</span><span class="n">valid_snps</span><span class="p">]</span>
        <span class="n">fst_std_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">fst_std_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid_snps</span><span class="p">]</span>

        <span class="c1"># Impute remaining NaNs with the mean of each column</span>
        <span class="n">fst_mean_df</span> <span class="o">=</span> <span class="n">fst_mean_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fst_mean_df</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">fst_std_df</span> <span class="o">=</span> <span class="n">fst_std_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fst_std_df</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_mean_df shape: </span><span class="si">{</span><span class="n">fst_mean_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_std_df shape: </span><span class="si">{</span><span class="n">fst_std_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Handle missing values</span>
        <span class="n">fst_mean_df</span> <span class="o">=</span> <span class="n">fst_mean_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">fst_std_df</span> <span class="o">=</span> <span class="n">fst_std_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">fst_mean_df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_mean_df shape: </span><span class="si">{</span><span class="n">fst_mean_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_std_df shape: </span><span class="si">{</span><span class="n">fst_std_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Use observed Fst values (from non-bootstrapped data)</span>
        <span class="n">fst_per_population_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weir_cockerham_fst_between_populations</span><span class="p">()</span>

        <span class="n">fst_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fst_per_population_pair</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;columns&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_mean_df shape: </span><span class="si">{</span><span class="n">fst_mean_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_std_df shape: </span><span class="si">{</span><span class="n">fst_std_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_df shape: </span><span class="si">{</span><span class="n">fst_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">fst_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fst_df</span><span class="p">))</span>
        <span class="n">fst_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">fst_mean_df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>  <span class="c1"># Align indices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_mean_df shape: </span><span class="si">{</span><span class="n">fst_mean_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_std_df shape: </span><span class="si">{</span><span class="n">fst_std_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_df shape: </span><span class="si">{</span><span class="n">fst_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure columns are aligned and in the same order</span>
        <span class="n">common_columns</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">fst_mean_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Reindex DataFrames to have the same columns</span>
        <span class="n">fst_df</span> <span class="o">=</span> <span class="n">fst_df</span><span class="p">[</span><span class="n">common_columns</span><span class="p">]</span>
        <span class="n">fst_mean_df</span> <span class="o">=</span> <span class="n">fst_mean_df</span><span class="p">[</span><span class="n">common_columns</span><span class="p">]</span>
        <span class="n">fst_std_df</span> <span class="o">=</span> <span class="n">fst_std_df</span><span class="p">[</span><span class="n">common_columns</span><span class="p">]</span>

        <span class="c1"># Impute remaining NaNs with the mean of each column</span>
        <span class="n">fst_df</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fst_df</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_mean_df shape: </span><span class="si">{</span><span class="n">fst_mean_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_std_df shape: </span><span class="si">{</span><span class="n">fst_std_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fst_df shape: </span><span class="si">{</span><span class="n">fst_df</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Replace zero standard deviations with a small positive value</span>
        <span class="c1"># Avoids division by zero when computing Z-scores</span>
        <span class="n">fst_std_df</span> <span class="o">=</span> <span class="n">fst_std_df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>

        <span class="c1"># Compute Z-scores</span>
        <span class="n">z_scores</span> <span class="o">=</span> <span class="p">(</span><span class="n">fst_df</span> <span class="o">-</span> <span class="n">fst_mean_df</span><span class="p">)</span> <span class="o">/</span> <span class="n">fst_std_df</span>

        <span class="c1"># Compute two-tailed p-values for z-scores</span>
        <span class="n">p_values</span> <span class="o">=</span> <span class="n">z_scores</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p_values</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p_values</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">z_scores</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">z_scores</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Flatten all p-values into one array, excluding NaNs</span>
        <span class="n">all_p_values</span> <span class="o">=</span> <span class="n">p_values</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">all_p_values</span><span class="p">)</span>
        <span class="n">all_p_values_valid</span> <span class="o">=</span> <span class="n">all_p_values</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">correction_method</span><span class="p">:</span>
            <span class="c1"># Apply multiple testing correction</span>
            <span class="n">adjusted_pvals_valid</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span>
                <span class="n">all_p_values_valid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">correction_method</span>
            <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adjusted_pvals_valid</span> <span class="o">=</span> <span class="n">all_p_values_valid</span>

        <span class="c1"># Create adjusted p-values DataFrame</span>
        <span class="n">adjusted_pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">all_p_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">adjusted_pvals</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_pvals_valid</span>

        <span class="c1"># Reshape adjusted_pvals to match p_values DataFrame</span>
        <span class="n">adjusted_pvals_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">adjusted_pvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p_values</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">p_values</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">p_values</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Identify significant SNPs and contributing pairs</span>
        <span class="n">significant</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">adjusted_pvals_df</span> <span class="o">&lt;</span> <span class="n">alpha</span>

        <span class="c1"># Get outlier SNPs</span>
        <span class="n">outlier_indices</span> <span class="o">=</span> <span class="n">significant</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">outlier_snps</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">fst_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">outlier_indices</span><span class="p">]</span>

        <span class="c1"># Identify contributing population pairs</span>
        <span class="n">contributing_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">snp</span> <span class="ow">in</span> <span class="n">adjusted_pvals_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">outlier_indices</span><span class="p">]:</span>
            <span class="n">adjusted_pvals_row</span> <span class="o">=</span> <span class="n">adjusted_pvals_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">snp</span><span class="p">]</span>
            <span class="n">significant_pairs</span> <span class="o">=</span> <span class="n">adjusted_pvals_row</span><span class="p">[</span>
                <span class="n">adjusted_pvals_row</span> <span class="o">&lt;</span> <span class="n">alpha</span>
            <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">contributing_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">significant_pairs</span><span class="p">)</span>

        <span class="c1"># Return outlier SNPs</span>
        <span class="k">return</span> <span class="n">outlier_snps</span><span class="p">,</span> <span class="n">contributing_pairs</span><span class="p">,</span> <span class="n">adjusted_pvals_df</span>

    <span class="k">def</span> <span class="nf">_estimate_eps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fst_values</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the optimal eps value for DBSCAN clustering.</span>

<span class="sd">        This method estimates the optimal eps value for DBSCAN clustering using the k-distance graph method. The optimal eps value is determined based on the knee point of the k-distance graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            fst_values (pd.DataFrame): Fst values between population pairs.</span>
<span class="sd">            min_samples (int): Minimum number of samples required for DBSCAN clustering.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The optimal eps value for DBSCAN clustering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 4: Compute the k-distance graph to find optimal eps</span>
        <span class="n">neighbor</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">min_samples</span><span class="p">)</span>
        <span class="n">nbrs</span><span class="p">:</span> <span class="n">NearestNeighbors</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">fst_values</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">fst_values</span><span class="p">)</span>

        <span class="c1"># Sort the distances to the min_samples-th nearest neighbor</span>
        <span class="n">distances_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">distances</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Check if distances are all zeros</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">distances_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Distances all zeros. Setting eps to a small positive value.&quot;</span>
            <span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># Adjust as appropriate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use KneeLocator to find the knee point</span>
            <span class="n">kneedle</span> <span class="o">=</span> <span class="n">KneeLocator</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances_k</span><span class="p">)),</span>
                <span class="n">distances_k</span><span class="p">,</span>
                <span class="n">S</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">curve</span><span class="o">=</span><span class="s2">&quot;convex&quot;</span><span class="p">,</span>
                <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;increasing&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">kneedle</span><span class="o">.</span><span class="n">knee</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="n">distances_k</span><span class="p">[</span><span class="n">kneedle</span><span class="o">.</span><span class="n">knee</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback: Use a percentile of distances</span>
                <span class="n">eps</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">distances_k</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;KneeLocator did not find a knee. Using eps from 10th percentile: </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">eps</span>

<div class="viewcode-block" id="PopGenStatistics.observed_heterozygosity">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.observed_heterozygosity">[docs]</a>
    <span class="k">def</span> <span class="nf">observed_heterozygosity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate observed heterozygosity (Ho) for each locus.</span>

<span class="sd">        Observed heterozygosity (Ho) is defined as the proportion of heterozygous individuals at a given locus.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array containing observed heterozygosity values for each locus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alignment</span><span class="p">,</span> <span class="n">n_individuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_alignment_and_individuals</span><span class="p">()</span>
        <span class="n">ho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_heterozygosity</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">n_individuals</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ho</span></div>


<div class="viewcode-block" id="PopGenStatistics.expected_heterozygosity">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.expected_heterozygosity">[docs]</a>
    <span class="k">def</span> <span class="nf">expected_heterozygosity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate expected heterozygosity (He) for each locus.</span>

<span class="sd">        Expected heterozygosity (He) is the expected proportion of heterozygous individuals under Hardy-Weinberg equilibrium.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array containing expected heterozygosity values for each locus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alignment</span><span class="p">,</span> <span class="n">n_individuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_alignment_and_individuals</span><span class="p">()</span>
        <span class="n">he</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_heterozygosity</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">n_individuals</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">he</span></div>


    <span class="k">def</span> <span class="nf">_prepare_alignment_and_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare alignment and count non-missing individuals per locus.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]: Alignment array and counts of non-missing individuals per locus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Replace missing data (-9) with NaN</span>
        <span class="n">alignment</span><span class="p">[</span><span class="n">alignment</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Count valid individuals per locus</span>
        <span class="n">n_individuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alignment</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">n_individuals</span>

    <span class="k">def</span> <span class="nf">_calculate_heterozygosity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">alignment</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n_individuals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">observed</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate heterozygosity (Ho or He) for each locus.</span>

<span class="sd">        Args:</span>
<span class="sd">            alignment (np.ndarray): The alignment array.</span>
<span class="sd">            n_individuals (np.ndarray): Number of non-missing individuals per locus.</span>
<span class="sd">            observed (bool): If True, calculate observed heterozygosity (Ho); otherwise, expected heterozygosity (He).</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Heterozygosity values for each locus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">observed</span><span class="p">:</span>
            <span class="c1"># Calculate observed heterozygosity</span>
            <span class="n">heterozygous_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alignment</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">heterozygous_counts</span><span class="p">,</span> <span class="n">n_individuals</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">n_individuals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ho</span><span class="p">[</span><span class="n">n_individuals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Handle loci with no valid data</span>
            <span class="k">return</span> <span class="n">ho</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate expected heterozygosity</span>
            <span class="n">alt_allele_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">total_alleles</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_individuals</span>  <span class="c1"># Assuming diploid organisms</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="c1"># Frequency of alternate alleles</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">alt_allele_counts</span><span class="p">,</span> <span class="n">total_alleles</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">total_alleles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p</span>
                <span class="n">he</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span>  <span class="c1"># He = 2pq</span>

                <span class="c1"># Handle loci with no valid data</span>
                <span class="n">he</span><span class="p">[</span><span class="n">total_alleles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="n">he</span>

<div class="viewcode-block" id="PopGenStatistics.nucleotide_diversity">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.nucleotide_diversity">[docs]</a>
    <span class="k">def</span> <span class="nf">nucleotide_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate nucleotide diversity (Pi) for each locus.</span>

<span class="sd">        Nucleotide diversity (Pi) is the average number of nucleotide differences per site between two sequences.</span>

<span class="sd">        Notes:</span>
<span class="sd">            A bias correction is applied in the calculation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array containing nucleotide diversity values for each locus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">n_individuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_alignment_and_individuals</span><span class="p">()</span>
        <span class="n">he</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_heterozygosity</span><span class="p">()</span>

        <span class="c1"># Calculate nucleotide diversity</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">he</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">n_individuals</span> <span class="o">&gt;</span> <span class="mi">1</span>  <span class="c1"># Need at least 2 individuals for diversity</span>
        <span class="n">pi</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">he</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_individuals</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_individuals</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pi</span></div>


<div class="viewcode-block" id="PopGenStatistics.summary_statistics">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.summary_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">summary_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_bootstraps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save_plots</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate a suite of summary statistics for SNP data.</span>

<span class="sd">        This method calculates a suite of summary statistics for SNP data, including observed heterozygosity (Ho), expected heterozygosity (He), nucleotide diversity (Pi), and Fst between populations. Summary statistics are calculated both overall and per population.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_bootstraps (int): Number of bootstrap replicates to use for estimating variance of Fst per SNP. If 0, then bootstrapping is not used and confidence intervals are estimated from the data. Defaults to 0.</span>
<span class="sd">            n_jobs (int): Number of parallel jobs. If set to -1, all available CPU threads are used. Defaults to 1.</span>
<span class="sd">            save_plots (bool): Whether to save plots of the summary statistics. In any case, a dictionary of summary statistics is returned. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary containing summary statistics per population and overall.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating summary statistics...&quot;</span><span class="p">)</span>

        <span class="c1"># Overall statistics</span>
        <span class="n">ho_overall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_heterozygosity</span><span class="p">())</span>
        <span class="n">he_overall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_heterozygosity</span><span class="p">())</span>
        <span class="n">pi_overall</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nucleotide_diversity</span><span class="p">())</span>

        <span class="c1"># Per-population statistics</span>
        <span class="n">ho_per_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_heterozygosity_per_population</span><span class="p">()</span>
        <span class="n">he_per_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_heterozygosity_per_population</span><span class="p">()</span>
        <span class="n">pi_per_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nucleotide_diversity_per_population</span><span class="p">()</span>

        <span class="n">summary_stats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;overall&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;Ho&quot;</span><span class="p">:</span> <span class="n">ho_overall</span><span class="p">,</span> <span class="s2">&quot;He&quot;</span><span class="p">:</span> <span class="n">he_overall</span><span class="p">,</span> <span class="s2">&quot;Pi&quot;</span><span class="p">:</span> <span class="n">pi_overall</span><span class="p">}</span>
            <span class="p">),</span>
            <span class="s2">&quot;per_population&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">pop_id</span> <span class="ow">in</span> <span class="n">ho_per_population</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">summary_stats</span><span class="p">[</span><span class="s2">&quot;per_population&quot;</span><span class="p">][</span><span class="n">pop_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;Ho&quot;</span><span class="p">:</span> <span class="n">ho_per_population</span><span class="p">[</span><span class="n">pop_id</span><span class="p">],</span>
                    <span class="s2">&quot;He&quot;</span><span class="p">:</span> <span class="n">he_per_population</span><span class="p">[</span><span class="n">pop_id</span><span class="p">],</span>
                    <span class="s2">&quot;Pi&quot;</span><span class="p">:</span> <span class="n">pi_per_population</span><span class="p">[</span><span class="n">pop_id</span><span class="p">],</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># Fst between populations</span>
        <span class="n">fst_between_pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weir_cockerham_fst_between_populations</span><span class="p">(</span>
            <span class="n">n_bootstraps</span><span class="o">=</span><span class="n">n_bootstraps</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span>
        <span class="p">)</span>
        <span class="n">summary_stats</span><span class="p">[</span><span class="s2">&quot;Fst_between_populations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fst_between_pops</span>

        <span class="k">if</span> <span class="n">save_plots</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_summary_statistics</span><span class="p">(</span><span class="n">summary_stats</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Summary statistics calculation complete!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary_stats</span></div>


<div class="viewcode-block" id="PopGenStatistics.observed_heterozygosity_per_population">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.observed_heterozygosity_per_population">[docs]</a>
    <span class="k">def</span> <span class="nf">observed_heterozygosity_per_population</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate observed heterozygosity (Ho) for each locus per population.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary where keys are population IDs and values are pandas Series containing the observed heterozygosity values per locus for that population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pop_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">get_population_indices</span><span class="p">()</span>
        <span class="n">ho_per_population</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">pop_id</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">pop_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pop_alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pop_alignment</span><span class="p">[</span><span class="n">pop_alignment</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Replace missing data</span>

            <span class="k">if</span> <span class="n">pop_alignment</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pop_alignment</span><span class="p">)):</span>
                <span class="k">continue</span>  <span class="c1"># Skip populations with no data</span>

            <span class="c1"># Number of non-missing individuals per locus</span>
            <span class="n">n_individuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pop_alignment</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">num_heterozygotes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pop_alignment</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Calculate Ho</span>
            <span class="n">ho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">pop_alignment</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">n_individuals</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">ho</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_heterozygotes</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_individuals</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

            <span class="c1"># Store results as a pandas Series with locus indices</span>
            <span class="n">ho_per_population</span><span class="p">[</span><span class="n">pop_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">ho</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pop_alignment</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ho&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ho_per_population</span></div>


<div class="viewcode-block" id="PopGenStatistics.expected_heterozygosity_per_population">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.expected_heterozygosity_per_population">[docs]</a>
    <span class="k">def</span> <span class="nf">expected_heterozygosity_per_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_n</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate expected heterozygosity (He) for each locus per population.</span>

<span class="sd">        Args:</span>
<span class="sd">            return_n (bool): If True, also return the number of non-missing individuals per locus.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary where keys are population IDs and values are pandas Series containing the expected heterozygosity values per locus for that population. If return_n is True, returns a tuple (he, n_individuals) per population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pop_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">get_population_indices</span><span class="p">()</span>
        <span class="n">he_per_population</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">pop_id</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">pop_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pop_alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pop_alignment</span><span class="p">[</span><span class="n">pop_alignment</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Replace missing data</span>

            <span class="k">if</span> <span class="n">pop_alignment</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pop_alignment</span><span class="p">)):</span>
                <span class="k">continue</span>  <span class="c1"># Skip populations with no data</span>

            <span class="c1"># Number of non-missing individuals per locus</span>
            <span class="n">n_individuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pop_alignment</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">total_alleles</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_individuals</span>

            <span class="c1"># Frequency of alternate allele (p)</span>
            <span class="n">alt_allele_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pop_alignment</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">alt_allele_counts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">total_alleles</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">p</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">alt_allele_counts</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">/</span> <span class="n">total_alleles</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
            <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p</span>

            <span class="c1"># Expected heterozygosity</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">he</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">return_n</span><span class="p">:</span>
                <span class="n">he_per_population</span><span class="p">[</span><span class="n">pop_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">he</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pop_alignment</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;He&quot;</span><span class="p">),</span>
                    <span class="n">n_individuals</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">he_per_population</span><span class="p">[</span><span class="n">pop_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                    <span class="n">he</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pop_alignment</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;He&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">he_per_population</span></div>


<div class="viewcode-block" id="PopGenStatistics.nucleotide_diversity_per_population">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.nucleotide_diversity_per_population">[docs]</a>
    <span class="k">def</span> <span class="nf">nucleotide_diversity_per_population</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate nucleotide diversity (Pi) for each locus per population.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary where keys are population IDs and values are pandas Series containing the nucleotide diversity values per locus for that population.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">he_and_n_per_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_heterozygosity_per_population</span><span class="p">(</span>
            <span class="n">return_n</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">pi_per_population</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">pop_id</span><span class="p">,</span> <span class="p">(</span><span class="n">he</span><span class="p">,</span> <span class="n">n_individuals</span><span class="p">)</span> <span class="ow">in</span> <span class="n">he_and_n_per_population</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n_individuals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># Calculate Pi with bias correction</span>
            <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">he</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">pi</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">he</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

            <span class="c1"># Store results as a pandas Series</span>
            <span class="n">pi_per_population</span><span class="p">[</span><span class="n">pop_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">pi</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">)),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Pi&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">pi_per_population</span></div>


<div class="viewcode-block" id="PopGenStatistics.weir_cockerham_fst_between_populations">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.weir_cockerham_fst_between_populations">[docs]</a>
    <span class="k">def</span> <span class="nf">weir_cockerham_fst_between_populations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n_bootstraps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate pairwise Weir and Cockerham&#39;s Fst.</span>

<span class="sd">        This method calculates pairwise Weir and Cockerham&#39;s Fst between populations. Fst is a measure of population differentiation due to genetic structure. Fst values range from 0 to 1, where 0 indicates no genetic differentiation and 1 indicates complete differentiation. Bootstrapping can be used to estimate the variance of Fst per SNP.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_bootstraps (int): Number of bootstrap replicates. Default is 0 (no bootstrapping).</span>
<span class="sd">            n_jobs (int): Number of parallel jobs for bootstrapping. Default is -1 (use all available cores).</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: If n_bootstraps is 0, returns a dictionary where keys are population pairs</span>
<span class="sd">                and values are pandas Series of Fst values per locus.</span>
<span class="sd">                If n_bootstraps &gt; 0, returns a dictionary where keys are population pairs</span>
<span class="sd">                and values are numpy arrays with shape (n_loci, n_bootstraps).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare population indices</span>
        <span class="n">pop_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">get_population_indices</span><span class="p">()</span>
        <span class="n">populations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pop_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">n_loci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Precompute alignments for each population</span>
        <span class="n">pop_alignments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">pop</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="p">[</span><span class="n">pop_indices</span><span class="p">[</span><span class="n">pop</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">populations</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">alignment</span> <span class="ow">in</span> <span class="n">pop_alignments</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">alignment</span><span class="p">[</span><span class="n">alignment</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Replace missing data</span>

        <span class="k">def</span> <span class="nf">compute_fst_pair</span><span class="p">(</span><span class="n">alignment1</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Function to compute Fst per SNP between two populations&quot;&quot;&quot;</span>
            <span class="n">n1_per_locus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alignment1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">n2_per_locus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alignment2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">n_total</span> <span class="o">=</span> <span class="n">n1_per_locus</span> <span class="o">+</span> <span class="n">n2_per_locus</span>

            <span class="n">alt_allele_counts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">alignment1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">alt_allele_counts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">alignment2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">total_alt_alleles</span> <span class="o">=</span> <span class="n">alt_allele_counts1</span> <span class="o">+</span> <span class="n">alt_allele_counts2</span>

            <span class="n">total_alleles1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n1_per_locus</span>
            <span class="n">total_alleles2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n2_per_locus</span>
            <span class="n">total_alleles</span> <span class="o">=</span> <span class="n">total_alleles1</span> <span class="o">+</span> <span class="n">total_alleles2</span>

            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">alt_allele_counts1</span><span class="p">,</span> <span class="n">total_alleles1</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">total_alleles1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">alt_allele_counts2</span><span class="p">,</span> <span class="n">total_alleles2</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">total_alleles2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                <span class="n">total_alt_alleles</span><span class="p">,</span> <span class="n">total_alleles</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">total_alleles</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">)</span>

            <span class="c1"># Variance in allele frequency between populations</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(((</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p_total</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="n">n1_per_locus</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">p1</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(((</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p_total</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="n">n2_per_locus</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">p2</span><span class="p">)),</span>
                <span class="p">(</span><span class="n">n_total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">n_total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Expected heterozygosity</span>
            <span class="n">he_total</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p_total</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_total</span><span class="p">)</span>

            <span class="c1"># Compute Fst</span>
            <span class="n">fst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">he_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">he_total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n_total</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">fst</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">/</span> <span class="n">he_total</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
            <span class="n">fst</span><span class="p">[</span><span class="o">~</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Set invalid loci to NaN</span>

            <span class="k">return</span> <span class="n">fst</span>

        <span class="c1"># Pairwise Fst calculation</span>
        <span class="k">if</span> <span class="n">n_bootstraps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fst_per_population_pair</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">populations</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">alignment1</span> <span class="o">=</span> <span class="n">pop_alignments</span><span class="p">[</span><span class="n">pop1</span><span class="p">]</span>
                <span class="n">alignment2</span> <span class="o">=</span> <span class="n">pop_alignments</span><span class="p">[</span><span class="n">pop2</span><span class="p">]</span>
                <span class="n">fst</span> <span class="o">=</span> <span class="n">compute_fst_pair</span><span class="p">(</span><span class="n">alignment1</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">)</span>
                <span class="n">fst_per_population_pair</span><span class="p">[(</span><span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                    <span class="n">fst</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_loci</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Fst </span><span class="si">{</span><span class="n">pop1</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">pop2</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">fst_per_population_pair</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Bootstrapping for Fst</span>
            <span class="n">fst_bootstrap_per_population_pair</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_loci</span><span class="p">,</span> <span class="n">n_bootstraps</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">populations</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="c1"># Bootstrap function</span>
            <span class="k">def</span> <span class="nf">bootstrap_replicate</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Function to compute Fst per SNP between two populations with bootstrapping&quot;&quot;&quot;</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
                <span class="n">resample_indices</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_loci</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_loci</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">fst_replicate</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">populations</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">alignment1</span> <span class="o">=</span> <span class="n">pop_alignments</span><span class="p">[</span><span class="n">pop1</span><span class="p">][:,</span> <span class="n">resample_indices</span><span class="p">]</span>
                    <span class="n">alignment2</span> <span class="o">=</span> <span class="n">pop_alignments</span><span class="p">[</span><span class="n">pop2</span><span class="p">][:,</span> <span class="n">resample_indices</span><span class="p">]</span>
                    <span class="n">fst</span> <span class="o">=</span> <span class="n">compute_fst_pair</span><span class="p">(</span><span class="n">alignment1</span><span class="p">,</span> <span class="n">alignment2</span><span class="p">)</span>
                    <span class="n">fst_replicate</span><span class="p">[(</span><span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fst</span>
                <span class="k">return</span> <span class="n">fst_replicate</span>

            <span class="c1"># Parallel bootstrap</span>
            <span class="n">seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e9</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_bootstraps</span><span class="p">)</span>
            <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span> <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">bootstrap_replicate</span><span class="p">,</span> <span class="n">seeds</span><span class="p">))</span>

            <span class="c1"># Collect bootstrap results</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">fst_replicate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">pop_pair</span><span class="p">,</span> <span class="n">fst_values</span> <span class="ow">in</span> <span class="n">fst_replicate</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">fst_bootstrap_per_population_pair</span><span class="p">[</span><span class="n">pop_pair</span><span class="p">][:,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">fst_values</span>

            <span class="k">return</span> <span class="n">fst_bootstrap_per_population_pair</span></div>


<div class="viewcode-block" id="PopGenStatistics.amova">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.amova">[docs]</a>
    <span class="k">def</span> <span class="nf">amova</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">regionmap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_bootstraps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Conduct AMOVA (Analysis Of Molecular Variance).</span>

<span class="sd">        AMOVA (Analysis of Molecular Variance) is a method for partitioning genetic variation into components due to differences among populations, among individuals within populations, and within individuals. This method calculates variance components and Phi statistics for a given number of hierarchical levels (1, 2, or 3). If bootstrapping is enabled, it also estimates p-values for the variance components. The number of hierarchical levels determines the structure of the AMOVA model: 1 =&gt; populations only, 2 =&gt; region -&gt; populations, 3 =&gt; region -&gt; population -&gt; individuals. If regionmap is provided, it is used to map populations to regions.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - Algorithm adapted from the R package &#39;poppr&#39; (Kamvar et al., 2014).</span>
<span class="sd">            - The Phi statistic is a measure of genetic differentiation between populations.</span>
<span class="sd">            - Algorithm description: First, the total variance is calculated. Then, the variance components are calculated by summing the squared differences between the mean of each group and the global mean. The Phi statistic is calculated as the ratio of the among-group variance to the total variance. P-values are estimated by bootstrapping.</span>

<span class="sd">        Args:</span>
<span class="sd">            regionmap (dict, optional): Mapping from population_id -&gt; region_id.</span>
<span class="sd">                If None but hierarchical_levels&gt;1, raises ValueError.</span>
<span class="sd">            n_bootstraps (int): Number of bootstrap replicates across SNP loci.</span>
<span class="sd">            n_jobs (int): Number of parallel jobs. -1 uses all cores.</span>
<span class="sd">            random_seed (int, optional): Random seed for reproducibility.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: AMOVA results (variance components, Phi statistics, and possibly p-values).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If regionmap is required but not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amova_instance</span> <span class="o">=</span> <span class="n">AMOVA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">amova_instance</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
            <span class="n">regionmap</span><span class="o">=</span><span class="n">regionmap</span><span class="p">,</span>
            <span class="n">n_bootstraps</span><span class="o">=</span><span class="n">n_bootstraps</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PopGenStatistics.tajimas_d">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.tajimas_d">[docs]</a>
    <span class="k">def</span> <span class="nf">tajimas_d</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Tajima&#39;s D for each locus.</span>

<span class="sd">        Tajima&#39;s D is a measure of the difference between two estimates of genetic diversity: the average number of pairwise differences (π) and Watterson&#39;s θ (based on segregating sites). A significant deviation of Tajima&#39;s D from zero suggests non-neutral evolution.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.Series: Tajima&#39;s D values for each locus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating Tajima&#39;s D...&quot;</span><span class="p">)</span>

        <span class="c1"># Step 1: Set up alignment data</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">alignment</span><span class="p">[</span><span class="n">alignment</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Replace missing data with NaN</span>

        <span class="c1"># Step 2: Calculate nucleotide diversity (π)</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nucleotide_diversity</span><span class="p">()</span>

        <span class="c1"># Step 3: Calculate the number of segregating sites (S)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">col</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">alignment</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Step 4: Calculate Watterson&#39;s theta</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">alignment</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Filter out loci with all missing data</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_samples</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_samples</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_samples</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_samples</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">a1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">theta</span><span class="p">[</span><span class="n">a1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Handle invalid cases</span>

        <span class="c1"># Step 5: Calculate variance and constants for Tajima&#39;s D</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_samples</span><span class="p">)</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">n_samples</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">a1</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span> <span class="o">*</span> <span class="n">n_samples</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">a1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Step 6: Calculate Tajima&#39;s D</span>
        <span class="n">variance_term</span> <span class="o">=</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">S</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance_term</span><span class="p">)</span>

        <span class="c1"># Set variance to NaN where S is zero or one</span>
        <span class="n">variance</span><span class="p">[(</span><span class="n">S</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">S</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">tajimas_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">pi</span> <span class="o">-</span> <span class="n">theta</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">variance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Handle invalid cases</span>
        <span class="n">tajimas_d</span><span class="p">[(</span><span class="n">variance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># Handle invalid cases</span>
        <span class="n">tajimas_d</span><span class="p">[(</span><span class="n">variance</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">tajimas_d</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">tajimas_d</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Tajima&#39;s D&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tajima&#39;s D calculation complete!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tajimas_d</span></div>


<div class="viewcode-block" id="PopGenStatistics.neis_genetic_distance">
<a class="viewcode-back" href="../../../snpio.popgenstats.html#snpio.popgenstats.pop_gen_statistics.PopGenStatistics.neis_genetic_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">neis_genetic_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate Nei&#39;s genetic distance between all pairs of populations.</span>

<span class="sd">        Nei&#39;s genetic distance is a measure of genetic divergence between populations. It is calculated based on the allele frequencies at each locus. A higher value indicates greater genetic distance, or differentiation, between populations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A DataFrame where each cell (i, j) represents Nei&#39;s genetic distance between populations i and j.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Get allele frequencies per population</span>
        <span class="n">allele_freqs_per_pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_allele_frequencies</span><span class="p">()</span>

        <span class="c1"># Step 2: Initialize DataFrame to store Nei&#39;s genetic distance for each population pair</span>
        <span class="n">populations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">allele_freqs_per_pop</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">populations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">populations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Step 3: Calculate Nei&#39;s genetic distance for each pair of populations</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pop1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">populations</span><span class="p">):</span>
            <span class="n">freqs_pop1</span> <span class="o">=</span> <span class="n">allele_freqs_per_pop</span><span class="p">[</span><span class="n">pop1</span><span class="p">]</span>

            <span class="c1"># Compare each population with every other population, including itself</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">pop2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">populations</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">dist_matrix</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="mf">0.0</span>  <span class="c1"># Genetic distance with itself is zero</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">freqs_pop2</span> <span class="o">=</span> <span class="n">allele_freqs_per_pop</span><span class="p">[</span><span class="n">pop2</span><span class="p">]</span>

                    <span class="c1"># Calculate Nei&#39;s genetic distance across loci</span>
                    <span class="n">neis_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_neis_distance_between_pops</span><span class="p">(</span>
                        <span class="n">freqs_pop1</span><span class="p">,</span> <span class="n">freqs_pop2</span>
                    <span class="p">)</span>

                    <span class="c1"># Set distance symmetrically</span>
                    <span class="n">dist_matrix</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span><span class="p">]</span> <span class="o">=</span> <span class="n">neis_distance</span>
                    <span class="n">dist_matrix</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pop2</span><span class="p">,</span> <span class="n">pop1</span><span class="p">]</span> <span class="o">=</span> <span class="n">neis_distance</span>

        <span class="c1"># Ensure all expected indices are in the DataFrame</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">populations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">populations</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dist_matrix</span></div>


    <span class="k">def</span> <span class="nf">_calculate_allele_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to calculate allele frequencies for each population at each locus.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary where keys are population IDs and values are arrays of allele</span>
<span class="sd">            frequencies per locus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pop_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genotype_data</span><span class="o">.</span><span class="n">get_population_indices</span><span class="p">()</span>
        <span class="n">allele_freqs_per_pop</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">pop_id</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">pop_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Subset alignment for population</span>
            <span class="n">pop_alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignment_012</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pop_alignment</span><span class="p">[</span><span class="n">pop_alignment</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># Replace missing data</span>

            <span class="c1"># Calculate allele frequencies</span>
            <span class="c1"># Since diploid</span>
            <span class="n">total_alleles</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pop_alignment</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">alt_allele_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pop_alignment</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Avoid division by zero</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">alt_allele_counts</span><span class="p">,</span> <span class="n">total_alleles</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">total_alleles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">allele_freqs_per_pop</span><span class="p">[</span><span class="n">pop_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">freqs</span>

        <span class="k">return</span> <span class="n">allele_freqs_per_pop</span>

    <span class="k">def</span> <span class="nf">_calculate_neis_distance_between_pops</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">freqs_pop1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">freqs_pop2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to calculate Nei&#39;s genetic distance between two populations based on</span>
<span class="sd">        their allele frequencies.</span>

<span class="sd">        Args:</span>
<span class="sd">            freqs_pop1 (np.ndarray): Allele frequencies of population 1.</span>
<span class="sd">            freqs_pop2 (np.ndarray): Allele frequencies of population 2.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Nei&#39;s genetic distance between the two populations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Calculate mean allele frequencies (p-bar) across populations</span>
        <span class="n">mean_freqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">freqs_pop1</span> <span class="o">+</span> <span class="n">freqs_pop2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Step 2: Calculate gene diversity within each population</span>
        <span class="n">h_pop1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">freqs_pop1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">freqs_pop1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">h_pop2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">freqs_pop2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">freqs_pop2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Step 3: Calculate mean gene diversity across populations</span>
        <span class="n">h_mean</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">mean_freqs</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mean_freqs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Step 4: Calculate Nei&#39;s genetic distance</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">nei_distance</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">h_pop1</span> <span class="o">+</span> <span class="n">h_pop2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">h_mean</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">nei_distance</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Bradley T. Martin and Tyler K. Chafin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>