# coding: utf-8

"""
    Selling Partner API for Services

    With the Services API, you can build applications that help service providers get and modify their service orders and manage their resources.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from py_sp_api.generated.services.models.add_appointment_request import AddAppointmentRequest
from py_sp_api.generated.services.models.assign_appointment_resources_request import AssignAppointmentResourcesRequest
from py_sp_api.generated.services.models.assign_appointment_resources_response import AssignAppointmentResourcesResponse
from py_sp_api.generated.services.models.cancel_reservation_response import CancelReservationResponse
from py_sp_api.generated.services.models.cancel_service_job_by_service_job_id_response import CancelServiceJobByServiceJobIdResponse
from py_sp_api.generated.services.models.complete_service_job_by_service_job_id_response import CompleteServiceJobByServiceJobIdResponse
from py_sp_api.generated.services.models.create_reservation_request import CreateReservationRequest
from py_sp_api.generated.services.models.create_reservation_response import CreateReservationResponse
from py_sp_api.generated.services.models.create_service_document_upload_destination import CreateServiceDocumentUploadDestination
from py_sp_api.generated.services.models.fixed_slot_capacity import FixedSlotCapacity
from py_sp_api.generated.services.models.fixed_slot_capacity_query import FixedSlotCapacityQuery
from py_sp_api.generated.services.models.get_appointment_slots_response import GetAppointmentSlotsResponse
from py_sp_api.generated.services.models.get_service_job_by_service_job_id_response import GetServiceJobByServiceJobIdResponse
from py_sp_api.generated.services.models.get_service_jobs_response import GetServiceJobsResponse
from py_sp_api.generated.services.models.range_slot_capacity import RangeSlotCapacity
from py_sp_api.generated.services.models.range_slot_capacity_query import RangeSlotCapacityQuery
from py_sp_api.generated.services.models.reschedule_appointment_request import RescheduleAppointmentRequest
from py_sp_api.generated.services.models.service_upload_document import ServiceUploadDocument
from py_sp_api.generated.services.models.set_appointment_fulfillment_data_request import SetAppointmentFulfillmentDataRequest
from py_sp_api.generated.services.models.set_appointment_response import SetAppointmentResponse
from py_sp_api.generated.services.models.update_reservation_request import UpdateReservationRequest
from py_sp_api.generated.services.models.update_reservation_response import UpdateReservationResponse
from py_sp_api.generated.services.models.update_schedule_request import UpdateScheduleRequest
from py_sp_api.generated.services.models.update_schedule_response import UpdateScheduleResponse

from py_sp_api.generated.services.api_client import ApiClient, RequestSerialized
from py_sp_api.generated.services.api_response import ApiResponse
from py_sp_api.generated.services.rest import RESTResponseType


class ServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_appointment_for_service_job_by_service_job_id(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        body: Annotated[AddAppointmentRequest, Field(description="Add appointment operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SetAppointmentResponse:
        """add_appointment_for_service_job_by_service_job_id

        Adds an appointment to the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param body: Add appointment operation input details. (required)
        :type body: AddAppointmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_appointment_for_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetAppointmentResponse",
            '400': "SetAppointmentResponse",
            '403': "SetAppointmentResponse",
            '404': "SetAppointmentResponse",
            '413': "SetAppointmentResponse",
            '415': "SetAppointmentResponse",
            '422': "SetAppointmentResponse",
            '429': "SetAppointmentResponse",
            '500': "SetAppointmentResponse",
            '503': "SetAppointmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_appointment_for_service_job_by_service_job_id_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        body: Annotated[AddAppointmentRequest, Field(description="Add appointment operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SetAppointmentResponse]:
        """add_appointment_for_service_job_by_service_job_id

        Adds an appointment to the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param body: Add appointment operation input details. (required)
        :type body: AddAppointmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_appointment_for_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetAppointmentResponse",
            '400': "SetAppointmentResponse",
            '403': "SetAppointmentResponse",
            '404': "SetAppointmentResponse",
            '413': "SetAppointmentResponse",
            '415': "SetAppointmentResponse",
            '422': "SetAppointmentResponse",
            '429': "SetAppointmentResponse",
            '500': "SetAppointmentResponse",
            '503': "SetAppointmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_appointment_for_service_job_by_service_job_id_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        body: Annotated[AddAppointmentRequest, Field(description="Add appointment operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """add_appointment_for_service_job_by_service_job_id

        Adds an appointment to the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param body: Add appointment operation input details. (required)
        :type body: AddAppointmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_appointment_for_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetAppointmentResponse",
            '400': "SetAppointmentResponse",
            '403': "SetAppointmentResponse",
            '404': "SetAppointmentResponse",
            '413': "SetAppointmentResponse",
            '415': "SetAppointmentResponse",
            '422': "SetAppointmentResponse",
            '429': "SetAppointmentResponse",
            '500': "SetAppointmentResponse",
            '503': "SetAppointmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_appointment_for_service_job_by_service_job_id_serialize(
        self,
        service_job_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/service/v1/serviceJobs/{serviceJobId}/appointments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def assign_appointment_resources(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined identifier of active service job appointment.")],
        body: AssignAppointmentResourcesRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AssignAppointmentResourcesResponse:
        """assign_appointment_resources

        Assigns new resource(s) or overwrite/update the existing one(s) to a service job appointment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API. (required)
        :type service_job_id: str
        :param appointment_id: An Amazon-defined identifier of active service job appointment. (required)
        :type appointment_id: str
        :param body: (required)
        :type body: AssignAppointmentResourcesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._assign_appointment_resources_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssignAppointmentResourcesResponse",
            '400': "AssignAppointmentResourcesResponse",
            '403': "AssignAppointmentResourcesResponse",
            '404': "AssignAppointmentResourcesResponse",
            '413': "AssignAppointmentResourcesResponse",
            '415': "AssignAppointmentResourcesResponse",
            '422': "AssignAppointmentResourcesResponse",
            '429': "AssignAppointmentResourcesResponse",
            '500': "AssignAppointmentResourcesResponse",
            '503': "AssignAppointmentResourcesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def assign_appointment_resources_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined identifier of active service job appointment.")],
        body: AssignAppointmentResourcesRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AssignAppointmentResourcesResponse]:
        """assign_appointment_resources

        Assigns new resource(s) or overwrite/update the existing one(s) to a service job appointment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API. (required)
        :type service_job_id: str
        :param appointment_id: An Amazon-defined identifier of active service job appointment. (required)
        :type appointment_id: str
        :param body: (required)
        :type body: AssignAppointmentResourcesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._assign_appointment_resources_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssignAppointmentResourcesResponse",
            '400': "AssignAppointmentResourcesResponse",
            '403': "AssignAppointmentResourcesResponse",
            '404': "AssignAppointmentResourcesResponse",
            '413': "AssignAppointmentResourcesResponse",
            '415': "AssignAppointmentResourcesResponse",
            '422': "AssignAppointmentResourcesResponse",
            '429': "AssignAppointmentResourcesResponse",
            '500': "AssignAppointmentResourcesResponse",
            '503': "AssignAppointmentResourcesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def assign_appointment_resources_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined identifier of active service job appointment.")],
        body: AssignAppointmentResourcesRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """assign_appointment_resources

        Assigns new resource(s) or overwrite/update the existing one(s) to a service job appointment.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 1 | 2 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API. (required)
        :type service_job_id: str
        :param appointment_id: An Amazon-defined identifier of active service job appointment. (required)
        :type appointment_id: str
        :param body: (required)
        :type body: AssignAppointmentResourcesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._assign_appointment_resources_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssignAppointmentResourcesResponse",
            '400': "AssignAppointmentResourcesResponse",
            '403': "AssignAppointmentResourcesResponse",
            '404': "AssignAppointmentResourcesResponse",
            '413': "AssignAppointmentResourcesResponse",
            '415': "AssignAppointmentResourcesResponse",
            '422': "AssignAppointmentResourcesResponse",
            '429': "AssignAppointmentResourcesResponse",
            '500': "AssignAppointmentResourcesResponse",
            '503': "AssignAppointmentResourcesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _assign_appointment_resources_serialize(
        self,
        service_job_id,
        appointment_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        if appointment_id is not None:
            _path_params['appointmentId'] = appointment_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/service/v1/serviceJobs/{serviceJobId}/appointments/{appointmentId}/resources',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cancel_reservation(
        self,
        reservation_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Reservation Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CancelReservationResponse:
        """cancel_reservation

        Cancel a reservation.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param reservation_id: Reservation Identifier (required)
        :type reservation_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_reservation_serialize(
            reservation_id=reservation_id,
            marketplace_ids=marketplace_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "CancelReservationResponse",
            '400': "CancelReservationResponse",
            '403': "CancelReservationResponse",
            '404': "CancelReservationResponse",
            '413': "CancelReservationResponse",
            '415': "CancelReservationResponse",
            '429': "CancelReservationResponse",
            '500': "CancelReservationResponse",
            '503': "CancelReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_reservation_with_http_info(
        self,
        reservation_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Reservation Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CancelReservationResponse]:
        """cancel_reservation

        Cancel a reservation.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param reservation_id: Reservation Identifier (required)
        :type reservation_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_reservation_serialize(
            reservation_id=reservation_id,
            marketplace_ids=marketplace_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "CancelReservationResponse",
            '400': "CancelReservationResponse",
            '403': "CancelReservationResponse",
            '404': "CancelReservationResponse",
            '413': "CancelReservationResponse",
            '415': "CancelReservationResponse",
            '429': "CancelReservationResponse",
            '500': "CancelReservationResponse",
            '503': "CancelReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_reservation_without_preload_content(
        self,
        reservation_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Reservation Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cancel_reservation

        Cancel a reservation.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param reservation_id: Reservation Identifier (required)
        :type reservation_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_reservation_serialize(
            reservation_id=reservation_id,
            marketplace_ids=marketplace_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "CancelReservationResponse",
            '400': "CancelReservationResponse",
            '403': "CancelReservationResponse",
            '404': "CancelReservationResponse",
            '413': "CancelReservationResponse",
            '415': "CancelReservationResponse",
            '429': "CancelReservationResponse",
            '500': "CancelReservationResponse",
            '503': "CancelReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_reservation_serialize(
        self,
        reservation_id,
        marketplace_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if reservation_id is not None:
            _path_params['reservationId'] = reservation_id
        # process the query parameters
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/service/v1/reservation/{reservationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cancel_service_job_by_service_job_id(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        cancellation_reason_code: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A cancel reason code that specifies the reason for cancelling a service job.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CancelServiceJobByServiceJobIdResponse:
        """cancel_service_job_by_service_job_id

        Cancels the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param cancellation_reason_code: A cancel reason code that specifies the reason for cancelling a service job. (required)
        :type cancellation_reason_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            cancellation_reason_code=cancellation_reason_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelServiceJobByServiceJobIdResponse",
            '400': "CancelServiceJobByServiceJobIdResponse",
            '403': "CancelServiceJobByServiceJobIdResponse",
            '404': "CancelServiceJobByServiceJobIdResponse",
            '413': "CancelServiceJobByServiceJobIdResponse",
            '415': "CancelServiceJobByServiceJobIdResponse",
            '422': "CancelServiceJobByServiceJobIdResponse",
            '429': "CancelServiceJobByServiceJobIdResponse",
            '500': "CancelServiceJobByServiceJobIdResponse",
            '503': "CancelServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_service_job_by_service_job_id_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        cancellation_reason_code: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A cancel reason code that specifies the reason for cancelling a service job.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CancelServiceJobByServiceJobIdResponse]:
        """cancel_service_job_by_service_job_id

        Cancels the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param cancellation_reason_code: A cancel reason code that specifies the reason for cancelling a service job. (required)
        :type cancellation_reason_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            cancellation_reason_code=cancellation_reason_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelServiceJobByServiceJobIdResponse",
            '400': "CancelServiceJobByServiceJobIdResponse",
            '403': "CancelServiceJobByServiceJobIdResponse",
            '404': "CancelServiceJobByServiceJobIdResponse",
            '413': "CancelServiceJobByServiceJobIdResponse",
            '415': "CancelServiceJobByServiceJobIdResponse",
            '422': "CancelServiceJobByServiceJobIdResponse",
            '429': "CancelServiceJobByServiceJobIdResponse",
            '500': "CancelServiceJobByServiceJobIdResponse",
            '503': "CancelServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_service_job_by_service_job_id_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        cancellation_reason_code: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A cancel reason code that specifies the reason for cancelling a service job.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cancel_service_job_by_service_job_id

        Cancels the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param cancellation_reason_code: A cancel reason code that specifies the reason for cancelling a service job. (required)
        :type cancellation_reason_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            cancellation_reason_code=cancellation_reason_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelServiceJobByServiceJobIdResponse",
            '400': "CancelServiceJobByServiceJobIdResponse",
            '403': "CancelServiceJobByServiceJobIdResponse",
            '404': "CancelServiceJobByServiceJobIdResponse",
            '413': "CancelServiceJobByServiceJobIdResponse",
            '415': "CancelServiceJobByServiceJobIdResponse",
            '422': "CancelServiceJobByServiceJobIdResponse",
            '429': "CancelServiceJobByServiceJobIdResponse",
            '500': "CancelServiceJobByServiceJobIdResponse",
            '503': "CancelServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_service_job_by_service_job_id_serialize(
        self,
        service_job_id,
        cancellation_reason_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        # process the query parameters
        if cancellation_reason_code is not None:
            
            _query_params.append(('cancellationReasonCode', cancellation_reason_code))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/service/v1/serviceJobs/{serviceJobId}/cancellations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def complete_service_job_by_service_job_id(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CompleteServiceJobByServiceJobIdResponse:
        """complete_service_job_by_service_job_id

        Completes the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompleteServiceJobByServiceJobIdResponse",
            '400': "CompleteServiceJobByServiceJobIdResponse",
            '403': "CompleteServiceJobByServiceJobIdResponse",
            '404': "CompleteServiceJobByServiceJobIdResponse",
            '413': "CompleteServiceJobByServiceJobIdResponse",
            '415': "CompleteServiceJobByServiceJobIdResponse",
            '422': "CompleteServiceJobByServiceJobIdResponse",
            '429': "CompleteServiceJobByServiceJobIdResponse",
            '500': "CompleteServiceJobByServiceJobIdResponse",
            '503': "CompleteServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def complete_service_job_by_service_job_id_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CompleteServiceJobByServiceJobIdResponse]:
        """complete_service_job_by_service_job_id

        Completes the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompleteServiceJobByServiceJobIdResponse",
            '400': "CompleteServiceJobByServiceJobIdResponse",
            '403': "CompleteServiceJobByServiceJobIdResponse",
            '404': "CompleteServiceJobByServiceJobIdResponse",
            '413': "CompleteServiceJobByServiceJobIdResponse",
            '415': "CompleteServiceJobByServiceJobIdResponse",
            '422': "CompleteServiceJobByServiceJobIdResponse",
            '429': "CompleteServiceJobByServiceJobIdResponse",
            '500': "CompleteServiceJobByServiceJobIdResponse",
            '503': "CompleteServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def complete_service_job_by_service_job_id_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """complete_service_job_by_service_job_id

        Completes the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompleteServiceJobByServiceJobIdResponse",
            '400': "CompleteServiceJobByServiceJobIdResponse",
            '403': "CompleteServiceJobByServiceJobIdResponse",
            '404': "CompleteServiceJobByServiceJobIdResponse",
            '413': "CompleteServiceJobByServiceJobIdResponse",
            '415': "CompleteServiceJobByServiceJobIdResponse",
            '422': "CompleteServiceJobByServiceJobIdResponse",
            '429': "CompleteServiceJobByServiceJobIdResponse",
            '500': "CompleteServiceJobByServiceJobIdResponse",
            '503': "CompleteServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _complete_service_job_by_service_job_id_serialize(
        self,
        service_job_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/service/v1/serviceJobs/{serviceJobId}/completions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_reservation(
        self,
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[CreateReservationRequest, Field(description="Reservation details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateReservationResponse:
        """create_reservation

        Create a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Reservation details (required)
        :type body: CreateReservationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_reservation_serialize(
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateReservationResponse",
            '400': "CreateReservationResponse",
            '403': "CreateReservationResponse",
            '404': "CreateReservationResponse",
            '413': "CreateReservationResponse",
            '415': "CreateReservationResponse",
            '429': "CreateReservationResponse",
            '500': "CreateReservationResponse",
            '503': "CreateReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_reservation_with_http_info(
        self,
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[CreateReservationRequest, Field(description="Reservation details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateReservationResponse]:
        """create_reservation

        Create a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Reservation details (required)
        :type body: CreateReservationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_reservation_serialize(
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateReservationResponse",
            '400': "CreateReservationResponse",
            '403': "CreateReservationResponse",
            '404': "CreateReservationResponse",
            '413': "CreateReservationResponse",
            '415': "CreateReservationResponse",
            '429': "CreateReservationResponse",
            '500': "CreateReservationResponse",
            '503': "CreateReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_reservation_without_preload_content(
        self,
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[CreateReservationRequest, Field(description="Reservation details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """create_reservation

        Create a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Reservation details (required)
        :type body: CreateReservationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_reservation_serialize(
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateReservationResponse",
            '400': "CreateReservationResponse",
            '403': "CreateReservationResponse",
            '404': "CreateReservationResponse",
            '413': "CreateReservationResponse",
            '415': "CreateReservationResponse",
            '429': "CreateReservationResponse",
            '500': "CreateReservationResponse",
            '503': "CreateReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_reservation_serialize(
        self,
        marketplace_ids,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/service/v1/reservation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_service_document_upload_destination(
        self,
        body: Annotated[ServiceUploadDocument, Field(description="Upload document operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateServiceDocumentUploadDestination:
        """create_service_document_upload_destination

        Creates an upload destination.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param body: Upload document operation input details. (required)
        :type body: ServiceUploadDocument
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_service_document_upload_destination_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateServiceDocumentUploadDestination",
            '400': "CreateServiceDocumentUploadDestination",
            '403': "CreateServiceDocumentUploadDestination",
            '404': "CreateServiceDocumentUploadDestination",
            '413': "CreateServiceDocumentUploadDestination",
            '415': "CreateServiceDocumentUploadDestination",
            '422': "CreateServiceDocumentUploadDestination",
            '429': "CreateServiceDocumentUploadDestination",
            '500': "CreateServiceDocumentUploadDestination",
            '503': "CreateServiceDocumentUploadDestination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_service_document_upload_destination_with_http_info(
        self,
        body: Annotated[ServiceUploadDocument, Field(description="Upload document operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateServiceDocumentUploadDestination]:
        """create_service_document_upload_destination

        Creates an upload destination.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param body: Upload document operation input details. (required)
        :type body: ServiceUploadDocument
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_service_document_upload_destination_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateServiceDocumentUploadDestination",
            '400': "CreateServiceDocumentUploadDestination",
            '403': "CreateServiceDocumentUploadDestination",
            '404': "CreateServiceDocumentUploadDestination",
            '413': "CreateServiceDocumentUploadDestination",
            '415': "CreateServiceDocumentUploadDestination",
            '422': "CreateServiceDocumentUploadDestination",
            '429': "CreateServiceDocumentUploadDestination",
            '500': "CreateServiceDocumentUploadDestination",
            '503': "CreateServiceDocumentUploadDestination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_service_document_upload_destination_without_preload_content(
        self,
        body: Annotated[ServiceUploadDocument, Field(description="Upload document operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """create_service_document_upload_destination

        Creates an upload destination.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param body: Upload document operation input details. (required)
        :type body: ServiceUploadDocument
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_service_document_upload_destination_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateServiceDocumentUploadDestination",
            '400': "CreateServiceDocumentUploadDestination",
            '403': "CreateServiceDocumentUploadDestination",
            '404': "CreateServiceDocumentUploadDestination",
            '413': "CreateServiceDocumentUploadDestination",
            '415': "CreateServiceDocumentUploadDestination",
            '422': "CreateServiceDocumentUploadDestination",
            '429': "CreateServiceDocumentUploadDestination",
            '500': "CreateServiceDocumentUploadDestination",
            '503': "CreateServiceDocumentUploadDestination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_service_document_upload_destination_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/service/v1/documents',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_appointment_slots(
        self,
        asin: Annotated[StrictStr, Field(description="ASIN associated with the service.")],
        store_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Store identifier defining the region scope to retrive appointment slots.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace for which appointment slots are queried")],
        start_time: Annotated[Optional[StrictStr], Field(description="A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAppointmentSlotsResponse:
        """get_appointment_slots

        Gets appointment slots as per the service context specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param asin: ASIN associated with the service. (required)
        :type asin: str
        :param store_id: Store identifier defining the region scope to retrive appointment slots. (required)
        :type store_id: str
        :param marketplace_ids: An identifier for the marketplace for which appointment slots are queried (required)
        :type marketplace_ids: List[str]
        :param start_time: A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
        :type start_time: str
        :param end_time: A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_appointment_slots_serialize(
            asin=asin,
            store_id=store_id,
            marketplace_ids=marketplace_ids,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAppointmentSlotsResponse",
            '400': "GetAppointmentSlotsResponse",
            '403': "GetAppointmentSlotsResponse",
            '404': "GetAppointmentSlotsResponse",
            '415': "GetAppointmentSlotsResponse",
            '422': "GetAppointmentSlotsResponse",
            '429': "GetAppointmentSlotsResponse",
            '500': "GetAppointmentSlotsResponse",
            '503': "GetAppointmentSlotsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_appointment_slots_with_http_info(
        self,
        asin: Annotated[StrictStr, Field(description="ASIN associated with the service.")],
        store_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Store identifier defining the region scope to retrive appointment slots.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace for which appointment slots are queried")],
        start_time: Annotated[Optional[StrictStr], Field(description="A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAppointmentSlotsResponse]:
        """get_appointment_slots

        Gets appointment slots as per the service context specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param asin: ASIN associated with the service. (required)
        :type asin: str
        :param store_id: Store identifier defining the region scope to retrive appointment slots. (required)
        :type store_id: str
        :param marketplace_ids: An identifier for the marketplace for which appointment slots are queried (required)
        :type marketplace_ids: List[str]
        :param start_time: A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
        :type start_time: str
        :param end_time: A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_appointment_slots_serialize(
            asin=asin,
            store_id=store_id,
            marketplace_ids=marketplace_ids,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAppointmentSlotsResponse",
            '400': "GetAppointmentSlotsResponse",
            '403': "GetAppointmentSlotsResponse",
            '404': "GetAppointmentSlotsResponse",
            '415': "GetAppointmentSlotsResponse",
            '422': "GetAppointmentSlotsResponse",
            '429': "GetAppointmentSlotsResponse",
            '500': "GetAppointmentSlotsResponse",
            '503': "GetAppointmentSlotsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_appointment_slots_without_preload_content(
        self,
        asin: Annotated[StrictStr, Field(description="ASIN associated with the service.")],
        store_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Store identifier defining the region scope to retrive appointment slots.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace for which appointment slots are queried")],
        start_time: Annotated[Optional[StrictStr], Field(description="A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_appointment_slots

        Gets appointment slots as per the service context specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param asin: ASIN associated with the service. (required)
        :type asin: str
        :param store_id: Store identifier defining the region scope to retrive appointment slots. (required)
        :type store_id: str
        :param marketplace_ids: An identifier for the marketplace for which appointment slots are queried (required)
        :type marketplace_ids: List[str]
        :param start_time: A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
        :type start_time: str
        :param end_time: A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_appointment_slots_serialize(
            asin=asin,
            store_id=store_id,
            marketplace_ids=marketplace_ids,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAppointmentSlotsResponse",
            '400': "GetAppointmentSlotsResponse",
            '403': "GetAppointmentSlotsResponse",
            '404': "GetAppointmentSlotsResponse",
            '415': "GetAppointmentSlotsResponse",
            '422': "GetAppointmentSlotsResponse",
            '429': "GetAppointmentSlotsResponse",
            '500': "GetAppointmentSlotsResponse",
            '503': "GetAppointmentSlotsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_appointment_slots_serialize(
        self,
        asin,
        store_id,
        marketplace_ids,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if asin is not None:
            
            _query_params.append(('asin', asin))
            
        if store_id is not None:
            
            _query_params.append(('storeId', store_id))
            
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/service/v1/appointmentSlots',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_appointmment_slots_by_job_id(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A service job identifier to retrive appointment slots for associated service.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        start_time: Annotated[Optional[StrictStr], Field(description="A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAppointmentSlotsResponse:
        """get_appointmment_slots_by_job_id

        Gets appointment slots for the service associated with the service job id specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: A service job identifier to retrive appointment slots for associated service. (required)
        :type service_job_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param start_time: A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
        :type start_time: str
        :param end_time: A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_appointmment_slots_by_job_id_serialize(
            service_job_id=service_job_id,
            marketplace_ids=marketplace_ids,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAppointmentSlotsResponse",
            '400': "GetAppointmentSlotsResponse",
            '403': "GetAppointmentSlotsResponse",
            '404': "GetAppointmentSlotsResponse",
            '415': "GetAppointmentSlotsResponse",
            '422': "GetAppointmentSlotsResponse",
            '429': "GetAppointmentSlotsResponse",
            '500': "GetAppointmentSlotsResponse",
            '503': "GetAppointmentSlotsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_appointmment_slots_by_job_id_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A service job identifier to retrive appointment slots for associated service.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        start_time: Annotated[Optional[StrictStr], Field(description="A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAppointmentSlotsResponse]:
        """get_appointmment_slots_by_job_id

        Gets appointment slots for the service associated with the service job id specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: A service job identifier to retrive appointment slots for associated service. (required)
        :type service_job_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param start_time: A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
        :type start_time: str
        :param end_time: A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_appointmment_slots_by_job_id_serialize(
            service_job_id=service_job_id,
            marketplace_ids=marketplace_ids,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAppointmentSlotsResponse",
            '400': "GetAppointmentSlotsResponse",
            '403': "GetAppointmentSlotsResponse",
            '404': "GetAppointmentSlotsResponse",
            '415': "GetAppointmentSlotsResponse",
            '422': "GetAppointmentSlotsResponse",
            '429': "GetAppointmentSlotsResponse",
            '500': "GetAppointmentSlotsResponse",
            '503': "GetAppointmentSlotsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_appointmment_slots_by_job_id_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A service job identifier to retrive appointment slots for associated service.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        start_time: Annotated[Optional[StrictStr], Field(description="A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_appointmment_slots_by_job_id

        Gets appointment slots for the service associated with the service job id specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: A service job identifier to retrive appointment slots for associated service. (required)
        :type service_job_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param start_time: A time from which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `startTime` is provided, `endTime` should also be provided. Default value is as per business configuration.
        :type start_time: str
        :param end_time: A time up to which the appointment slots will be retrieved. The specified time must be in ISO 8601 format. If `endTime` is provided, `startTime` should also be provided. Default value is as per business configuration. Maximum range of appointment slots can be 90 days.
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_appointmment_slots_by_job_id_serialize(
            service_job_id=service_job_id,
            marketplace_ids=marketplace_ids,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetAppointmentSlotsResponse",
            '400': "GetAppointmentSlotsResponse",
            '403': "GetAppointmentSlotsResponse",
            '404': "GetAppointmentSlotsResponse",
            '415': "GetAppointmentSlotsResponse",
            '422': "GetAppointmentSlotsResponse",
            '429': "GetAppointmentSlotsResponse",
            '500': "GetAppointmentSlotsResponse",
            '503': "GetAppointmentSlotsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_appointmment_slots_by_job_id_serialize(
        self,
        service_job_id,
        marketplace_ids,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        # process the query parameters
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/service/v1/serviceJobs/{serviceJobId}/appointmentSlots',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fixed_slot_capacity(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource Identifier.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[FixedSlotCapacityQuery, Field(description="Request body.")],
        next_page_token: Annotated[Optional[StrictStr], Field(description="Next page token returned in the response of your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FixedSlotCapacity:
        """get_fixed_slot_capacity

        Provides capacity in fixed-size slots.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource Identifier. (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Request body. (required)
        :type body: FixedSlotCapacityQuery
        :param next_page_token: Next page token returned in the response of your previous request.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fixed_slot_capacity_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FixedSlotCapacity",
            '400': "FixedSlotCapacityErrors",
            '401': "FixedSlotCapacityErrors",
            '403': "FixedSlotCapacityErrors",
            '404': "FixedSlotCapacityErrors",
            '413': "FixedSlotCapacityErrors",
            '415': "FixedSlotCapacityErrors",
            '429': "FixedSlotCapacityErrors",
            '500': "FixedSlotCapacityErrors",
            '503': "FixedSlotCapacityErrors",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fixed_slot_capacity_with_http_info(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource Identifier.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[FixedSlotCapacityQuery, Field(description="Request body.")],
        next_page_token: Annotated[Optional[StrictStr], Field(description="Next page token returned in the response of your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FixedSlotCapacity]:
        """get_fixed_slot_capacity

        Provides capacity in fixed-size slots.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource Identifier. (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Request body. (required)
        :type body: FixedSlotCapacityQuery
        :param next_page_token: Next page token returned in the response of your previous request.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fixed_slot_capacity_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FixedSlotCapacity",
            '400': "FixedSlotCapacityErrors",
            '401': "FixedSlotCapacityErrors",
            '403': "FixedSlotCapacityErrors",
            '404': "FixedSlotCapacityErrors",
            '413': "FixedSlotCapacityErrors",
            '415': "FixedSlotCapacityErrors",
            '429': "FixedSlotCapacityErrors",
            '500': "FixedSlotCapacityErrors",
            '503': "FixedSlotCapacityErrors",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fixed_slot_capacity_without_preload_content(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource Identifier.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[FixedSlotCapacityQuery, Field(description="Request body.")],
        next_page_token: Annotated[Optional[StrictStr], Field(description="Next page token returned in the response of your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_fixed_slot_capacity

        Provides capacity in fixed-size slots.   **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource Identifier. (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Request body. (required)
        :type body: FixedSlotCapacityQuery
        :param next_page_token: Next page token returned in the response of your previous request.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fixed_slot_capacity_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FixedSlotCapacity",
            '400': "FixedSlotCapacityErrors",
            '401': "FixedSlotCapacityErrors",
            '403': "FixedSlotCapacityErrors",
            '404': "FixedSlotCapacityErrors",
            '413': "FixedSlotCapacityErrors",
            '415': "FixedSlotCapacityErrors",
            '429': "FixedSlotCapacityErrors",
            '500': "FixedSlotCapacityErrors",
            '503': "FixedSlotCapacityErrors",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fixed_slot_capacity_serialize(
        self,
        resource_id,
        marketplace_ids,
        body,
        next_page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resourceId'] = resource_id
        # process the query parameters
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        if next_page_token is not None:
            
            _query_params.append(('nextPageToken', next_page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/service/v1/serviceResources/{resourceId}/capacity/fixed',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_range_slot_capacity(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource Identifier.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[RangeSlotCapacityQuery, Field(description="Request body.")],
        next_page_token: Annotated[Optional[StrictStr], Field(description="Next page token returned in the response of your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RangeSlotCapacity:
        """get_range_slot_capacity

        Provides capacity slots in a format similar to availability records.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource Identifier. (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Request body. (required)
        :type body: RangeSlotCapacityQuery
        :param next_page_token: Next page token returned in the response of your previous request.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_range_slot_capacity_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RangeSlotCapacity",
            '400': "RangeSlotCapacityErrors",
            '401': "RangeSlotCapacityErrors",
            '403': "RangeSlotCapacityErrors",
            '404': "RangeSlotCapacityErrors",
            '413': "RangeSlotCapacityErrors",
            '415': "RangeSlotCapacityErrors",
            '429': "RangeSlotCapacityErrors",
            '500': "RangeSlotCapacityErrors",
            '503': "RangeSlotCapacityErrors",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_range_slot_capacity_with_http_info(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource Identifier.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[RangeSlotCapacityQuery, Field(description="Request body.")],
        next_page_token: Annotated[Optional[StrictStr], Field(description="Next page token returned in the response of your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RangeSlotCapacity]:
        """get_range_slot_capacity

        Provides capacity slots in a format similar to availability records.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource Identifier. (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Request body. (required)
        :type body: RangeSlotCapacityQuery
        :param next_page_token: Next page token returned in the response of your previous request.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_range_slot_capacity_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RangeSlotCapacity",
            '400': "RangeSlotCapacityErrors",
            '401': "RangeSlotCapacityErrors",
            '403': "RangeSlotCapacityErrors",
            '404': "RangeSlotCapacityErrors",
            '413': "RangeSlotCapacityErrors",
            '415': "RangeSlotCapacityErrors",
            '429': "RangeSlotCapacityErrors",
            '500': "RangeSlotCapacityErrors",
            '503': "RangeSlotCapacityErrors",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_range_slot_capacity_without_preload_content(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource Identifier.")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[RangeSlotCapacityQuery, Field(description="Request body.")],
        next_page_token: Annotated[Optional[StrictStr], Field(description="Next page token returned in the response of your previous request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_range_slot_capacity

        Provides capacity slots in a format similar to availability records.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource Identifier. (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Request body. (required)
        :type body: RangeSlotCapacityQuery
        :param next_page_token: Next page token returned in the response of your previous request.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_range_slot_capacity_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RangeSlotCapacity",
            '400': "RangeSlotCapacityErrors",
            '401': "RangeSlotCapacityErrors",
            '403': "RangeSlotCapacityErrors",
            '404': "RangeSlotCapacityErrors",
            '413': "RangeSlotCapacityErrors",
            '415': "RangeSlotCapacityErrors",
            '429': "RangeSlotCapacityErrors",
            '500': "RangeSlotCapacityErrors",
            '503': "RangeSlotCapacityErrors",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_range_slot_capacity_serialize(
        self,
        resource_id,
        marketplace_ids,
        body,
        next_page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resourceId'] = resource_id
        # process the query parameters
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        if next_page_token is not None:
            
            _query_params.append(('nextPageToken', next_page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/service/v1/serviceResources/{resourceId}/capacity/range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_service_job_by_service_job_id(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A service job identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetServiceJobByServiceJobIdResponse:
        """get_service_job_by_service_job_id

        Gets details of service job indicated by the provided `serviceJobID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: A service job identifier. (required)
        :type service_job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetServiceJobByServiceJobIdResponse",
            '400': "GetServiceJobByServiceJobIdResponse",
            '403': "GetServiceJobByServiceJobIdResponse",
            '404': "GetServiceJobByServiceJobIdResponse",
            '413': "GetServiceJobByServiceJobIdResponse",
            '415': "GetServiceJobByServiceJobIdResponse",
            '422': "GetServiceJobByServiceJobIdResponse",
            '429': "GetServiceJobByServiceJobIdResponse",
            '500': "GetServiceJobByServiceJobIdResponse",
            '503': "GetServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_service_job_by_service_job_id_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A service job identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetServiceJobByServiceJobIdResponse]:
        """get_service_job_by_service_job_id

        Gets details of service job indicated by the provided `serviceJobID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: A service job identifier. (required)
        :type service_job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetServiceJobByServiceJobIdResponse",
            '400': "GetServiceJobByServiceJobIdResponse",
            '403': "GetServiceJobByServiceJobIdResponse",
            '404': "GetServiceJobByServiceJobIdResponse",
            '413': "GetServiceJobByServiceJobIdResponse",
            '415': "GetServiceJobByServiceJobIdResponse",
            '422': "GetServiceJobByServiceJobIdResponse",
            '429': "GetServiceJobByServiceJobIdResponse",
            '500': "GetServiceJobByServiceJobIdResponse",
            '503': "GetServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_service_job_by_service_job_id_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="A service job identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_service_job_by_service_job_id

        Gets details of service job indicated by the provided `serviceJobID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 20 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: A service job identifier. (required)
        :type service_job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetServiceJobByServiceJobIdResponse",
            '400': "GetServiceJobByServiceJobIdResponse",
            '403': "GetServiceJobByServiceJobIdResponse",
            '404': "GetServiceJobByServiceJobIdResponse",
            '413': "GetServiceJobByServiceJobIdResponse",
            '415': "GetServiceJobByServiceJobIdResponse",
            '422': "GetServiceJobByServiceJobIdResponse",
            '429': "GetServiceJobByServiceJobIdResponse",
            '500': "GetServiceJobByServiceJobIdResponse",
            '503': "GetServiceJobByServiceJobIdResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_service_job_by_service_job_id_serialize(
        self,
        service_job_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/service/v1/serviceJobs/{serviceJobId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_service_jobs(
        self,
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="Used to select jobs that were placed in the specified marketplaces.")],
        service_order_ids: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1, max_length=20)]], Field(description="List of service order ids for the query you want to perform.Max values supported 20.")] = None,
        service_job_status: Annotated[Optional[List[StrictStr]], Field(description="A list of one or more job status by which to filter the list of jobs.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="String returned in the response of your previous request.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=20, strict=True, ge=1)]], Field(description="A non-negative integer that indicates the maximum number of jobs to return in the list, Value must be 1 - 20. Default 20.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Sort fields on which you want to sort the output.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort order for the query you want to perform.")] = None,
        created_after: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs created at or after a specified time. Must be in ISO 8601 format. Required if `LastUpdatedAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.")] = None,
        created_before: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs created at or before a specified time. Must be in ISO 8601 format.")] = None,
        last_updated_after: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs updated at or after a specified time. Must be in ISO 8601 format. Required if `createdAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.")] = None,
        last_updated_before: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs updated at or before a specified time. Must be in ISO 8601 format.")] = None,
        schedule_start_date: Annotated[Optional[StrictStr], Field(description="A date used for filtering jobs schedules at or after a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.")] = None,
        schedule_end_date: Annotated[Optional[StrictStr], Field(description="A date used for filtering jobs schedules at or before a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.")] = None,
        asins: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=10, strict=True, max_length=10)]], Field(min_length=1, max_length=20)]], Field(description="List of Amazon Standard Identification Numbers (ASIN) of the items. Max values supported is 20.")] = None,
        required_skills: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=1, strict=True, max_length=50)]], Field(min_length=1, max_length=20)]], Field(description="A defined set of related knowledge, skills, experience, tools, materials, and work processes common to service delivery for a set of products and/or service scenarios. Max values supported is 20.")] = None,
        store_ids: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=1, strict=True, max_length=100)]], Field(min_length=1, max_length=50)]], Field(description="List of Amazon-defined identifiers for the region scope. Max values supported is 50.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetServiceJobsResponse:
        """get_service_jobs

        Gets service job details for the specified filter query.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param marketplace_ids: Used to select jobs that were placed in the specified marketplaces. (required)
        :type marketplace_ids: List[str]
        :param service_order_ids: List of service order ids for the query you want to perform.Max values supported 20.
        :type service_order_ids: List[str]
        :param service_job_status: A list of one or more job status by which to filter the list of jobs.
        :type service_job_status: List[str]
        :param page_token: String returned in the response of your previous request.
        :type page_token: str
        :param page_size: A non-negative integer that indicates the maximum number of jobs to return in the list, Value must be 1 - 20. Default 20.
        :type page_size: int
        :param sort_field: Sort fields on which you want to sort the output.
        :type sort_field: str
        :param sort_order: Sort order for the query you want to perform.
        :type sort_order: str
        :param created_after: A date used for selecting jobs created at or after a specified time. Must be in ISO 8601 format. Required if `LastUpdatedAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
        :type created_after: str
        :param created_before: A date used for selecting jobs created at or before a specified time. Must be in ISO 8601 format.
        :type created_before: str
        :param last_updated_after: A date used for selecting jobs updated at or after a specified time. Must be in ISO 8601 format. Required if `createdAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
        :type last_updated_after: str
        :param last_updated_before: A date used for selecting jobs updated at or before a specified time. Must be in ISO 8601 format.
        :type last_updated_before: str
        :param schedule_start_date: A date used for filtering jobs schedules at or after a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
        :type schedule_start_date: str
        :param schedule_end_date: A date used for filtering jobs schedules at or before a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
        :type schedule_end_date: str
        :param asins: List of Amazon Standard Identification Numbers (ASIN) of the items. Max values supported is 20.
        :type asins: List[str]
        :param required_skills: A defined set of related knowledge, skills, experience, tools, materials, and work processes common to service delivery for a set of products and/or service scenarios. Max values supported is 20.
        :type required_skills: List[str]
        :param store_ids: List of Amazon-defined identifiers for the region scope. Max values supported is 50.
        :type store_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_service_jobs_serialize(
            marketplace_ids=marketplace_ids,
            service_order_ids=service_order_ids,
            service_job_status=service_job_status,
            page_token=page_token,
            page_size=page_size,
            sort_field=sort_field,
            sort_order=sort_order,
            created_after=created_after,
            created_before=created_before,
            last_updated_after=last_updated_after,
            last_updated_before=last_updated_before,
            schedule_start_date=schedule_start_date,
            schedule_end_date=schedule_end_date,
            asins=asins,
            required_skills=required_skills,
            store_ids=store_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetServiceJobsResponse",
            '400': "GetServiceJobsResponse",
            '403': "GetServiceJobsResponse",
            '404': "GetServiceJobsResponse",
            '413': "GetServiceJobsResponse",
            '415': "GetServiceJobsResponse",
            '429': "GetServiceJobsResponse",
            '500': "GetServiceJobsResponse",
            '503': "GetServiceJobsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_service_jobs_with_http_info(
        self,
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="Used to select jobs that were placed in the specified marketplaces.")],
        service_order_ids: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1, max_length=20)]], Field(description="List of service order ids for the query you want to perform.Max values supported 20.")] = None,
        service_job_status: Annotated[Optional[List[StrictStr]], Field(description="A list of one or more job status by which to filter the list of jobs.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="String returned in the response of your previous request.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=20, strict=True, ge=1)]], Field(description="A non-negative integer that indicates the maximum number of jobs to return in the list, Value must be 1 - 20. Default 20.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Sort fields on which you want to sort the output.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort order for the query you want to perform.")] = None,
        created_after: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs created at or after a specified time. Must be in ISO 8601 format. Required if `LastUpdatedAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.")] = None,
        created_before: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs created at or before a specified time. Must be in ISO 8601 format.")] = None,
        last_updated_after: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs updated at or after a specified time. Must be in ISO 8601 format. Required if `createdAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.")] = None,
        last_updated_before: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs updated at or before a specified time. Must be in ISO 8601 format.")] = None,
        schedule_start_date: Annotated[Optional[StrictStr], Field(description="A date used for filtering jobs schedules at or after a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.")] = None,
        schedule_end_date: Annotated[Optional[StrictStr], Field(description="A date used for filtering jobs schedules at or before a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.")] = None,
        asins: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=10, strict=True, max_length=10)]], Field(min_length=1, max_length=20)]], Field(description="List of Amazon Standard Identification Numbers (ASIN) of the items. Max values supported is 20.")] = None,
        required_skills: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=1, strict=True, max_length=50)]], Field(min_length=1, max_length=20)]], Field(description="A defined set of related knowledge, skills, experience, tools, materials, and work processes common to service delivery for a set of products and/or service scenarios. Max values supported is 20.")] = None,
        store_ids: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=1, strict=True, max_length=100)]], Field(min_length=1, max_length=50)]], Field(description="List of Amazon-defined identifiers for the region scope. Max values supported is 50.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetServiceJobsResponse]:
        """get_service_jobs

        Gets service job details for the specified filter query.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param marketplace_ids: Used to select jobs that were placed in the specified marketplaces. (required)
        :type marketplace_ids: List[str]
        :param service_order_ids: List of service order ids for the query you want to perform.Max values supported 20.
        :type service_order_ids: List[str]
        :param service_job_status: A list of one or more job status by which to filter the list of jobs.
        :type service_job_status: List[str]
        :param page_token: String returned in the response of your previous request.
        :type page_token: str
        :param page_size: A non-negative integer that indicates the maximum number of jobs to return in the list, Value must be 1 - 20. Default 20.
        :type page_size: int
        :param sort_field: Sort fields on which you want to sort the output.
        :type sort_field: str
        :param sort_order: Sort order for the query you want to perform.
        :type sort_order: str
        :param created_after: A date used for selecting jobs created at or after a specified time. Must be in ISO 8601 format. Required if `LastUpdatedAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
        :type created_after: str
        :param created_before: A date used for selecting jobs created at or before a specified time. Must be in ISO 8601 format.
        :type created_before: str
        :param last_updated_after: A date used for selecting jobs updated at or after a specified time. Must be in ISO 8601 format. Required if `createdAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
        :type last_updated_after: str
        :param last_updated_before: A date used for selecting jobs updated at or before a specified time. Must be in ISO 8601 format.
        :type last_updated_before: str
        :param schedule_start_date: A date used for filtering jobs schedules at or after a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
        :type schedule_start_date: str
        :param schedule_end_date: A date used for filtering jobs schedules at or before a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
        :type schedule_end_date: str
        :param asins: List of Amazon Standard Identification Numbers (ASIN) of the items. Max values supported is 20.
        :type asins: List[str]
        :param required_skills: A defined set of related knowledge, skills, experience, tools, materials, and work processes common to service delivery for a set of products and/or service scenarios. Max values supported is 20.
        :type required_skills: List[str]
        :param store_ids: List of Amazon-defined identifiers for the region scope. Max values supported is 50.
        :type store_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_service_jobs_serialize(
            marketplace_ids=marketplace_ids,
            service_order_ids=service_order_ids,
            service_job_status=service_job_status,
            page_token=page_token,
            page_size=page_size,
            sort_field=sort_field,
            sort_order=sort_order,
            created_after=created_after,
            created_before=created_before,
            last_updated_after=last_updated_after,
            last_updated_before=last_updated_before,
            schedule_start_date=schedule_start_date,
            schedule_end_date=schedule_end_date,
            asins=asins,
            required_skills=required_skills,
            store_ids=store_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetServiceJobsResponse",
            '400': "GetServiceJobsResponse",
            '403': "GetServiceJobsResponse",
            '404': "GetServiceJobsResponse",
            '413': "GetServiceJobsResponse",
            '415': "GetServiceJobsResponse",
            '429': "GetServiceJobsResponse",
            '500': "GetServiceJobsResponse",
            '503': "GetServiceJobsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_service_jobs_without_preload_content(
        self,
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="Used to select jobs that were placed in the specified marketplaces.")],
        service_order_ids: Annotated[Optional[Annotated[List[StrictStr], Field(min_length=1, max_length=20)]], Field(description="List of service order ids for the query you want to perform.Max values supported 20.")] = None,
        service_job_status: Annotated[Optional[List[StrictStr]], Field(description="A list of one or more job status by which to filter the list of jobs.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="String returned in the response of your previous request.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=20, strict=True, ge=1)]], Field(description="A non-negative integer that indicates the maximum number of jobs to return in the list, Value must be 1 - 20. Default 20.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Sort fields on which you want to sort the output.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort order for the query you want to perform.")] = None,
        created_after: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs created at or after a specified time. Must be in ISO 8601 format. Required if `LastUpdatedAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.")] = None,
        created_before: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs created at or before a specified time. Must be in ISO 8601 format.")] = None,
        last_updated_after: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs updated at or after a specified time. Must be in ISO 8601 format. Required if `createdAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.")] = None,
        last_updated_before: Annotated[Optional[StrictStr], Field(description="A date used for selecting jobs updated at or before a specified time. Must be in ISO 8601 format.")] = None,
        schedule_start_date: Annotated[Optional[StrictStr], Field(description="A date used for filtering jobs schedules at or after a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.")] = None,
        schedule_end_date: Annotated[Optional[StrictStr], Field(description="A date used for filtering jobs schedules at or before a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.")] = None,
        asins: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=10, strict=True, max_length=10)]], Field(min_length=1, max_length=20)]], Field(description="List of Amazon Standard Identification Numbers (ASIN) of the items. Max values supported is 20.")] = None,
        required_skills: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=1, strict=True, max_length=50)]], Field(min_length=1, max_length=20)]], Field(description="A defined set of related knowledge, skills, experience, tools, materials, and work processes common to service delivery for a set of products and/or service scenarios. Max values supported is 20.")] = None,
        store_ids: Annotated[Optional[Annotated[List[Annotated[str, Field(min_length=1, strict=True, max_length=100)]], Field(min_length=1, max_length=50)]], Field(description="List of Amazon-defined identifiers for the region scope. Max values supported is 50.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_service_jobs

        Gets service job details for the specified filter query.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 10 | 40 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param marketplace_ids: Used to select jobs that were placed in the specified marketplaces. (required)
        :type marketplace_ids: List[str]
        :param service_order_ids: List of service order ids for the query you want to perform.Max values supported 20.
        :type service_order_ids: List[str]
        :param service_job_status: A list of one or more job status by which to filter the list of jobs.
        :type service_job_status: List[str]
        :param page_token: String returned in the response of your previous request.
        :type page_token: str
        :param page_size: A non-negative integer that indicates the maximum number of jobs to return in the list, Value must be 1 - 20. Default 20.
        :type page_size: int
        :param sort_field: Sort fields on which you want to sort the output.
        :type sort_field: str
        :param sort_order: Sort order for the query you want to perform.
        :type sort_order: str
        :param created_after: A date used for selecting jobs created at or after a specified time. Must be in ISO 8601 format. Required if `LastUpdatedAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
        :type created_after: str
        :param created_before: A date used for selecting jobs created at or before a specified time. Must be in ISO 8601 format.
        :type created_before: str
        :param last_updated_after: A date used for selecting jobs updated at or after a specified time. Must be in ISO 8601 format. Required if `createdAfter` is not specified. Specifying both `CreatedAfter` and `LastUpdatedAfter` returns an error.
        :type last_updated_after: str
        :param last_updated_before: A date used for selecting jobs updated at or before a specified time. Must be in ISO 8601 format.
        :type last_updated_before: str
        :param schedule_start_date: A date used for filtering jobs schedules at or after a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
        :type schedule_start_date: str
        :param schedule_end_date: A date used for filtering jobs schedules at or before a specified time. Must be in ISO 8601 format. Schedule end date should not be earlier than schedule start date.
        :type schedule_end_date: str
        :param asins: List of Amazon Standard Identification Numbers (ASIN) of the items. Max values supported is 20.
        :type asins: List[str]
        :param required_skills: A defined set of related knowledge, skills, experience, tools, materials, and work processes common to service delivery for a set of products and/or service scenarios. Max values supported is 20.
        :type required_skills: List[str]
        :param store_ids: List of Amazon-defined identifiers for the region scope. Max values supported is 50.
        :type store_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_service_jobs_serialize(
            marketplace_ids=marketplace_ids,
            service_order_ids=service_order_ids,
            service_job_status=service_job_status,
            page_token=page_token,
            page_size=page_size,
            sort_field=sort_field,
            sort_order=sort_order,
            created_after=created_after,
            created_before=created_before,
            last_updated_after=last_updated_after,
            last_updated_before=last_updated_before,
            schedule_start_date=schedule_start_date,
            schedule_end_date=schedule_end_date,
            asins=asins,
            required_skills=required_skills,
            store_ids=store_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetServiceJobsResponse",
            '400': "GetServiceJobsResponse",
            '403': "GetServiceJobsResponse",
            '404': "GetServiceJobsResponse",
            '413': "GetServiceJobsResponse",
            '415': "GetServiceJobsResponse",
            '429': "GetServiceJobsResponse",
            '500': "GetServiceJobsResponse",
            '503': "GetServiceJobsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_service_jobs_serialize(
        self,
        marketplace_ids,
        service_order_ids,
        service_job_status,
        page_token,
        page_size,
        sort_field,
        sort_order,
        created_after,
        created_before,
        last_updated_after,
        last_updated_before,
        schedule_start_date,
        schedule_end_date,
        asins,
        required_skills,
        store_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
            'serviceOrderIds': 'csv',
            'serviceJobStatus': 'csv',
            'asins': 'csv',
            'requiredSkills': 'csv',
            'storeIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if service_order_ids is not None:
            
            _query_params.append(('serviceOrderIds', service_order_ids))
            
        if service_job_status is not None:
            
            _query_params.append(('serviceJobStatus', service_job_status))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if created_after is not None:
            
            _query_params.append(('createdAfter', created_after))
            
        if created_before is not None:
            
            _query_params.append(('createdBefore', created_before))
            
        if last_updated_after is not None:
            
            _query_params.append(('lastUpdatedAfter', last_updated_after))
            
        if last_updated_before is not None:
            
            _query_params.append(('lastUpdatedBefore', last_updated_before))
            
        if schedule_start_date is not None:
            
            _query_params.append(('scheduleStartDate', schedule_start_date))
            
        if schedule_end_date is not None:
            
            _query_params.append(('scheduleEndDate', schedule_end_date))
            
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        if asins is not None:
            
            _query_params.append(('asins', asins))
            
        if required_skills is not None:
            
            _query_params.append(('requiredSkills', required_skills))
            
        if store_ids is not None:
            
            _query_params.append(('storeIds', store_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/service/v1/serviceJobs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reschedule_appointment_for_service_job_by_service_job_id(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An existing appointment identifier for the Service Job.")],
        body: Annotated[RescheduleAppointmentRequest, Field(description="Reschedule appointment operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SetAppointmentResponse:
        """reschedule_appointment_for_service_job_by_service_job_id

        Reschedules an appointment for the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param appointment_id: An existing appointment identifier for the Service Job. (required)
        :type appointment_id: str
        :param body: Reschedule appointment operation input details. (required)
        :type body: RescheduleAppointmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reschedule_appointment_for_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetAppointmentResponse",
            '400': "SetAppointmentResponse",
            '403': "SetAppointmentResponse",
            '404': "SetAppointmentResponse",
            '413': "SetAppointmentResponse",
            '415': "SetAppointmentResponse",
            '422': "SetAppointmentResponse",
            '429': "SetAppointmentResponse",
            '500': "SetAppointmentResponse",
            '503': "SetAppointmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reschedule_appointment_for_service_job_by_service_job_id_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An existing appointment identifier for the Service Job.")],
        body: Annotated[RescheduleAppointmentRequest, Field(description="Reschedule appointment operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SetAppointmentResponse]:
        """reschedule_appointment_for_service_job_by_service_job_id

        Reschedules an appointment for the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param appointment_id: An existing appointment identifier for the Service Job. (required)
        :type appointment_id: str
        :param body: Reschedule appointment operation input details. (required)
        :type body: RescheduleAppointmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reschedule_appointment_for_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetAppointmentResponse",
            '400': "SetAppointmentResponse",
            '403': "SetAppointmentResponse",
            '404': "SetAppointmentResponse",
            '413': "SetAppointmentResponse",
            '415': "SetAppointmentResponse",
            '422': "SetAppointmentResponse",
            '429': "SetAppointmentResponse",
            '500': "SetAppointmentResponse",
            '503': "SetAppointmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reschedule_appointment_for_service_job_by_service_job_id_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon defined service job identifier.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An existing appointment identifier for the Service Job.")],
        body: Annotated[RescheduleAppointmentRequest, Field(description="Reschedule appointment operation input details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reschedule_appointment_for_service_job_by_service_job_id

        Reschedules an appointment for the service job indicated by the service job identifier specified.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon defined service job identifier. (required)
        :type service_job_id: str
        :param appointment_id: An existing appointment identifier for the Service Job. (required)
        :type appointment_id: str
        :param body: Reschedule appointment operation input details. (required)
        :type body: RescheduleAppointmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reschedule_appointment_for_service_job_by_service_job_id_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SetAppointmentResponse",
            '400': "SetAppointmentResponse",
            '403': "SetAppointmentResponse",
            '404': "SetAppointmentResponse",
            '413': "SetAppointmentResponse",
            '415': "SetAppointmentResponse",
            '422': "SetAppointmentResponse",
            '429': "SetAppointmentResponse",
            '500': "SetAppointmentResponse",
            '503': "SetAppointmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reschedule_appointment_for_service_job_by_service_job_id_serialize(
        self,
        service_job_id,
        appointment_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        if appointment_id is not None:
            _path_params['appointmentId'] = appointment_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/service/v1/serviceJobs/{serviceJobId}/appointments/{appointmentId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def set_appointment_fulfillment_data(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined identifier of active service job appointment.")],
        body: Annotated[SetAppointmentFulfillmentDataRequest, Field(description="Appointment fulfillment data collection details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """set_appointment_fulfillment_data

        Updates the appointment fulfillment data related to a given `jobID` and `appointmentID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API. (required)
        :type service_job_id: str
        :param appointment_id: An Amazon-defined identifier of active service job appointment. (required)
        :type appointment_id: str
        :param body: Appointment fulfillment data collection details. (required)
        :type body: SetAppointmentFulfillmentDataRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_appointment_fulfillment_data_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "str",
            '400': "List[Error]",
            '403': "List[Error]",
            '404': "List[Error]",
            '413': "List[Error]",
            '415': "List[Error]",
            '422': "List[Error]",
            '429': "List[Error]",
            '500': "List[Error]",
            '503': "List[Error]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_appointment_fulfillment_data_with_http_info(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined identifier of active service job appointment.")],
        body: Annotated[SetAppointmentFulfillmentDataRequest, Field(description="Appointment fulfillment data collection details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """set_appointment_fulfillment_data

        Updates the appointment fulfillment data related to a given `jobID` and `appointmentID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API. (required)
        :type service_job_id: str
        :param appointment_id: An Amazon-defined identifier of active service job appointment. (required)
        :type appointment_id: str
        :param body: Appointment fulfillment data collection details. (required)
        :type body: SetAppointmentFulfillmentDataRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_appointment_fulfillment_data_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "str",
            '400': "List[Error]",
            '403': "List[Error]",
            '404': "List[Error]",
            '413': "List[Error]",
            '415': "List[Error]",
            '422': "List[Error]",
            '429': "List[Error]",
            '500': "List[Error]",
            '503': "List[Error]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def set_appointment_fulfillment_data_without_preload_content(
        self,
        service_job_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API.")],
        appointment_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="An Amazon-defined identifier of active service job appointment.")],
        body: Annotated[SetAppointmentFulfillmentDataRequest, Field(description="Appointment fulfillment data collection details.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """set_appointment_fulfillment_data

        Updates the appointment fulfillment data related to a given `jobID` and `appointmentID`.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param service_job_id: An Amazon-defined service job identifier. Get this value by calling the `getServiceJobs` operation of the Services API. (required)
        :type service_job_id: str
        :param appointment_id: An Amazon-defined identifier of active service job appointment. (required)
        :type appointment_id: str
        :param body: Appointment fulfillment data collection details. (required)
        :type body: SetAppointmentFulfillmentDataRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_appointment_fulfillment_data_serialize(
            service_job_id=service_job_id,
            appointment_id=appointment_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "str",
            '400': "List[Error]",
            '403': "List[Error]",
            '404': "List[Error]",
            '413': "List[Error]",
            '415': "List[Error]",
            '422': "List[Error]",
            '429': "List[Error]",
            '500': "List[Error]",
            '503': "List[Error]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _set_appointment_fulfillment_data_serialize(
        self,
        service_job_id,
        appointment_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if service_job_id is not None:
            _path_params['serviceJobId'] = service_job_id
        if appointment_id is not None:
            _path_params['appointmentId'] = appointment_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/service/v1/serviceJobs/{serviceJobId}/appointments/{appointmentId}/fulfillment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_reservation(
        self,
        reservation_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Reservation Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[UpdateReservationRequest, Field(description="Reservation details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateReservationResponse:
        """update_reservation

        Update a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param reservation_id: Reservation Identifier (required)
        :type reservation_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Reservation details (required)
        :type body: UpdateReservationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_reservation_serialize(
            reservation_id=reservation_id,
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateReservationResponse",
            '400': "UpdateReservationResponse",
            '403': "UpdateReservationResponse",
            '404': "UpdateReservationResponse",
            '413': "UpdateReservationResponse",
            '415': "UpdateReservationResponse",
            '429': "UpdateReservationResponse",
            '500': "UpdateReservationResponse",
            '503': "UpdateReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_reservation_with_http_info(
        self,
        reservation_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Reservation Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[UpdateReservationRequest, Field(description="Reservation details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateReservationResponse]:
        """update_reservation

        Update a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param reservation_id: Reservation Identifier (required)
        :type reservation_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Reservation details (required)
        :type body: UpdateReservationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_reservation_serialize(
            reservation_id=reservation_id,
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateReservationResponse",
            '400': "UpdateReservationResponse",
            '403': "UpdateReservationResponse",
            '404': "UpdateReservationResponse",
            '413': "UpdateReservationResponse",
            '415': "UpdateReservationResponse",
            '429': "UpdateReservationResponse",
            '500': "UpdateReservationResponse",
            '503': "UpdateReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_reservation_without_preload_content(
        self,
        reservation_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Reservation Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[UpdateReservationRequest, Field(description="Reservation details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """update_reservation

        Update a reservation.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param reservation_id: Reservation Identifier (required)
        :type reservation_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Reservation details (required)
        :type body: UpdateReservationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_reservation_serialize(
            reservation_id=reservation_id,
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateReservationResponse",
            '400': "UpdateReservationResponse",
            '403': "UpdateReservationResponse",
            '404': "UpdateReservationResponse",
            '413': "UpdateReservationResponse",
            '415': "UpdateReservationResponse",
            '429': "UpdateReservationResponse",
            '500': "UpdateReservationResponse",
            '503': "UpdateReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_reservation_serialize(
        self,
        reservation_id,
        marketplace_ids,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if reservation_id is not None:
            _path_params['reservationId'] = reservation_id
        # process the query parameters
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/service/v1/reservation/{reservationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_schedule(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource (store) Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[UpdateScheduleRequest, Field(description="Schedule details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateScheduleResponse:
        """update_schedule

        Update the schedule of the given resource.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource (store) Identifier (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Schedule details (required)
        :type body: UpdateScheduleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_schedule_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateScheduleResponse",
            '400': "UpdateScheduleResponse",
            '403': "UpdateScheduleResponse",
            '404': "UpdateScheduleResponse",
            '413': "UpdateScheduleResponse",
            '415': "UpdateScheduleResponse",
            '429': "UpdateScheduleResponse",
            '500': "UpdateScheduleResponse",
            '503': "UpdateScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_schedule_with_http_info(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource (store) Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[UpdateScheduleRequest, Field(description="Schedule details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateScheduleResponse]:
        """update_schedule

        Update the schedule of the given resource.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource (store) Identifier (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Schedule details (required)
        :type body: UpdateScheduleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_schedule_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateScheduleResponse",
            '400': "UpdateScheduleResponse",
            '403': "UpdateScheduleResponse",
            '404': "UpdateScheduleResponse",
            '413': "UpdateScheduleResponse",
            '415': "UpdateScheduleResponse",
            '429': "UpdateScheduleResponse",
            '500': "UpdateScheduleResponse",
            '503': "UpdateScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_schedule_without_preload_content(
        self,
        resource_id: Annotated[str, Field(min_length=1, strict=True, max_length=100, description="Resource (store) Identifier")],
        marketplace_ids: Annotated[List[StrictStr], Field(max_length=1, description="An identifier for the marketplace in which the resource operates.")],
        body: Annotated[UpdateScheduleRequest, Field(description="Schedule details")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """update_schedule

        Update the schedule of the given resource.  **Usage Plan:**  | Rate (requests per second) | Burst | | ---- | ---- | | 5 | 20 |  The `x-amzn-RateLimit-Limit` response header returns the usage plan rate limits that were applied to the requested operation, when available. The table above indicates the default rate and burst values for this operation. Selling partners whose business demands require higher throughput may see higher rate and burst values than those shown here. For more information, see [Usage Plans and Rate Limits in the Selling Partner API](doc:usage-plans-and-rate-limits-in-the-sp-api).

        :param resource_id: Resource (store) Identifier (required)
        :type resource_id: str
        :param marketplace_ids: An identifier for the marketplace in which the resource operates. (required)
        :type marketplace_ids: List[str]
        :param body: Schedule details (required)
        :type body: UpdateScheduleRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_schedule_serialize(
            resource_id=resource_id,
            marketplace_ids=marketplace_ids,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateScheduleResponse",
            '400': "UpdateScheduleResponse",
            '403': "UpdateScheduleResponse",
            '404': "UpdateScheduleResponse",
            '413': "UpdateScheduleResponse",
            '415': "UpdateScheduleResponse",
            '429': "UpdateScheduleResponse",
            '500': "UpdateScheduleResponse",
            '503': "UpdateScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_schedule_serialize(
        self,
        resource_id,
        marketplace_ids,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'marketplaceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resourceId'] = resource_id
        # process the query parameters
        if marketplace_ids is not None:
            
            _query_params.append(('marketplaceIds', marketplace_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/service/v1/serviceResources/{resourceId}/schedules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


