# coding: utf-8

"""
    Selling Partner API for Retail Procurement Shipments

    The Selling Partner API for Retail Procurement Shipments provides programmatic access to retail shipping data for vendors.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from py_sp_api.generated.vendorShipments.models.carton import Carton
from py_sp_api.generated.vendorShipments.models.import_details import ImportDetails
from py_sp_api.generated.vendorShipments.models.item import Item
from py_sp_api.generated.vendorShipments.models.pallet import Pallet
from py_sp_api.generated.vendorShipments.models.party_identification import PartyIdentification
from py_sp_api.generated.vendorShipments.models.shipment_measurements import ShipmentMeasurements
from py_sp_api.generated.vendorShipments.models.transportation_details_for_shipment_confirmation import TransportationDetailsForShipmentConfirmation
from typing import Optional, Set
from typing_extensions import Self

class ShipmentConfirmation(BaseModel):
    """
    A list of one or more shipment confirmations.
    """ # noqa: E501
    shipment_identifier: StrictStr = Field(description="Unique shipment ID (not used over the last 365 days).", alias="shipmentIdentifier")
    shipment_confirmation_type: StrictStr = Field(description="Indicates if this shipment confirmation is the initial confirmation, or intended to replace an already posted shipment confirmation. If replacing an existing shipment confirmation, be sure to provide the identical shipmentIdentifier and sellingParty information as in the previous confirmation.", alias="shipmentConfirmationType")
    shipment_type: Optional[StrictStr] = Field(default=None, description="The type of shipment.", alias="shipmentType")
    shipment_structure: Optional[StrictStr] = Field(default=None, description="Shipment hierarchical structure.", alias="shipmentStructure")
    transportation_details: Optional[TransportationDetailsForShipmentConfirmation] = Field(default=None, alias="transportationDetails")
    amazon_reference_number: Optional[StrictStr] = Field(default=None, description="The Amazon Reference Number is a unique identifier generated by Amazon for all Collect/WePay shipments when you submit  a routing request. This field is mandatory for Collect/WePay shipments.", alias="amazonReferenceNumber")
    shipment_confirmation_date: datetime = Field(description="Date on which the shipment confirmation was submitted.", alias="shipmentConfirmationDate")
    shipped_date: Optional[datetime] = Field(default=None, description="The date and time of the departure of the shipment from the vendor's location. Vendors are requested to send ASNs within 30 minutes of departure from their warehouse/distribution center or at least 6 hours prior to the appointment time at the buyer destination warehouse, whichever is sooner. Shipped date mentioned in the shipment confirmation should not be in the future.", alias="shippedDate")
    estimated_delivery_date: Optional[datetime] = Field(default=None, description="The date and time on which the shipment is estimated to reach buyer's warehouse. It needs to be an estimate based on the average transit time between ship from location and the destination. The exact appointment time will be provided by the buyer and is potentially not known when creating the shipment confirmation.", alias="estimatedDeliveryDate")
    selling_party: PartyIdentification = Field(alias="sellingParty")
    ship_from_party: PartyIdentification = Field(alias="shipFromParty")
    ship_to_party: PartyIdentification = Field(alias="shipToParty")
    shipment_measurements: Optional[ShipmentMeasurements] = Field(default=None, alias="shipmentMeasurements")
    import_details: Optional[ImportDetails] = Field(default=None, alias="importDetails")
    shipped_items: List[Item] = Field(description="A list of the items in this shipment and their associated details. If any of the item detail fields are common at a carton or a pallet level, provide them at the corresponding carton or pallet level.", alias="shippedItems")
    cartons: Optional[List[Carton]] = Field(default=None, description="A list of the cartons in this shipment.")
    pallets: Optional[List[Pallet]] = Field(default=None, description="A list of the pallets in this shipment.")
    __properties: ClassVar[List[str]] = ["shipmentIdentifier", "shipmentConfirmationType", "shipmentType", "shipmentStructure", "transportationDetails", "amazonReferenceNumber", "shipmentConfirmationDate", "shippedDate", "estimatedDeliveryDate", "sellingParty", "shipFromParty", "shipToParty", "shipmentMeasurements", "importDetails", "shippedItems", "cartons", "pallets"]

    @field_validator('shipment_confirmation_type')
    def shipment_confirmation_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Original', 'Replace']):
            raise ValueError("must be one of enum values ('Original', 'Replace')")
        return value

    @field_validator('shipment_type')
    def shipment_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TruckLoad', 'LessThanTruckLoad', 'SmallParcel']):
            raise ValueError("must be one of enum values ('TruckLoad', 'LessThanTruckLoad', 'SmallParcel')")
        return value

    @field_validator('shipment_structure')
    def shipment_structure_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PalletizedAssortmentCase', 'LooseAssortmentCase', 'PalletOfItems', 'PalletizedStandardCase', 'LooseStandardCase', 'MasterPallet', 'MasterCase']):
            raise ValueError("must be one of enum values ('PalletizedAssortmentCase', 'LooseAssortmentCase', 'PalletOfItems', 'PalletizedStandardCase', 'LooseStandardCase', 'MasterPallet', 'MasterCase')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ShipmentConfirmation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of transportation_details
        if self.transportation_details:
            _dict['transportationDetails'] = self.transportation_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of selling_party
        if self.selling_party:
            _dict['sellingParty'] = self.selling_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_from_party
        if self.ship_from_party:
            _dict['shipFromParty'] = self.ship_from_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_to_party
        if self.ship_to_party:
            _dict['shipToParty'] = self.ship_to_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipment_measurements
        if self.shipment_measurements:
            _dict['shipmentMeasurements'] = self.shipment_measurements.to_dict()
        # override the default output from pydantic by calling `to_dict()` of import_details
        if self.import_details:
            _dict['importDetails'] = self.import_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in shipped_items (list)
        _items = []
        if self.shipped_items:
            for _item_shipped_items in self.shipped_items:
                if _item_shipped_items:
                    _items.append(_item_shipped_items.to_dict())
            _dict['shippedItems'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cartons (list)
        _items = []
        if self.cartons:
            for _item_cartons in self.cartons:
                if _item_cartons:
                    _items.append(_item_cartons.to_dict())
            _dict['cartons'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in pallets (list)
        _items = []
        if self.pallets:
            for _item_pallets in self.pallets:
                if _item_pallets:
                    _items.append(_item_pallets.to_dict())
            _dict['pallets'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ShipmentConfirmation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "shipmentIdentifier": obj.get("shipmentIdentifier"),
            "shipmentConfirmationType": obj.get("shipmentConfirmationType"),
            "shipmentType": obj.get("shipmentType"),
            "shipmentStructure": obj.get("shipmentStructure"),
            "transportationDetails": TransportationDetailsForShipmentConfirmation.from_dict(obj["transportationDetails"]) if obj.get("transportationDetails") is not None else None,
            "amazonReferenceNumber": obj.get("amazonReferenceNumber"),
            "shipmentConfirmationDate": obj.get("shipmentConfirmationDate"),
            "shippedDate": obj.get("shippedDate"),
            "estimatedDeliveryDate": obj.get("estimatedDeliveryDate"),
            "sellingParty": PartyIdentification.from_dict(obj["sellingParty"]) if obj.get("sellingParty") is not None else None,
            "shipFromParty": PartyIdentification.from_dict(obj["shipFromParty"]) if obj.get("shipFromParty") is not None else None,
            "shipToParty": PartyIdentification.from_dict(obj["shipToParty"]) if obj.get("shipToParty") is not None else None,
            "shipmentMeasurements": ShipmentMeasurements.from_dict(obj["shipmentMeasurements"]) if obj.get("shipmentMeasurements") is not None else None,
            "importDetails": ImportDetails.from_dict(obj["importDetails"]) if obj.get("importDetails") is not None else None,
            "shippedItems": [Item.from_dict(_item) for _item in obj["shippedItems"]] if obj.get("shippedItems") is not None else None,
            "cartons": [Carton.from_dict(_item) for _item in obj["cartons"]] if obj.get("cartons") is not None else None,
            "pallets": [Pallet.from_dict(_item) for _item in obj["pallets"]] if obj.get("pallets") is not None else None
        })
        return _obj


