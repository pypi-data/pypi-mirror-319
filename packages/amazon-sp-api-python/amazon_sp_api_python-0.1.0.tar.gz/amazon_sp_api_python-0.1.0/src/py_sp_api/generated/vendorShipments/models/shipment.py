# coding: utf-8

"""
    Selling Partner API for Retail Procurement Shipments

    The Selling Partner API for Retail Procurement Shipments provides programmatic access to retail shipping data for vendors.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from py_sp_api.generated.vendorShipments.models.collect_freight_pickup_details import CollectFreightPickupDetails
from py_sp_api.generated.vendorShipments.models.containers import Containers
from py_sp_api.generated.vendorShipments.models.import_details import ImportDetails
from py_sp_api.generated.vendorShipments.models.party_identification import PartyIdentification
from py_sp_api.generated.vendorShipments.models.purchase_orders import PurchaseOrders
from py_sp_api.generated.vendorShipments.models.shipment_status_details import ShipmentStatusDetails
from py_sp_api.generated.vendorShipments.models.transport_shipment_measurements import TransportShipmentMeasurements
from py_sp_api.generated.vendorShipments.models.transportation_details import TransportationDetails
from typing import Optional, Set
from typing_extensions import Self

class Shipment(BaseModel):
    """
    A list of one or more shipments with respective details.
    """ # noqa: E501
    vendor_shipment_identifier: StrictStr = Field(description="Unique Transportation ID created by Vendor (Should not be used over the last 365 days).", alias="vendorShipmentIdentifier")
    transaction_type: StrictStr = Field(description="Indicates the type of  transportation request such as (New,Cancel,Confirm and PackageLabelRequest). Each transactiontype has a unique set of operation and there are corresponding details to be populated for each operation.", alias="transactionType")
    buyer_reference_number: Optional[StrictStr] = Field(default=None, description="The buyer Reference Number is a unique identifier generated by buyer for all Collect/WePay shipments when you submit a transportation request. This field is mandatory for Collect/WePay shipments.", alias="buyerReferenceNumber")
    transaction_date: datetime = Field(description="Date on which the transportation request was submitted.", alias="transactionDate")
    current_shipment_status: Optional[StrictStr] = Field(default=None, description="Indicates the current shipment status.", alias="currentShipmentStatus")
    currentshipment_status_date: Optional[datetime] = Field(default=None, description="Date and time when the last status was updated.", alias="currentshipmentStatusDate")
    shipment_status_details: Optional[List[ShipmentStatusDetails]] = Field(default=None, description="Indicates the list of current shipment status details and when the last update was received from carrier this is available on shipment Details response.", alias="shipmentStatusDetails")
    shipment_create_date: Optional[datetime] = Field(default=None, description="The date and time of the shipment request created by vendor.", alias="shipmentCreateDate")
    shipment_confirm_date: Optional[datetime] = Field(default=None, description="The date and time of the departure of the shipment from the vendor's location. Vendors are requested to send ASNs within 30 minutes of departure from their warehouse/distribution center or at least 6 hours prior to the appointment time at the Buyer destination warehouse, whichever is sooner. Shipped date mentioned in the shipment confirmation should not be in the future.", alias="shipmentConfirmDate")
    package_label_create_date: Optional[datetime] = Field(default=None, description="The date and time of the package label created for the shipment by buyer.", alias="packageLabelCreateDate")
    shipment_freight_term: Optional[StrictStr] = Field(default=None, description="Indicates if this transportation request is WePay/Collect or TheyPay/Prepaid. This is a mandatory information.", alias="shipmentFreightTerm")
    selling_party: PartyIdentification = Field(alias="sellingParty")
    ship_from_party: PartyIdentification = Field(alias="shipFromParty")
    ship_to_party: PartyIdentification = Field(alias="shipToParty")
    shipment_measurements: Optional[TransportShipmentMeasurements] = Field(default=None, alias="shipmentMeasurements")
    collect_freight_pickup_details: Optional[CollectFreightPickupDetails] = Field(default=None, alias="collectFreightPickupDetails")
    purchase_orders: Optional[List[PurchaseOrders]] = Field(default=None, description="Indicates the purchase orders involved for the transportation request. This group is an array create 1 for each PO and list their corresponding items. This information is used for deciding the route,truck allocation and storage efficiently. This is a mandatory information for Buyer performing transportation from vendor warehouse (WePay/Collect)", alias="purchaseOrders")
    import_details: Optional[ImportDetails] = Field(default=None, alias="importDetails")
    containers: Optional[List[Containers]] = Field(default=None, description="A list of the items in this transportation and their associated inner container details. If any of the item detail fields are common at a carton or a pallet level, provide them at the corresponding carton or pallet level.")
    transportation_details: Optional[TransportationDetails] = Field(default=None, alias="transportationDetails")
    __properties: ClassVar[List[str]] = ["vendorShipmentIdentifier", "transactionType", "buyerReferenceNumber", "transactionDate", "currentShipmentStatus", "currentshipmentStatusDate", "shipmentStatusDetails", "shipmentCreateDate", "shipmentConfirmDate", "packageLabelCreateDate", "shipmentFreightTerm", "sellingParty", "shipFromParty", "shipToParty", "shipmentMeasurements", "collectFreightPickupDetails", "purchaseOrders", "importDetails", "containers", "transportationDetails"]

    @field_validator('transaction_type')
    def transaction_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['New', 'Cancel']):
            raise ValueError("must be one of enum values ('New', 'Cancel')")
        return value

    @field_validator('current_shipment_status')
    def current_shipment_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Created', 'TransportationRequested', 'CarrierAssigned', 'Shipped']):
            raise ValueError("must be one of enum values ('Created', 'TransportationRequested', 'CarrierAssigned', 'Shipped')")
        return value

    @field_validator('shipment_freight_term')
    def shipment_freight_term_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Collect', 'Prepaid']):
            raise ValueError("must be one of enum values ('Collect', 'Prepaid')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Shipment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in shipment_status_details (list)
        _items = []
        if self.shipment_status_details:
            for _item_shipment_status_details in self.shipment_status_details:
                if _item_shipment_status_details:
                    _items.append(_item_shipment_status_details.to_dict())
            _dict['shipmentStatusDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of selling_party
        if self.selling_party:
            _dict['sellingParty'] = self.selling_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_from_party
        if self.ship_from_party:
            _dict['shipFromParty'] = self.ship_from_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_to_party
        if self.ship_to_party:
            _dict['shipToParty'] = self.ship_to_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipment_measurements
        if self.shipment_measurements:
            _dict['shipmentMeasurements'] = self.shipment_measurements.to_dict()
        # override the default output from pydantic by calling `to_dict()` of collect_freight_pickup_details
        if self.collect_freight_pickup_details:
            _dict['collectFreightPickupDetails'] = self.collect_freight_pickup_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in purchase_orders (list)
        _items = []
        if self.purchase_orders:
            for _item_purchase_orders in self.purchase_orders:
                if _item_purchase_orders:
                    _items.append(_item_purchase_orders.to_dict())
            _dict['purchaseOrders'] = _items
        # override the default output from pydantic by calling `to_dict()` of import_details
        if self.import_details:
            _dict['importDetails'] = self.import_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in containers (list)
        _items = []
        if self.containers:
            for _item_containers in self.containers:
                if _item_containers:
                    _items.append(_item_containers.to_dict())
            _dict['containers'] = _items
        # override the default output from pydantic by calling `to_dict()` of transportation_details
        if self.transportation_details:
            _dict['transportationDetails'] = self.transportation_details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Shipment from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "vendorShipmentIdentifier": obj.get("vendorShipmentIdentifier"),
            "transactionType": obj.get("transactionType"),
            "buyerReferenceNumber": obj.get("buyerReferenceNumber"),
            "transactionDate": obj.get("transactionDate"),
            "currentShipmentStatus": obj.get("currentShipmentStatus"),
            "currentshipmentStatusDate": obj.get("currentshipmentStatusDate"),
            "shipmentStatusDetails": [ShipmentStatusDetails.from_dict(_item) for _item in obj["shipmentStatusDetails"]] if obj.get("shipmentStatusDetails") is not None else None,
            "shipmentCreateDate": obj.get("shipmentCreateDate"),
            "shipmentConfirmDate": obj.get("shipmentConfirmDate"),
            "packageLabelCreateDate": obj.get("packageLabelCreateDate"),
            "shipmentFreightTerm": obj.get("shipmentFreightTerm"),
            "sellingParty": PartyIdentification.from_dict(obj["sellingParty"]) if obj.get("sellingParty") is not None else None,
            "shipFromParty": PartyIdentification.from_dict(obj["shipFromParty"]) if obj.get("shipFromParty") is not None else None,
            "shipToParty": PartyIdentification.from_dict(obj["shipToParty"]) if obj.get("shipToParty") is not None else None,
            "shipmentMeasurements": TransportShipmentMeasurements.from_dict(obj["shipmentMeasurements"]) if obj.get("shipmentMeasurements") is not None else None,
            "collectFreightPickupDetails": CollectFreightPickupDetails.from_dict(obj["collectFreightPickupDetails"]) if obj.get("collectFreightPickupDetails") is not None else None,
            "purchaseOrders": [PurchaseOrders.from_dict(_item) for _item in obj["purchaseOrders"]] if obj.get("purchaseOrders") is not None else None,
            "importDetails": ImportDetails.from_dict(obj["importDetails"]) if obj.get("importDetails") is not None else None,
            "containers": [Containers.from_dict(_item) for _item in obj["containers"]] if obj.get("containers") is not None else None,
            "transportationDetails": TransportationDetails.from_dict(obj["transportationDetails"]) if obj.get("transportationDetails") is not None else None
        })
        return _obj


