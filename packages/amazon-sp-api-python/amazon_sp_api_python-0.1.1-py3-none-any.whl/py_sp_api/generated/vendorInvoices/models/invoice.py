# coding: utf-8

"""
    Vendor Invoices v1

    The Selling Partner API for Retail Procurement Payments provides programmatic access to vendors payments data.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from py_sp_api.generated.vendorInvoices.models.additional_details import AdditionalDetails
from py_sp_api.generated.vendorInvoices.models.allowance_details import AllowanceDetails
from py_sp_api.generated.vendorInvoices.models.charge_details import ChargeDetails
from py_sp_api.generated.vendorInvoices.models.invoice_item import InvoiceItem
from py_sp_api.generated.vendorInvoices.models.money import Money
from py_sp_api.generated.vendorInvoices.models.party_identification import PartyIdentification
from py_sp_api.generated.vendorInvoices.models.payment_terms import PaymentTerms
from py_sp_api.generated.vendorInvoices.models.tax_details import TaxDetails
from typing import Optional, Set
from typing_extensions import Self

class Invoice(BaseModel):
    """
    Represents an invoice or credit note document with details about the transaction, parties involved, and line items.
    """ # noqa: E501
    invoice_type: StrictStr = Field(description="Identifies the type of invoice.", alias="invoiceType")
    id: StrictStr = Field(description="Unique number relating to the charges defined in this document. This will be invoice number if the document type is Invoice or CreditNote number if the document type is Credit Note. Failure to provide this reference will result in a rejection.")
    reference_number: Optional[StrictStr] = Field(default=None, description="An additional unique reference number used for regulatory or other purposes.", alias="referenceNumber")
    var_date: datetime = Field(description="Defines a date and time according to ISO8601.", alias="date")
    remit_to_party: PartyIdentification = Field(alias="remitToParty")
    ship_to_party: Optional[PartyIdentification] = Field(default=None, alias="shipToParty")
    ship_from_party: Optional[PartyIdentification] = Field(default=None, alias="shipFromParty")
    bill_to_party: Optional[PartyIdentification] = Field(default=None, alias="billToParty")
    payment_terms: Optional[PaymentTerms] = Field(default=None, alias="paymentTerms")
    invoice_total: Money = Field(alias="invoiceTotal")
    tax_details: Optional[List[TaxDetails]] = Field(default=None, description="Total tax amount details for all line items.", alias="taxDetails")
    additional_details: Optional[List[AdditionalDetails]] = Field(default=None, description="Additional details provided by the selling party, for tax related or other purposes.", alias="additionalDetails")
    charge_details: Optional[List[ChargeDetails]] = Field(default=None, description="Total charge amount details for all line items.", alias="chargeDetails")
    allowance_details: Optional[List[AllowanceDetails]] = Field(default=None, description="Total allowance amount details for all line items.", alias="allowanceDetails")
    items: Optional[List[InvoiceItem]] = Field(default=None, description="The list of invoice items.")
    __properties: ClassVar[List[str]] = ["invoiceType", "id", "referenceNumber", "date", "remitToParty", "shipToParty", "shipFromParty", "billToParty", "paymentTerms", "invoiceTotal", "taxDetails", "additionalDetails", "chargeDetails", "allowanceDetails", "items"]

    @field_validator('invoice_type')
    def invoice_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Invoice', 'CreditNote']):
            raise ValueError("must be one of enum values ('Invoice', 'CreditNote')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Invoice from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of remit_to_party
        if self.remit_to_party:
            _dict['remitToParty'] = self.remit_to_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_to_party
        if self.ship_to_party:
            _dict['shipToParty'] = self.ship_to_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ship_from_party
        if self.ship_from_party:
            _dict['shipFromParty'] = self.ship_from_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bill_to_party
        if self.bill_to_party:
            _dict['billToParty'] = self.bill_to_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_terms
        if self.payment_terms:
            _dict['paymentTerms'] = self.payment_terms.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invoice_total
        if self.invoice_total:
            _dict['invoiceTotal'] = self.invoice_total.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tax_details (list)
        _items = []
        if self.tax_details:
            for _item_tax_details in self.tax_details:
                if _item_tax_details:
                    _items.append(_item_tax_details.to_dict())
            _dict['taxDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in additional_details (list)
        _items = []
        if self.additional_details:
            for _item_additional_details in self.additional_details:
                if _item_additional_details:
                    _items.append(_item_additional_details.to_dict())
            _dict['additionalDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in charge_details (list)
        _items = []
        if self.charge_details:
            for _item_charge_details in self.charge_details:
                if _item_charge_details:
                    _items.append(_item_charge_details.to_dict())
            _dict['chargeDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in allowance_details (list)
        _items = []
        if self.allowance_details:
            for _item_allowance_details in self.allowance_details:
                if _item_allowance_details:
                    _items.append(_item_allowance_details.to_dict())
            _dict['allowanceDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in items (list)
        _items = []
        if self.items:
            for _item_items in self.items:
                if _item_items:
                    _items.append(_item_items.to_dict())
            _dict['items'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Invoice from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "invoiceType": obj.get("invoiceType"),
            "id": obj.get("id"),
            "referenceNumber": obj.get("referenceNumber"),
            "date": obj.get("date"),
            "remitToParty": PartyIdentification.from_dict(obj["remitToParty"]) if obj.get("remitToParty") is not None else None,
            "shipToParty": PartyIdentification.from_dict(obj["shipToParty"]) if obj.get("shipToParty") is not None else None,
            "shipFromParty": PartyIdentification.from_dict(obj["shipFromParty"]) if obj.get("shipFromParty") is not None else None,
            "billToParty": PartyIdentification.from_dict(obj["billToParty"]) if obj.get("billToParty") is not None else None,
            "paymentTerms": PaymentTerms.from_dict(obj["paymentTerms"]) if obj.get("paymentTerms") is not None else None,
            "invoiceTotal": Money.from_dict(obj["invoiceTotal"]) if obj.get("invoiceTotal") is not None else None,
            "taxDetails": [TaxDetails.from_dict(_item) for _item in obj["taxDetails"]] if obj.get("taxDetails") is not None else None,
            "additionalDetails": [AdditionalDetails.from_dict(_item) for _item in obj["additionalDetails"]] if obj.get("additionalDetails") is not None else None,
            "chargeDetails": [ChargeDetails.from_dict(_item) for _item in obj["chargeDetails"]] if obj.get("chargeDetails") is not None else None,
            "allowanceDetails": [AllowanceDetails.from_dict(_item) for _item in obj["allowanceDetails"]] if obj.get("allowanceDetails") is not None else None,
            "items": [InvoiceItem.from_dict(_item) for _item in obj["items"]] if obj.get("items") is not None else None
        })
        return _obj


