# coding: utf-8

"""
    Amazon Shipping API

    The Amazon Shipping API is designed to support outbound shipping use cases both for orders originating on Amazon-owned marketplaces as well as external channels/marketplaces. With these APIs, you can request shipping rates, create shipments, cancel shipments, and track shipments.

    The version of the OpenAPI document: v2
    Contact: swa-api-core@amazon.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from py_sp_api.generated.shippingV2.models.currency import Currency
from py_sp_api.generated.shippingV2.models.dangerous_goods_details import DangerousGoodsDetails
from py_sp_api.generated.shippingV2.models.direct_fulfillment_item_identifiers import DirectFulfillmentItemIdentifiers
from py_sp_api.generated.shippingV2.models.invoice_details import InvoiceDetails
from py_sp_api.generated.shippingV2.models.liquid_volume import LiquidVolume
from py_sp_api.generated.shippingV2.models.weight import Weight
from typing import Optional, Set
from typing_extensions import Self

class Item(BaseModel):
    """
    An item in a package.
    """ # noqa: E501
    item_value: Optional[Currency] = Field(default=None, alias="itemValue")
    description: Optional[StrictStr] = Field(default=None, description="The product description of the item.")
    item_identifier: Optional[StrictStr] = Field(default=None, description="A unique identifier for an item provided by the client.", alias="itemIdentifier")
    quantity: StrictInt = Field(description="The number of units. This value is required.")
    weight: Optional[Weight] = None
    liquid_volume: Optional[LiquidVolume] = Field(default=None, alias="liquidVolume")
    is_hazmat: Optional[StrictBool] = Field(default=None, description="When true, the item qualifies as hazardous materials (hazmat). Defaults to false.", alias="isHazmat")
    dangerous_goods_details: Optional[DangerousGoodsDetails] = Field(default=None, alias="dangerousGoodsDetails")
    product_type: Optional[StrictStr] = Field(default=None, description="The product type of the item.", alias="productType")
    invoice_details: Optional[InvoiceDetails] = Field(default=None, alias="invoiceDetails")
    serial_numbers: Optional[List[StrictStr]] = Field(default=None, description="A list of unique serial numbers in an Amazon package that can be used to guarantee non-fraudulent items. The number of serial numbers in the list must be less than or equal to the quantity of items being shipped. Only applicable when channel source is Amazon.", alias="serialNumbers")
    direct_fulfillment_item_identifiers: Optional[DirectFulfillmentItemIdentifiers] = Field(default=None, alias="directFulfillmentItemIdentifiers")
    __properties: ClassVar[List[str]] = ["itemValue", "description", "itemIdentifier", "quantity", "weight", "liquidVolume", "isHazmat", "dangerousGoodsDetails", "productType", "invoiceDetails", "serialNumbers", "directFulfillmentItemIdentifiers"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Item from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of item_value
        if self.item_value:
            _dict['itemValue'] = self.item_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of weight
        if self.weight:
            _dict['weight'] = self.weight.to_dict()
        # override the default output from pydantic by calling `to_dict()` of liquid_volume
        if self.liquid_volume:
            _dict['liquidVolume'] = self.liquid_volume.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dangerous_goods_details
        if self.dangerous_goods_details:
            _dict['dangerousGoodsDetails'] = self.dangerous_goods_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invoice_details
        if self.invoice_details:
            _dict['invoiceDetails'] = self.invoice_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of direct_fulfillment_item_identifiers
        if self.direct_fulfillment_item_identifiers:
            _dict['directFulfillmentItemIdentifiers'] = self.direct_fulfillment_item_identifiers.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Item from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "itemValue": Currency.from_dict(obj["itemValue"]) if obj.get("itemValue") is not None else None,
            "description": obj.get("description"),
            "itemIdentifier": obj.get("itemIdentifier"),
            "quantity": obj.get("quantity"),
            "weight": Weight.from_dict(obj["weight"]) if obj.get("weight") is not None else None,
            "liquidVolume": LiquidVolume.from_dict(obj["liquidVolume"]) if obj.get("liquidVolume") is not None else None,
            "isHazmat": obj.get("isHazmat"),
            "dangerousGoodsDetails": DangerousGoodsDetails.from_dict(obj["dangerousGoodsDetails"]) if obj.get("dangerousGoodsDetails") is not None else None,
            "productType": obj.get("productType"),
            "invoiceDetails": InvoiceDetails.from_dict(obj["invoiceDetails"]) if obj.get("invoiceDetails") is not None else None,
            "serialNumbers": obj.get("serialNumbers"),
            "directFulfillmentItemIdentifiers": DirectFulfillmentItemIdentifiers.from_dict(obj["directFulfillmentItemIdentifiers"]) if obj.get("directFulfillmentItemIdentifiers") is not None else None
        })
        return _obj


