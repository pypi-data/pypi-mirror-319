import sys
import pkg_resources
import datetime
import xml.dom.minidom
from typing import (Optional, List)
from xml.dom.minidom import (Element, Document)
import assetic.assetic_sdk
from assetic import OData
from assetic.tools import APIHelper
from assetic.rest import ApiException
from assetic.api import AssetConfigurationApi, FunctionalLocationApi


class XMLConfigVerifier:
    """
    A class to parse XML configuration files and provide summary data/
    error data for GIS Integration clients.
    """

    def __init__(self, xml_fp, ini_fp, conf_output):

        # file path of the xml file
        self.fp = xml_fp

        # file path of the auth ini file
        self.ini_fp = ini_fp

        # access to the sdk to call the API to check on things
        self.sdk = assetic.assetic_sdk.AsseticSDK(ini_fp)

        # api to call things
        self.api = APIHelper()

        # the file path of the final output
        self.conf_output = conf_output

        # api to call the Asset Configuration
        self.asset_config_api = AssetConfigurationApi()

        # api to call the Functional Location
        self.fl_api = FunctionalLocationApi()

        # error trackers
        self.errors = []
        self.warnings = []

        # a list to keep track of output lines
        self.output_values = []

        # attempt to read the xml file and return the dom
        self.dom = self.init_dom(xml_fp)

        # list of valid asset category labels to be retrieved from the API
        self._valid_asset_cat_labels = None

        # list of valid functional location types to be retrieved from the API
        self._valid_fl_types = None

        # we can use this to retrieve the oData lists of attributes
        self.odata = OData()

        self.protected_values = {"assets": ["asset_name", "asset_id", "functional_location_name"]}

    @property
    def valid_fl_types(self):

        # type: () -> dict
        """
        Stores a list of valid functional location types.
        """
        if self._valid_fl_types is None:
            kwargs = {
                'request_params_page': 1,
                'request_params_page_size': 500
            }
            try:
                fl_type = self.asset_config_api.asset_configuration_get_group_asset_types(**kwargs)
            except ApiException as e:
                self.logger.error("Status {0}, Reason: {1} {2}".format(
                    e.status, e.reason, e.body))
                return e.status
            fl_type_dict = {l["FunctionalLocationTypeName"]: {"auto id": l["UseAutogeneratedId"]} for l in
                            fl_type["ResourceList"]}
            for page in range(2, int(fl_type["TotalPages"]) + 1):
                kwargs["request_params_page"] = page
                # now execute the request
                try:
                    response = self.asset_config_api.asset_configuration_get_group_asset_types(**kwargs)
                except ApiException as e:
                    self.logger.error("Status {0}, Reason: {1} {2}".format(e.status, e.reason, e.body))
                    return e.status
                fl_type_dict1 = {l["FunctionalLocationTypeName"]: {"auto id": l["UseAutogeneratedId"]} for l in
                                 response["ResourceList"]}
                fl_type_dict.update(fl_type_dict1)
            self._valid_fl_types = fl_type_dict
        return self._valid_fl_types

    @property
    def valid_asset_cat_labels(self):
        # type: () -> dict
        """
        Stores a list of valid asset category labels.
        """

        if self._valid_asset_cat_labels is None:
            try:
                asset_cat = self.asset_config_api.asset_configuration_get_asset_category()
            except ApiException as e:
                self.logger.error("Status {0}, Reason: {1} {2}".format(
                    e.status, e.reason, e.body))
                return e.status
            self._valid_asset_cat_labels = {l["Label"]: {"auto id": l["UseAutogeneratedId"]} for l in
                                            asset_cat["ResourceList"]}

        return self._valid_asset_cat_labels

    def init_dom(self, fp):
        # type: (str) -> Optional[Document]
        """
        Initialises the document object by reading the file path.
        """
        try:
            dom = xml.dom.minidom.parse(fp)
        except xml.parsers.expat.ExpatError:
            self.errors.append("FATAL: File [{0}] is inappropriately formed. Ensure that all tags "
                               "(elements contained within brackets, e.g. <tag>tag-contents</tag>)"
                               " have starting and ending brackets.".format(fp))
            return None
        except FileNotFoundError:
            self.errors.append("FATAL: File [{0}] cannot be accessed by the XML configuration "
                               "parser service. It either does not exist, or the configuration "
                               "does not have rights to access its parent folder.".format(fp))
            return None
        return dom

    def get_element(self, element, tag):
        # type: (Element, str) -> Element
        """
        Convenience method to return a value of a tag

        Will log an error if there is more than one element with the
        given tag, and will only return the first instance.
        """
        els = element.getElementsByTagName(tag)
        if len(els) == 0:
            raise TypeError
        elif len(els) > 1:
            self.errors.append("XML NODE ERROR: The tag {0} appears "
                               "more than once in the parent element. {0} "
                               "may only appear once. The first instance "
                               "<{0}>{1}</{0}> will be used, and the rest ignored."
                               .format(tag, els[0].childNodes[0].nodeValue))

        return els[0]

    def get_attributes(self, lyr, tagname):
        # type: (Element, str) -> dict
        """
        Retrieves all of the attributes from the layer
        with the given tag name. Returns an empty dict if
        nothing is defined.
        """
        try:
            fields = self.get_element(lyr, tagname)
        except TypeError:
            # e.g. the node is not defined
            return {}

        mps = {}
        for attr in fields.childNodes:
            if type(attr) == xml.dom.minidom.Text:
                continue

            try:
                mps[attr.tagName] = attr.childNodes[0].nodeValue
            except IndexError:
                pass

        return mps

    def output_summary(self, mode="w"):
        # type: (str) -> None
        """
        Outputs all of the items appended to output_values to the
        defined configuration output file.
        :param: mode <str> 'w' over-writes contents and 'a' appends to
                the bottom of the file
        """
        outro = ("\n\nIf you are having trouble suppressing warnings/ solving "
                 "errors, or are unable to get your GIS integration to function "
                 "properly, please consult Assetic's Knowledge Base ("
                 "https://assetic.zendesk.com/hc/en-us/categories/115002261967-Integration-SDKs) "
                 "or lodge a support ticket in your environment ({0})"
                 .format(self.api.host))

        with open(self.conf_output, mode) as f:
            f.write("\n".join(self.output_values))

            f.write(outro)

    def parse_fls(self, fl_mappings):
        # type: (dict) -> None
        """
        Functional locations require EITHER:
            -   Functional Location Friendly ID
                    OR
            -   Functional Location Name, and
            -   Functional Location Type
        """

        errors = False

        if len(fl_mappings) == 0:
            # e.g. there is no functional location information
            # defined in the layer
            return
        if "functional_location_id" in fl_mappings.keys():
            # if there is and ID is present, this is fine
            return

        if "functional_location_name" not in fl_mappings.keys():
            self.errors.append("FUNCTIONAL LOCATION: Functional location name (in addition "
                               "to functional location type) must be defined in configuration"
                               " file if `functional_location_id` not defined.")
            errors = True
        if "functional_location_type" not in fl_mappings.keys():
            self.errors.append("FUNCTIONAL LOCATION: Functional location type (in addition "
                               "to functional location name) must be defined in configuration"
                               " file if `functional_location_id` not defined.")
            errors = True

        fl_mappings["CONFIGURATION VALID"] = not errors

    def get_creation_status(self, layer):
        # type: (Element) -> str
        """
        Retrieves creation status of the asset layer. Defaults to
        'Active' if not defined.
        """
        valid = ["Notional Asset", "Proposed", "Active"]

        try:
            val = self.get_element(layer, "creation_status")
            cs = val.childNodes[0].nodeValue
        except TypeError:
            self.warnings.append("CREATION STATUS: No creation status for layer {0} defined. "
                                 "Will default to 'Active'.".format(layer.getAttribute("name")))
            cs = "Active"

        if cs not in valid:
            self.errors.append("CREATION STATUS: Creation status [{0}] is not a valid status. "
                               "Valid statuses: {1}".format(cs, valid))
        return cs

    def get_upload_feature(self, layer):
        # type: (Element) -> bool
        """
        Retrieves the boolean value indicating if the asset row
        will be uploaded as a spatial feature. As this is a GIS integration
        it will usually be yes.
        """
        try:
            val = self.get_element(layer, "upload_feature")
            bval = str(val.childNodes[0].nodeValue).upper() == "TRUE"
        except TypeError:
            bval = False

        if bval is False:
            self.warnings.append("SPATIAL: Upload Feature tag (<upload_feature>True/False"
                                 "</upload_feature> set to False. No spatial information will "
                                 "be uploaded against features for this layer.")

        return bval

    def get(self, element, attr):
        # type: (Element, str) -> str
        """
        Convenienence method to return a nodeValue of an attribute
        """
        el = self.get_element(element, attr)
        return el.childNodes[0].nodeValue

    def get_logfile_loc(self):
        """
        Attempts to retrieve the value of the logfile.
        """
        try:
            el = self.get_element(self.dom, "logfile")
        except TypeError:
            # e.g. doesn't contain the node
            self.warnings.append("LOGFILE: Logfile (<logfile>path/to/logfile.txt</logfile> "
                                 "has not been defined. You may not be able to monitor output at "
                                 "a later date.")

            return "No log file defined."

        logfilefp = el.childNodes[0].nodeValue

        return logfilefp

    def get_logfile_level(self):
        """
        Attempts to retrieve the value of the loglevel.
        """
        try:
            el = self.get_element(self.dom, "loglevel")
        except TypeError:
            # e.g. doesn't contain the node
            self.warnings.append("LOG LEVEL: Log level (<loglevel>debug/info/error/warning</loglevel> "
                                 "has not been defined. The default is warning, which is not "
                                 "very informative.")

            return "WARNING"

        loglevel_ = el.childNodes[0].nodeValue

        return loglevel_

    def display_layer_attr_info(self, i, lyr, mappings):
        # type: (int, Element, dict) -> None
        """
        Displays some basic information about each layer.

        Currently displays:
            -   Upload feature True/False
            -   Asset creation status
        """
        self.add_to_output("Layer {0}: {1}".format(i, lyr.getAttribute("name")))

        upload = self.get_upload_feature(lyr)
        self.add_to_output("Upload spatial information for asset: {0}".format(upload), num_tabs=1)
        creation_status = self.get_creation_status(lyr)
        self.add_to_output("Asset status on creation: {0}".format(creation_status), num_tabs=1)

        for val, m in mappings.items():
            self.display_attrs(val, m)

    def display_attrs(self, title, mappings, num_tabs=1):
        # type: (str, dict, int) -> None
        """
        Method to display the key-value pairs of the passed in mappings.
        :param: title <str> the heading/title for the mappings
        :param: mappings <dict> the key, value pairs for the mappings (will be in format
                key: assetic attribute, value: GIS layer col name)
        :param: num_tabs <int> the number of indents for the line
        """
        self.add_to_output(title, num_tabs=num_tabs)
        if len(mappings) == 0:
            # nothing passed in, return early
            self.add_to_output("*\tno values defined\t*", num_tabs=num_tabs + 1)
            return

        for k, v in mappings.items():
            msg = "-\t{0}: {1}".format(k, v)
            # todo complete oData validation (see message at bottom)
            # invalid = self.odata.asset_odata.get(v, True)
            #
            # if invalid:
            #     msg += "\t|\tINVALID"
            #     self.errors.append("XML attribute '{0}' (with GIS value '{1}') is "
            #                        "not found in Assetic's Asset oData metadata (source: "
            #                        "{2}/odata/$metadata/). Please ensure values are correctly "
            #                        "spelled and found in metadata list.\n"
            #                        .format(k, v, self.api.host))

            self.add_to_output(msg, num_tabs=num_tabs + 1)

    def add_to_output(self, msg, num_tabs=0):
        # type: (str, int) -> None
        """
        Convenience method to add text to the output list.
        :param: num_tabs <int> the number of indents to the output
                that the method will insert (used to nest info)
        """
        tabs = "".join(["\t" for _ in range(num_tabs)])
        self.output_values.append("{0}{1}".format(tabs, msg))

    def parse_address_fields(self, fields, defs):
        # type: (dict, dict) -> dict
        """
        Checks defined address information so that it contains the minimum
        amount required (at a minimum, 'Country' is required).

        :param: fields <dict> mappings for address attribute fields
        :param: defs <dict> default values for address fields
        """

        keys = list(fields.keys()) + list(defs.keys())

        if len(keys) == 0:
            return {}

        errors = False
        if "country" not in keys:
            errors = True
            self.errors.append("ADDRESS: The minimum information required for "
                               "address definitions is the value 'Country'. "
                               "Values currently defined: {0}".format(keys))

        return {"CONFIGURATION VALID": not errors}

    def display_cp_info(self, cp_mappings):
        # type: (dict) -> None
        """
        Displays component info for each asset.
        """
        self.add_to_output("Component", num_tabs=1)
        for val, m in cp_mappings.items():
            self.display_attrs(val, m, num_tabs=2)

    def display_dimension_info(self, d_mappings, j):
        # type: (dict, int) -> None
        """
        Displays dimension info for each component.
        """
        self.add_to_output("Dimension {0}".format(j), num_tabs=3)
        for val, m in d_mappings.items():
            self.display_attrs(val, m, num_tabs=4)

    def flush_errors_and_warnings(self):
        """
        Writes all errors to the output.
        """
        msg = ""
        if len(self.errors) > 0:
            msg += ("There were {0} errors while parsing the XML configuration file.\n\n"
                    "### ERRORS ###\n\n".format(len(self.errors)))

            for i, e in enumerate(self.errors, start=1):
                msg += "{0}:\t{1}\n".format(i, e)

            msg += "\n\nThese need to be fixed before the integration will work properly."

        if len(self.warnings) > 0:
            msg += ("There were {0} warning(s) while parsing the XML configuration file.\n\n"
                    "### WARNINGS ###\n\n".format(len(self.warnings)))

            for i, e in enumerate(self.warnings):
                msg += "{0}:\t{1}\n".format(i, e)

            msg += "\n\nThese may not require attention but may affect the expected output " \
                   "of the integration."

        with open(self.conf_output, "w") as f:
            f.write(msg)
            f.write("\n\n")

    def perform_user_checks(self):
        """
        Ensures that the user exists and has appropriate privileges.
        """
        r = self.api.generic_get("/api/v2/auth")

        required = {
            "Type": "Assetic/Admin/AssetRegisterConfigure",
            "Value": "Delete"
        }
        has_auth = False
        for claim in r["Claims"]:
            if claim == required:
                has_auth = True
                break
        else:
            # e.g. user does not have appropriate privilege
            self.errors.append("USER ERROR: user defined in auth ini (location: "
                               "{0}) does not have appropriate privileges to create/ "
                               "update assets. To ensure integration can work, user "
                               "must have either clientAdmin or assetsAdmin role."
                               .format(self.ini_fp))

        self.add_to_output("### USER INFO ###\n"
                           "User ({0}) has appropriate privileges:\t{1}\n"
                           .format(self.api.api_client.configuration.username, has_auth))

        self.add_to_output("")

    def process_component_node(self, cp):
        cp_mappings = {
            "Component Fields": self.get_attributes(cp, "componentfields"),
            "Component Defaults": self.get_attributes(cp, "componentdefaults")
        }
        self.display_cp_info(cp_mappings)

    def process_dimension_nodes(self, dims):
        self.add_to_output("Dimensions ({0})".format(len(dims)), num_tabs=2)
        if len(dims) == 0:
            self.add_to_output("*\tno values defined\t*", num_tabs=3)
        for j, d in enumerate(dims, start=1):
            d_mappings = {
                "Dimension Fields": self.get_attributes(d, "dimensionfields"),
                "Dimension Defaults": self.get_attributes(d, "dimensiondefaults")
            }
            self.display_dimension_info(d_mappings, j)

    def parse_asset_core_fields(self, cat, core_fields):
        """
        Ensures the asset core fields contains all of the information
        required for an asset.
        """
        valid = True
        if "asset_name" not in core_fields.keys():
            valid = False
            self.errors.append("ASSET CORE FIELD ERROR: asset_name is a required field "
                               "for all assets created in Assetic Cloud, and it is not "
                               "defined in the XML configuration.")

        autoid = self.valid_asset_cat_labels[cat]["auto id"]

        if (autoid is False) and ("asset_id" not in core_fields.keys()):
            valid = False
            self.errors.append("ASSET CORE FIELD ERROR: asset_id is required when "
                               "creating assets in categories that do not have auto ID "
                               "enabled. If you do not wish for asset IDs to be automatically "
                               "generated, this option can be toggled in the admin console ({}"
                               "/Admin/AssetRegister/)"
                               .format(self.api.host))

        if (autoid is True) and ("asset_id" not in core_fields.keys()):
            self.warnings.append("ASSET CORE FIELD WARNING: asset auto ID is enabled "
                                 "but asset_id has not been defined in the configuration. "
                                 "Any auto-generated asset IDs created in Assetic Cloud will "
                                 "not be written back to the GIS layer.")

        core_fields["CONFIGURATION VALID"] = valid

    def process_asset_node(self, cat, i, layer):
        core_fields = self.get_attributes(layer, "corefields")
        self.parse_asset_core_fields(cat, core_fields)
        asset_mappings = {
            "Asset Core Fields": core_fields,
            "Asset Core Defaults": self.get_attributes(layer, "coredefaults"),
            "Asset Attributes": self.get_attributes(layer, "attributefields"),
            "Asset Attribute Defaults": self.get_attributes(layer, "attributedefaults"),
        }

        addr_fields = self.get_attributes(layer, "addressfields")
        addr_defs = self.get_attributes(layer, "addressdefaults")

        addr_sum = self.parse_address_fields(addr_fields, addr_defs)

        asset_mappings.update({
            "Address Fields": addr_fields,
            "Address Defaults": addr_defs,
        })
        if len(addr_sum) > 0:
            asset_mappings["Address Summary"] = addr_sum

        fls = self.get_attributes(layer, "functional_location")
        self.parse_fls(fls)
        asset_mappings["Functional Location Definition"] = fls

        self.display_layer_attr_info(i, layer, asset_mappings)

        self.add_to_output("")

    def parse_layer_asset_category(self, layer):

        cat_node = self.get_element(layer, "category")
        cat = cat_node.firstChild.nodeValue
        if cat not in list(self.valid_asset_cat_labels.keys()):
            self.errors.append("CATEGORY: [{0}] is not present in Assetic environment. "
                               "Check Asset Register ({1}/Admin/AssetRegister/) "
                               "to ensure the category has been enabled or is "
                               "spelled/formatted correctly".format(cat, self.api.host))

        return cat

    def get_functional_location_layer_from_dom(self):
        # type: () -> Optional[Element]
        fl = None
        ops = self.dom.getElementsByTagName("operation")
        for o in ops:
            if o.getAttribute("action") == "Functional Location":
                fl = o
                break
        return fl

    def get_asset_layers_from_dom(self):
        # type: () -> List[Element]
        """
        Retrieves all of the asset configuration layers from the DOM.
        """

        asset = None
        ops = self.dom.getElementsByTagName("operation")
        for o in ops:
            if o.getAttribute("action") == "Asset":
                asset = o
                break
        if asset is None:
            self.errors.append("FATAL: No asset layers defined.")

        layers = asset.getElementsByTagName("layer")

        return layers

    def output_asset_layers_summary(self, layers):
        self.add_to_output("### ASSET CONFIGURATION ###")
        self.add_to_output("Present Asset Layers:")
        for i, l in enumerate(layers, start=1):
            cat_node = self.get_element(l, "category")
            cat = cat_node.firstChild.nodeValue
            self.add_to_output("{0}.\t{1}".format(i, l.getAttribute("name")), num_tabs=1)
            self.add_to_output("-\tAsset category: {0}".format(cat), num_tabs=2)
            autoid = self.valid_asset_cat_labels[cat]["auto id"]
            self.add_to_output("-\tAuto ID: {0}".format(autoid), num_tabs=2)

        self.add_to_output("")

    def output_xml_info(self):
        pkgs = {d.project_name: d.version for d in pkg_resources.working_set}

        lf_loc = self.get_logfile_loc()
        lf_level = self.get_logfile_level()

        dt = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        intro = ("### Assetic GIS Integration XML Configuration Parser ###\n\n"
                 "Creation Date:        {0}\n"
                 "Logfile location:     {1}\n"
                 "Loglevel:             {2}\n"
                 "XML location:         {3}\n\n"
                 "Python version:       {4}\n"
                 "python-sdk version:   {5}\n"
                 "assetic-qgis version: {6}\n"

                 .format(dt, lf_loc, lf_level, self.fp, sys.version,
                         pkgs.get("assetic", "NOT INSTALLED"),
                         pkgs.get("assetic-qgis", "NOT INSTALLED")))

        self.add_to_output(intro)

    def check_functional_location_core_default(self, core_defaults):
        fl_core_defaults_dict = {}
        valid = True
        for key, value in core_defaults.items():
            if key == "functional_location_type":
                if value not in list(self.valid_fl_types.keys()):
                    self.errors.append(
                        "FUNCTIONAL LOCATION TYPE CORE DEFAULT ERROR: [{0}] is not present in Assetic environment. "
                        "Check Asset Register ({1}/Admin/AssetRegister/) "
                        "to ensure the FUNCTIONAL LOCATION TYPE  has been enabled or is "
                        "spelled/formatted correctly".format(value, self.api.host))
                    valid = False

            if key == "functional_location_name":
                if len(value) == 0:
                    self.errors.append(
                        "FUNCTIONAL LOCATION NAME CORE DEFAULT ERROR: Functional Location name should not be empty if "
                        "it the tag is defined in core default")

                    valid = False
        core_defaults["CONFIGURATION VALID"] = valid
        return core_defaults

    def parse_fl_core_default_n_field(self, core_defaults, core_fields):
        """
        Ensures the functional location core fields and core defaults contains all of the information
        required for functional location.
        """
        valid = True
        # Check default first

        if ("functional_location_name" not in core_defaults.keys()) and ("functional_location_name" not in core_fields):
            valid = False
            self.errors.append("FUNCTIONAL LOCATION NAME ERROR: functional_location_name is a required field "
                               "for all functional location created in Assetic Cloud, and it is not "
                               "defined either in core defaults or core fields in the XML configuration.")
        if ("functional_location_name" in core_defaults.keys()) and ("functional_location_name" in core_fields):
            valid = False
            self.errors.append(
                "FUNCTIONAL LOCATION NAME ERROR: functional_location_name is defined in both core defaults and core "
                "fields "
                "functional_location_name in core fields will be overwritten by functional_location_name in core "
                "defaults ")
        if ("functional_location_type" not in core_defaults.keys()) and ("functional_location_type" not in core_fields):
            valid = False
            self.errors.append("FUNCTIONAL LOCATION TYPE ERROR: functional_location_type is a required field "
                               "for all functional location created in Assetic Cloud, and it is not "
                               "defined either in core defaults or core fields in the XML configuration.")
        if ("functional_location_type" in core_defaults.keys()) and ("functional_location_type" in core_fields):
            valid = False
            self.errors.append(
                "FUNCTIONAL LOCATION NAME ERROR: functional_location_type is defined in both core defaults and core "
                "fields "
                "functional_location_type in core fields will be overwritten by functional_location_name in core "
                "defaults ")
        if "functional_location_type" in core_defaults.keys():
            autoid = self.valid_fl_types[core_defaults["functional_location_type"]]["auto id"]

            if (autoid is False) and ("functional_location_id" not in core_fields.keys()):
                valid = False
                self.errors.append("FUNCTIONAL LOCATION CORE FIELD ERROR: functional_location_id is required when "
                                   "auto ID in functional location type is not "
                                   "enabled. If you wish for Functional location IDs to be automatically "
                                   "generated, this option can be toggled in the admin console ({}"
                                   "/Admin/AssetRegister/)"
                                   .format(self.api.host))

            if (autoid is True) and ("functional_location_id" not in core_fields.keys()):
                self.warnings.append("FUNCTIONAL LOCATION CORE FIELD WARNING: Functional location auto ID is enabled "
                                     "but functional_location_id has not been defined in the configuration. "
                                     "Any auto-generated functional_location_id IDs created in Assetic Cloud will "
                                     "not be written back to the GIS layer.")

        elif ("functional_location_type" in core_fields.keys()) and (
                "functional_location_id" not in core_fields.keys()):
            valid = False
            self.errors.append("FUNCTIONAL LOCATION CORE FIELD ERROR: functional_location_id is required when"
                               "functional location type is defined in the core fields instead of core defaults")

        core_fields["CONFIGURATION VALID"] = valid

    def parse_fl_layer(self, fllayer):
        # type: (Element) -> None
        self.add_to_output("### FUNCTIONAL LOCATION CONFIGURATION ###\n")

        if fllayer is None:
            self.add_to_output("*\tno FL configuration defined\t*")
            return

        self.output_functional_location_layer_summary(fllayer)
        lyrs = fllayer.getElementsByTagName("layer")

        for i, lyr in enumerate(lyrs, start=1):
            fl_core_defaults_dict = {}
            core_defaults = self.get_attributes(lyr, "fl_coredefaults")
            if len(core_defaults) != 0:
                self.check_functional_location_core_default(core_defaults)
            core_fields = self.get_attributes(lyr, "fl_corefields")
            self.parse_fl_core_default_n_field(core_defaults, core_fields)
            self.add_to_output("Layer {0}:\t{1}".format(i, lyr.getAttribute("name")), num_tabs=0)
            mappings = {
                "FL Core Fields": core_fields,
                "FL Core Defaults": core_defaults,
                "FL Attribute Fields": self.get_attributes(lyr, "fl_attributefields"),
                "FL Attribute Defaults": self.get_attributes(lyr, "fl_attributedefaults"),
            }

            for val, m in mappings.items():
                self.display_attrs(val, m)

    def output_functional_location_layer_summary(self, fl_lyr):

        self.add_to_output("Present Functional Location Layers for CoreDefaults:")
        layers = fl_lyr.getElementsByTagName("layer")
        for i, lyr in enumerate(layers, start=1):
            fl_coredefaults = self.get_attributes(lyr, "fl_coredefaults")
            if "functional_location_type" in fl_coredefaults.keys():
                autoid = self.valid_fl_types[fl_coredefaults["functional_location_type"]]["auto id"]
                self.add_to_output("{0}.\t{1}".format(i, lyr.getAttribute("name")), num_tabs=1)
                self.add_to_output(
                    "-\tFunctional Location Type: {0}".format(fl_coredefaults["functional_location_type"]), num_tabs=2)
                self.add_to_output("-\tAuto ID: {0}".format(autoid), num_tabs=2)

        self.add_to_output("")

    def run(self):

        if self.dom is None:
            # there was an initilisation error
            self.flush_errors_and_warnings()
            return

        self.output_xml_info()

        self.perform_user_checks()

        as_layers = self.get_asset_layers_from_dom()

        self.output_asset_layers_summary(as_layers)

        for i, alyr in enumerate(as_layers, start=1):
            cat = self.parse_layer_asset_category(alyr)

            self.process_asset_node(cat, i, alyr)

            cps = alyr.getElementsByTagName("component")
            for cp in cps:
                self.process_component_node(cp)

                dims = cp.getElementsByTagName("dimension")
                self.process_dimension_nodes(dims)

        fl_layer = self.get_functional_location_layer_from_dom()
        self.parse_fl_layer(fl_layer)

        if (len(self.errors) > 0) or (len(self.warnings) > 0):
            self.flush_errors_and_warnings()
            self.output_summary(mode="a")
        else:
            self.output_summary(mode="w")


if __name__ == '__main__':
    xmlfile = r"C:\repos\gis\assetic_qgis_sdk\user_config_files\gis_edit_config.xml"
    inifile = r"C:\repos\test.ini"
    logfile = r"C:\repos\assetic_qgis_sdk\log.txt"

    _conf_output = r"C:\repos\conf_output.txt"
    x = XMLConfigVerifier(xmlfile, inifile, _conf_output)
    x.run()

"""
there is a dict somewhere that describes the relationship between the snake_case and camelcase 
corefields in the swagger documentation or somewhere else

find this and then update the odata search so that it doesn't freak out when
it attempts to find 'asset_id' in the oData keys
"""
