
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "iree_input"

@_ods_cext.register_operation(_Dialect)
class AlignOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.align"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, alignment, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(alignment))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def alignment(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def align(value, alignment, *, loc=None, ip=None) -> _ods_ir.Value:
  return AlignOp(value=value, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferSubspanOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.buffer.subspan"

  _ODS_REGIONS = (0, True)

  def __init__(self, source_buffer, source_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source_buffer))
    operands.append(_get_op_result_or_value(source_offset))
    operands.append(_get_op_result_or_value(length))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def length(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_subspan(source_buffer, source_offset, length, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferSubspanOp(source_buffer=source_buffer, source_offset=source_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.buffer_view.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, source_buffer, source_offset, source_length, element_type, encoding_type, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source_buffer))
    operands.append(_get_op_result_or_value(source_offset))
    operands.append(_get_op_result_or_value(source_length))
    operands.append(_get_op_result_or_value(element_type))
    operands.append(_get_op_result_or_value(encoding_type))
    operands.extend(_get_op_results_or_values(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def source_length(self):
    return self.operation.operands[2]

  @builtins.property
  def element_type(self):
    return self.operation.operands[3]

  @builtins.property
  def encoding_type(self):
    return self.operation.operands[4]

  @builtins.property
  def shape(self):
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[5:5 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_create(source_buffer, source_offset, source_length, element_type, encoding_type, shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewCreateOp(source_buffer=source_buffer, source_offset=source_offset, source_length=source_length, element_type=element_type, encoding_type=encoding_type, shape=shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewDimOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.buffer_view.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(buffer_view))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_dim(buffer_view, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewDimOp(buffer_view=buffer_view, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewRankOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.buffer_view.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(buffer_view))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_rank(buffer_view, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewRankOp(buffer_view=buffer_view, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ByteBufferConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.byte_buffer.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, name=None, alignment=None, mime_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(value, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def name(self):
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def mime_type(self):
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def byte_buffer_constant(value, *, name=None, alignment=None, mime_type=None, loc=None, ip=None) -> _ods_ir.Value:
  return ByteBufferConstantOp(value=value, name=name, alignment=alignment, mime_type=mime_type, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, workload, entry_point, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_point"] = (entry_point if (
    isinstance(entry_point, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(entry_point, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IREEInput_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('IREEInput_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def arguments(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def argument_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def entry_point(self):
    return self.operation.attributes["entry_point"]

  @entry_point.setter
  def entry_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_point"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def dispatch(results_, workload, entry_point, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DispatchOp(results_=results_, workload=workload, entry_point=entry_point, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, tied_operands=tied_operands, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupCountOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.dispatch.workgroup.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_count(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupCountOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupIDOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.dispatch.workgroup.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_id(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupIDOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.dispatch.workgroup.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_size(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupSizeOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.executable.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, layout, *, sym_visibility=None, ordinal=None, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IREEInput_OrdinalAttr')) else
          _ods_ir.AttrBuilder.get('IREEInput_OrdinalAttr')(ordinal, context=_ods_context))
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IREEInput_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('IREEInput_PipelineLayoutAttr')(layout, context=_ods_context))
    if workgroup_size is not None: attributes["workgroup_size"] = (workgroup_size if (
        isinstance(workgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IREEInput_WorkgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('IREEInput_WorkgroupSizeAttr')(workgroup_size, context=_ods_context))
    if subgroup_size is not None: attributes["subgroup_size"] = (subgroup_size if (
        isinstance(subgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IREEInput_SubgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('IREEInput_SubgroupSizeAttr')(subgroup_size, context=_ods_context))
    if workgroup_local_memory is not None: attributes["workgroup_local_memory"] = (workgroup_local_memory if (
        isinstance(workgroup_local_memory, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(workgroup_local_memory, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def ordinal(self):
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

  @builtins.property
  def layout(self):
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def workgroup_size(self):
    if "workgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_size"]

  @workgroup_size.setter
  def workgroup_size(self, value):
    if value is not None:
      self.operation.attributes["workgroup_size"] = value
    elif "workgroup_size" in self.operation.attributes:
      del self.operation.attributes["workgroup_size"]

  @workgroup_size.deleter
  def workgroup_size(self):
    del self.operation.attributes["workgroup_size"]

  @builtins.property
  def subgroup_size(self):
    if "subgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["subgroup_size"]

  @subgroup_size.setter
  def subgroup_size(self, value):
    if value is not None:
      self.operation.attributes["subgroup_size"] = value
    elif "subgroup_size" in self.operation.attributes:
      del self.operation.attributes["subgroup_size"]

  @subgroup_size.deleter
  def subgroup_size(self):
    del self.operation.attributes["subgroup_size"]

  @builtins.property
  def workgroup_local_memory(self):
    if "workgroup_local_memory" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.setter
  def workgroup_local_memory(self, value):
    if value is not None:
      self.operation.attributes["workgroup_local_memory"] = value
    elif "workgroup_local_memory" in self.operation.attributes:
      del self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.deleter
  def workgroup_local_memory(self):
    del self.operation.attributes["workgroup_local_memory"]

def executable_export(sym_name, layout, *, sym_visibility=None, ordinal=None, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableExportOp(sym_name=sym_name, layout=layout, sym_visibility=sym_visibility, ordinal=ordinal, workgroup_size=workgroup_size, subgroup_size=subgroup_size, workgroup_local_memory=workgroup_local_memory, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableSourceEndOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.executable.source_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

def executable_source_end(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableSourceEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableSourceOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.executable.source"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, objects=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if objects is not None: attributes["objects"] = (objects if (
        isinstance(objects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IREEInput_ExecutableObjectsAttr')) else
          _ods_ir.AttrBuilder.get('IREEInput_ExecutableObjectsAttr')(objects, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def objects(self):
    if "objects" not in self.operation.attributes:
      return None
    return self.operation.attributes["objects"]

  @objects.setter
  def objects(self, value):
    if value is not None:
      self.operation.attributes["objects"] = value
    elif "objects" in self.operation.attributes:
      del self.operation.attributes["objects"]

  @objects.deleter
  def objects(self):
    del self.operation.attributes["objects"]

  @builtins.property
  def body(self):
    return self.regions[0]

def executable_source(sym_name, *, sym_visibility=None, objects=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableSourceOp(sym_name=sym_name, sym_visibility=sym_visibility, objects=objects, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalAddressOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.global.address"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IREEInput_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('IREEInput_GlobalRefAttr')(global_, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def global_(self):
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def global_address(result, global_, *, loc=None, ip=None) -> _ods_ir.Value:
  return GlobalAddressOp(result=result, global_=global_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.global.load.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(global_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def global_(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def global_load_indirect(result, global_, *, loc=None, ip=None) -> _ods_ir.Value:
  return GlobalLoadIndirectOp(result=result, global_=global_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.global.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IREEInput_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('IREEInput_GlobalRefAttr')(global_, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def global_(self):
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def global_load(result, global_, *, loc=None, ip=None) -> _ods_ir.Value:
  return GlobalLoadOp(result=result, global_=global_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.global"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, initializer=None, initial_value=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if initializer is not None: attributes["initializer"] = (initializer if (
        isinstance(initializer, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(initializer, context=_ods_context))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
          _ods_ir.AttrBuilder.get('TypedAttrInterface')(initial_value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self):
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def initializer(self):
    if "initializer" not in self.operation.attributes:
      return None
    return self.operation.attributes["initializer"]

  @initializer.setter
  def initializer(self, value):
    if value is not None:
      self.operation.attributes["initializer"] = value
    elif "initializer" in self.operation.attributes:
      del self.operation.attributes["initializer"]

  @initializer.deleter
  def initializer(self):
    del self.operation.attributes["initializer"]

  @builtins.property
  def initial_value(self):
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

def global_(sym_name, type_, *, sym_visibility=None, is_mutable=None, initializer=None, initial_value=None, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalOp(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, initializer=initializer, initial_value=initial_value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.global.store.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(global_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def global_(self):
    return self.operation.operands[1]

def global_store_indirect(value, global_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalStoreIndirectOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.global.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IREEInput_GlobalRefAttr')) else
      _ods_ir.AttrBuilder.get('IREEInput_GlobalRefAttr')(global_, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def global_(self):
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store(value, global_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalStoreOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.list.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, initial_capacity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if initial_capacity is not None: operands.append(_get_op_result_or_value(initial_capacity))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def initial_capacity(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_create(result, *, initial_capacity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ListCreateOp(result=result, initial_capacity=initial_capacity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.list.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(list))
    operands.append(_get_op_result_or_value(index))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_get(result, list, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListGetOp(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListResizeOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.list.resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, new_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(list))
    operands.append(_get_op_result_or_value(new_size))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def new_size(self):
    return self.operation.operands[1]

def list_resize(list, new_size, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ListResizeOp(list=list, new_size=new_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.list.set"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(list))
    operands.append(_get_op_result_or_value(index))
    operands.append(_get_op_result_or_value(value))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

def list_set(list, index, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ListSetOp(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.list.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(list))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_size(list, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListSizeOp(list=list, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NullOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.null"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def result(self):
    return self.operation.results[0]

def null(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return NullOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OptimizationBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.optimization_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def optimization_barrier(results_, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(OptimizationBarrierOp(results_=results_, operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TensorBitCastOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.bitcast"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_bitcast(result, source, source_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorBitCastOp(result=result, source=source, source_dims=source_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorCloneOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.clone"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(operand))
    operands.extend(_get_op_results_or_values(operand_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_clone(operand, operand_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorCloneOp(operand=operand, operand_dims=operand_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorExportOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, source_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    operands.extend(_get_op_results_or_values(source_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(target)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def target(self):
    return self.operation.results[0]

def tensor_export(target, source, source_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorExportOp(target=target, source=source, source_dims=source_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorImportOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, target_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    operands.extend(_get_op_results_or_values(target_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(target)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def target(self):
    return self.operation.results[0]

def tensor_import(target, source, target_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorImportOp(target=target, source=source, target_dims=target_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.load"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_dims, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_load(source, source_dims, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorLoadOp(source=source, source_dims=source_dims, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.reshape"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_reshape(result, source, source_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorReshapeOp(result=result, source=source, source_dims=source_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.slice"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, start_indices, lengths, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_results_or_values(lengths))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def start_indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_slice(result, source, source_dims, start_indices, lengths, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorSliceOp(result=result, source=source, source_dims=source_dims, start_indices=start_indices, lengths=lengths, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSplatOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.extend(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def result_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_splat(result, value, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorSplatOp(result=result, value=value, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.store"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, target, target_dims, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(target))
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def target_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_store(value, target, target_dims, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorStoreOp(value=value, target=target, target_dims=target_dims, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTraceOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.trace"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, key, values, value_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(values))
    operands.append(_get_op_results_or_values(value_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def values(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def value_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def key(self):
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

def tensor_trace(key, values, value_dims, *, loc=None, ip=None) -> _ods_ir.Operation:
  return TensorTraceOp(key=key, values=values, value_dims=value_dims, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_input.tensor.update"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_dims, start_indices, update, update_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_result_or_value(update))
    operands.append(_get_op_results_or_values(update_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def start_indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def update(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def update_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_update(target, target_dims, start_indices, update, update_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorUpdateOp(target=target, target_dims=target_dims, start_indices=start_indices, update=update, update_dims=update_dims, loc=loc, ip=ip).result
