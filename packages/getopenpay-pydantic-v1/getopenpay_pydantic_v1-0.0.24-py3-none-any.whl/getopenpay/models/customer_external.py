# coding: utf-8

"""
    OpenPay API

    super charge your subscription management.

    The version of the OpenAPI document: 1.2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from datetime import datetime
from typing import Any, Dict, List, Optional

from getopenpay.models.complete_address import CompleteAddress
from getopenpay.models.customer_balance_external import CustomerBalanceExternal
from getopenpay.models.customer_invoice_settings import CustomerInvoiceSettings
from getopenpay.models.customer_language import CustomerLanguage
from getopenpay.models.customer_status import CustomerStatus
from getopenpay.models.customer_total_amount import CustomerTotalAmount
from getopenpay.models.discount_external import DiscountExternal
from getopenpay.models.object_name import ObjectName
from getopenpay.models.product_external import ProductExternal
from getopenpay.models.subscription_external import SubscriptionExternal
from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist


class CustomerExternal(BaseModel):
  """
    CustomerExternal
    """
  id: StrictStr = Field(..., description='Unique identifier of the customer.')
  object: Optional[ObjectName] = None
  created_at: datetime = Field(
    ..., description="DateTime at which the object was created, in 'ISO 8601' format."
  )
  updated_at: datetime = Field(
    ..., description="DateTime at which the object was updated, in 'ISO 8601' format."
  )
  is_deleted: Optional[StrictBool] = Field(
    False, description='If true, indicates that this object has been deleted'
  )
  account_id: StrictStr = Field(..., description='Unique identifier for the account.')
  email: StrictStr = Field(..., description='Customerâ€™s email address.')
  first_name: Optional[StrictStr] = Field(...)
  last_name: Optional[StrictStr] = Field(...)
  address: Optional[CompleteAddress] = Field(...)
  subscriptions: Optional[conlist(SubscriptionExternal)] = None
  balance_atoms: Optional[conlist(CustomerBalanceExternal)] = None
  subscribed_to_products: Optional[conlist(ProductExternal)] = None
  last_successful_payment_intent: Optional[PaymentIntentExternal] = None
  discount: Optional[DiscountExternal] = None
  metadata: Optional[Dict[str, Any]] = None
  notes: Optional[StrictStr] = Field(...)
  custom_fields: Optional[Dict[str, Any]] = None
  total_spent: Optional[conlist(CustomerTotalAmount)] = None
  total_refunds: Optional[conlist(CustomerTotalAmount)] = None
  mrr: Optional[conlist(CustomerTotalAmount)] = None
  billing_email: Optional[StrictStr] = None
  language: Optional[CustomerLanguage] = None
  invoice_settings: Optional[CustomerInvoiceSettings] = None
  should_send_payment_receipt: StrictBool = Field(
    ..., description='Whether email should be sent or not on payment.'
  )
  status: Optional[CustomerStatus] = None
  phone_number: Optional[StrictStr] = None
  __properties = [
    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'account_id', 'email', 'first_name',
    'last_name', 'address', 'subscriptions', 'balance_atoms', 'subscribed_to_products',
    'last_successful_payment_intent', 'discount', 'metadata', 'notes', 'custom_fields',
    'total_spent', 'total_refunds', 'mrr', 'billing_email', 'language', 'invoice_settings',
    'should_send_payment_receipt', 'status', 'phone_number'
  ]

  class Config:
    """Pydantic configuration"""
    allow_population_by_field_name = True
    validate_assignment = True

  def to_str(self) -> str:
    """Returns the string representation of the model using alias"""
    return pprint.pformat(self.dict(by_alias=True))

  def to_json(self) -> str:
    """Returns the JSON representation of the model using alias"""
    return json.dumps(self.to_dict())

  @classmethod
  def from_json(cls, json_str: str) -> CustomerExternal:
    """Create an instance of CustomerExternal from a JSON string"""
    return cls.from_dict(json.loads(json_str))

  def to_dict(self):
    """Returns the dictionary representation of the model using alias"""
    _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
    # override the default output from pydantic by calling `to_dict()` of address
    if self.address:
      _dict['address'] = self.address.to_dict()
    # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
    _items = []
    if self.subscriptions:
      for _item in self.subscriptions:
        if _item:
          _items.append(_item.to_dict())
      _dict['subscriptions'] = _items
    # override the default output from pydantic by calling `to_dict()` of each item in balance_atoms (list)
    _items = []
    if self.balance_atoms:
      for _item in self.balance_atoms:
        if _item:
          _items.append(_item.to_dict())
      _dict['balance_atoms'] = _items
    # override the default output from pydantic by calling `to_dict()` of each item in subscribed_to_products (list)
    _items = []
    if self.subscribed_to_products:
      for _item in self.subscribed_to_products:
        if _item:
          _items.append(_item.to_dict())
      _dict['subscribed_to_products'] = _items
    # override the default output from pydantic by calling `to_dict()` of last_successful_payment_intent
    if self.last_successful_payment_intent:
      _dict['last_successful_payment_intent'] = self.last_successful_payment_intent.to_dict()
    # override the default output from pydantic by calling `to_dict()` of discount
    if self.discount:
      _dict['discount'] = self.discount.to_dict()
    # override the default output from pydantic by calling `to_dict()` of each item in total_spent (list)
    _items = []
    if self.total_spent:
      for _item in self.total_spent:
        if _item:
          _items.append(_item.to_dict())
      _dict['total_spent'] = _items
    # override the default output from pydantic by calling `to_dict()` of each item in total_refunds (list)
    _items = []
    if self.total_refunds:
      for _item in self.total_refunds:
        if _item:
          _items.append(_item.to_dict())
      _dict['total_refunds'] = _items
    # override the default output from pydantic by calling `to_dict()` of each item in mrr (list)
    _items = []
    if self.mrr:
      for _item in self.mrr:
        if _item:
          _items.append(_item.to_dict())
      _dict['mrr'] = _items
    # override the default output from pydantic by calling `to_dict()` of invoice_settings
    if self.invoice_settings:
      _dict['invoice_settings'] = self.invoice_settings.to_dict()
    # set to None if first_name (nullable) is None
    # and __fields_set__ contains the field
    if self.first_name is None and 'first_name' in self.__fields_set__:
      _dict['first_name'] = None

    # set to None if last_name (nullable) is None
    # and __fields_set__ contains the field
    if self.last_name is None and 'last_name' in self.__fields_set__:
      _dict['last_name'] = None

    # set to None if address (nullable) is None
    # and __fields_set__ contains the field
    if self.address is None and 'address' in self.__fields_set__:
      _dict['address'] = None

    # set to None if last_successful_payment_intent (nullable) is None
    # and __fields_set__ contains the field
    if self.last_successful_payment_intent is None and 'last_successful_payment_intent' in self.__fields_set__:
      _dict['last_successful_payment_intent'] = None

    # set to None if discount (nullable) is None
    # and __fields_set__ contains the field
    if self.discount is None and 'discount' in self.__fields_set__:
      _dict['discount'] = None

    # set to None if metadata (nullable) is None
    # and __fields_set__ contains the field
    if self.metadata is None and 'metadata' in self.__fields_set__:
      _dict['metadata'] = None

    # set to None if notes (nullable) is None
    # and __fields_set__ contains the field
    if self.notes is None and 'notes' in self.__fields_set__:
      _dict['notes'] = None

    # set to None if custom_fields (nullable) is None
    # and __fields_set__ contains the field
    if self.custom_fields is None and 'custom_fields' in self.__fields_set__:
      _dict['custom_fields'] = None

    # set to None if billing_email (nullable) is None
    # and __fields_set__ contains the field
    if self.billing_email is None and 'billing_email' in self.__fields_set__:
      _dict['billing_email'] = None

    # set to None if invoice_settings (nullable) is None
    # and __fields_set__ contains the field
    if self.invoice_settings is None and 'invoice_settings' in self.__fields_set__:
      _dict['invoice_settings'] = None

    # set to None if status (nullable) is None
    # and __fields_set__ contains the field
    if self.status is None and 'status' in self.__fields_set__:
      _dict['status'] = None

    # set to None if phone_number (nullable) is None
    # and __fields_set__ contains the field
    if self.phone_number is None and 'phone_number' in self.__fields_set__:
      _dict['phone_number'] = None

    return _dict

  @classmethod
  def from_dict(cls, obj: dict) -> CustomerExternal:
    """Create an instance of CustomerExternal from a dict"""
    if obj is None:
      return None

    if not isinstance(obj, dict):
      return CustomerExternal.parse_obj(obj)

    _obj = CustomerExternal.parse_obj(
      {
        'id': obj.get('id'),
        'object': obj.get('object'),
        'created_at': obj.get('created_at'),
        'updated_at': obj.get('updated_at'),
        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
        'account_id': obj.get('account_id'),
        'email': obj.get('email'),
        'first_name': obj.get('first_name'),
        'last_name': obj.get('last_name'),
        'address':
          CompleteAddress.from_dict(obj.get('address')) if obj.get('address') is not None else None,
        'subscriptions':
          [SubscriptionExternal.from_dict(_item) for _item in obj.get('subscriptions')]
          if obj.get('subscriptions') is not None else None,
        'balance_atoms':
          [CustomerBalanceExternal.from_dict(_item) for _item in obj.get('balance_atoms')]
          if obj.get('balance_atoms') is not None else None,
        'subscribed_to_products':
          [ProductExternal.from_dict(_item) for _item in obj.get('subscribed_to_products')]
          if obj.get('subscribed_to_products') is not None else None,
        'last_successful_payment_intent':
          PaymentIntentExternal.from_dict(obj.get('last_successful_payment_intent'))
          if obj.get('last_successful_payment_intent') is not None else None,
        'discount':
          DiscountExternal.from_dict(obj.get('discount'))
          if obj.get('discount') is not None else None,
        'metadata': obj.get('metadata'),
        'notes': obj.get('notes'),
        'custom_fields': obj.get('custom_fields'),
        'total_spent':
          [CustomerTotalAmount.from_dict(_item) for _item in obj.get('total_spent')]
          if obj.get('total_spent') is not None else None,
        'total_refunds':
          [CustomerTotalAmount.from_dict(_item) for _item in obj.get('total_refunds')]
          if obj.get('total_refunds') is not None else None,
        'mrr':
          [CustomerTotalAmount.from_dict(_item) for _item in obj.get('mrr')]
          if obj.get('mrr') is not None else None,
        'billing_email': obj.get('billing_email'),
        'language': obj.get('language'),
        'invoice_settings':
          CustomerInvoiceSettings.from_dict(obj.get('invoice_settings'))
          if obj.get('invoice_settings') is not None else None,
        'should_send_payment_receipt': obj.get('should_send_payment_receipt'),
        'status': obj.get('status'),
        'phone_number': obj.get('phone_number')
      }
    )
    return _obj


from getopenpay.models.payment_intent_external import PaymentIntentExternal

CustomerExternal.update_forward_refs()
